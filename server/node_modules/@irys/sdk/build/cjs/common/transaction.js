"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
/**
 * Extended DataItem that allows for seamless Irys operations, such as signing and uploading.
 * Takes the same parameters as a regular DataItem.
 */
function buildIrysTransaction(irys) {
    class IrysTransaction extends irys.arbundles.DataItem {
        constructor(data, irys, opts) {
            var _a;
            super((opts === null || opts === void 0 ? void 0 : opts.dataIsRawTransaction) === true
                ? Buffer.from(data)
                : irys.arbundles
                    .createData(data, irys.tokenConfig.getSigner(), Object.assign(Object.assign({}, opts), { anchor: (_a = opts === null || opts === void 0 ? void 0 : opts.anchor) !== null && _a !== void 0 ? _a : crypto_1.default.randomBytes(32).toString("base64").slice(0, 32) }))
                    .getRaw());
            this.Irys = irys;
            this.signer = irys.tokenConfig.getSigner();
        }
        sign() {
            return super.sign(this.signer);
        }
        get size() {
            return this.getRaw().length;
        }
        uploadWithReceipt(opts) {
            return __awaiter(this, void 0, void 0, function* () {
                return (yield this.Irys.uploader.uploadTransaction(this, Object.assign(Object.assign({}, opts), { getReceiptSignature: true }))).data;
            });
        }
        upload(opts) {
            return __awaiter(this, void 0, void 0, function* () {
                return (yield this.Irys.uploader.uploadTransaction(this, opts)).data;
            });
        }
        // static fromRaw(rawTransaction: Buffer, IrysInstance: Irys): IrysTransaction {
        //   return new IrysTransaction(rawTransaction, IrysInstance, { dataIsRawTransaction: true });
        // }
        getPrice() {
            return __awaiter(this, void 0, void 0, function* () {
                return this.Irys.utils.getPrice(this.Irys.tokenConfig.name, this.size);
            });
        }
        isValid() {
            return __awaiter(this, void 0, void 0, function* () {
                return irys.arbundles.DataItem.verify(this.getRaw());
            });
        }
    }
    return IrysTransaction;
}
exports.default = buildIrysTransaction;
// export abstract class IrysTransaction extends DataItem {}
// export interface IrysTransaction extends DataItem {
//   size: number;
//   uploadWithReceipt(opts?: UploadOptions): Promise<UploadReceipt>;
//   upload(opts: UploadOptions & { getReceiptSignature: true }): Promise<UploadReceipt>;
//   upload(opts?: UploadOptions): Promise<UploadResponse>;
// }
//# sourceMappingURL=transaction.js.map