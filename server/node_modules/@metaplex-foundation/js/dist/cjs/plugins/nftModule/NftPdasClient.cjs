'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = require('buffer');
var DelegateType = require('./DelegateType.cjs');
var Pda = require('../../types/Pda.cjs');
var BigNumber = require('../../types/BigNumber.cjs');

/**
 * This client allows you to build PDAs related to the NFT module.
 *
 * @see {@link NftClient}
 * @group Module Pdas
 */
class NftPdasClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  /** Finds the Metadata PDA of a given mint address. */
  metadata({
    mint,
    programs
  }) {
    const programId = this.programId(programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), mint.toBuffer()]);
  }

  /** Finds the Master Edition PDA of a given mint address. */
  masterEdition({
    mint,
    programs
  }) {
    const programId = this.programId(programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), mint.toBuffer(), buffer.Buffer.from('edition', 'utf8')]);
  }

  /** Finds the Edition PDA of a given mint address. */
  edition(input) {
    return this.masterEdition(input);
  }

  /** Finds the Edition Marker PDA of a given edition number. */
  editionMarker({
    mint,
    edition,
    programs
  }) {
    const programId = this.programId(programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), mint.toBuffer(), buffer.Buffer.from('edition', 'utf8'), buffer.Buffer.from(edition.div(BigNumber.toBigNumber(248)).toString())]);
  }

  /** Finds the collection authority PDA for a given NFT and authority. */
  collectionAuthorityRecord({
    mint,
    collectionAuthority,
    programs
  }) {
    const programId = this.programId(programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), mint.toBuffer(), buffer.Buffer.from('collection_authority', 'utf8'), collectionAuthority.toBuffer()]);
  }

  /** Finds the use authority PDA for a given NFT and user. */
  useAuthorityRecord({
    mint,
    useAuthority,
    programs
  }) {
    const programId = this.programId(programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), mint.toBuffer(), buffer.Buffer.from('user', 'utf8'), useAuthority.toBuffer()]);
  }

  /** Finds the burner PDA of the Token Metadata program. */
  burner({
    programs
  }) {
    const programId = this.programId(programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), buffer.Buffer.from('burn', 'utf8')]);
  }

  /** Finds the record PDA for a given NFT and delegate authority. */
  tokenRecord(input) {
    const programId = this.programId(input.programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), input.mint.toBuffer(), buffer.Buffer.from('token_record', 'utf8'), input.token.toBuffer()]);
  }

  /** Finds the record PDA for a given NFT and delegate authority. */
  metadataDelegateRecord(input) {
    const programId = this.programId(input.programs);
    return Pda.Pda.find(programId, [buffer.Buffer.from('metadata', 'utf8'), programId.toBuffer(), input.mint.toBuffer(), buffer.Buffer.from(DelegateType.getMetadataDelegateRoleSeed(input.type), 'utf8'), input.updateAuthority.toBuffer(), input.delegate.toBuffer()]);
  }
  programId(programs) {
    return this.metaplex.programs().getTokenMetadata(programs).address;
  }
}

exports.NftPdasClient = NftPdasClient;
//# sourceMappingURL=NftPdasClient.cjs.map
