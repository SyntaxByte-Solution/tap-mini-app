{"version":3,"file":"transferCompressedNft.mjs","sources":["../../../../../src/plugins/nftModule/operations/transferCompressedNft.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport { createTransferInstruction } from '@metaplex-foundation/mpl-bubblegum';\nimport {\n  MerkleTree,\n  ConcurrentMerkleTreeAccount,\n  SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  SPL_NOOP_PROGRAM_ID,\n} from '@solana/spl-account-compression';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  TokenMetadataAuthorityHolder,\n  TokenMetadataAuthorityTokenDelegate,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { Sft } from '../models';\nimport { Metaplex } from '@/Metaplex';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  GetAssetProofRpcResponse,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  useOperation,\n  TransferNftCompressionParam,\n  ReadApiAsset,\n} from '@/types';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'TransferCompressedNftOperation' as const;\n\n/**\n * Transfers a compressed NFT or SFT from one account to another.\n *\n * ```ts\n * await metaplex.nfts().transfer({\n *   nftOrSft,\n *   toOwner,\n * });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const transferCompressedNftOperation =\n  useOperation<TransferCompressedNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type TransferCompressedNftOperation = Operation<\n  typeof Key,\n  TransferCompressedNftInput,\n  TransferCompressedNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type TransferCompressedNftInput = {\n  /**\n   * The compressed NFT or SFT to transfer.\n   * We only need its address and token standard.\n   */\n  nftOrSft: Sft;\n\n  /**\n   * An authority allowed to transfer the asset.\n   *\n   * Note that Metadata authorities are\n   * not supported for this instruction.\n   *\n   * If a `Signer` is provided directly,\n   * it will be used as an Holder authority.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?:\n    | Signer\n    | TokenMetadataAuthorityTokenDelegate\n    | TokenMetadataAuthorityHolder;\n\n  /**\n   * The authorization rules and data to use for the transfer.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The wallet to get the tokens from.\n   *\n   * @defaultValue The public key of the provided authority.\n   */\n  fromOwner?: PublicKey;\n\n  /**\n   * The token account to be debited.\n   *\n   * @defaultValue Defaults to the associated token account of `fromOwner`.\n   */\n  fromToken?: PublicKey;\n\n  /**\n   * The wallet to send the tokens to.\n   */\n  toOwner: PublicKey;\n\n  /**\n   * The token account to be credited.\n   *\n   * @defaultValue Defaults to the associated token account of `toOwner`.\n   */\n  toToken?: PublicKey;\n\n  /**\n   * The amount of tokens to transfer.\n   *\n   * @defaultValue `token(1)`\n   */\n  amount?: SplTokenAmount;\n\n  /**\n   * The compression data needed for transfer.\n   * Including the assetProof, concurrent merkle tree account info, and compression metadata.\n   */\n  compression: TransferNftCompressionParam;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type TransferCompressedNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const transferCompressedNftOperationHandler: OperationHandler<TransferCompressedNftOperation> =\n  {\n    handle: async (\n      operation: TransferCompressedNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TransferCompressedNftOutput> => {\n      return transferCompressedNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type TransferCompressedNftBuilderParams = Omit<\n  TransferCompressedNftInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Transfers a compressed NFT from one account to another.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .transfer({\n *     nftOrSft,\n *     toOwner,\n *     compression,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const transferCompressedNftBuilder = (\n  metaplex: Metaplex,\n  params: TransferCompressedNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { toOwner, compression } = params;\n\n  // ensure all required compression data has been supplied\n  if (\n    !compression.merkleTree ||\n    !compression.assetProof ||\n    !compression.data ||\n    !compression.ownership\n  )\n    throw Error('Invalid compression data supplied');\n\n  const merkleTree = new PublicKey(compression.assetProof.tree_id);\n  const treeAuthority = compression.merkleTree?.getAuthority();\n  const canopyDepth = compression.merkleTree?.getCanopyDepth();\n\n  const leafOwner = new PublicKey(compression.ownership.owner);\n  const leafDelegate = !!compression.ownership?.delegate\n    ? new PublicKey(compression.ownership.delegate)\n    : leafOwner;\n\n  // check if the provided assetProof path is valid for the provided root\n  if (\n    !MerkleTree.verify(new PublicKey(compression.assetProof.root).toBuffer(), {\n      leafIndex: compression.data.leaf_id,\n      leaf: new PublicKey(compression.assetProof.leaf).toBuffer(),\n      root: new PublicKey(compression.assetProof.root).toBuffer(),\n      proof: compression.assetProof.proof.map((node: string) =>\n        new PublicKey(node).toBuffer()\n      ),\n    })\n  )\n    throw Error('Provided proof path did not pass verification');\n\n  // parse the list of proof addresses into a valid AccountMeta[]\n  const proofPath = compression.assetProof.proof\n    .map((node: string) => ({\n      pubkey: new PublicKey(node),\n      isSigner: false,\n      isWritable: false,\n    }))\n    .slice(\n      0,\n      compression.assetProof.proof.length - (!!canopyDepth ? canopyDepth : 0)\n    );\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createTransferInstruction(\n        {\n          merkleTree,\n          treeAuthority,\n          leafOwner,\n          leafDelegate,\n          newLeafOwner: toOwner,\n          logWrapper: SPL_NOOP_PROGRAM_ID,\n          compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n          anchorRemainingAccounts: proofPath,\n        },\n        {\n          root: [\n            ...new PublicKey(compression.assetProof.root.trim()).toBytes(),\n          ],\n          dataHash: [\n            ...new PublicKey(compression.data.data_hash.trim()).toBytes(),\n          ],\n          creatorHash: [\n            ...new PublicKey(compression.data.creator_hash.trim()).toBytes(),\n          ],\n          nonce: compression.data.leaf_id,\n          index: compression.data.leaf_id,\n        }\n      ),\n      signers: [payer],\n      key: params.instructionKey ?? 'transferCompressedNft',\n    });\n};\n\n/**\n * Helper function to auto fetch the asset proof data from the ReadApi\n */\nexport async function prepareTransferCompressedNftBuilder(\n  metaplex: Metaplex,\n  params: TransferCompressedNftBuilderParams\n): Promise<TransferCompressedNftBuilderParams> {\n  if (!params?.compression) params.compression = {};\n\n  // auto fetch the assetProof data from the ReadApi, when not provided\n  if (!params?.compression?.assetProof) {\n    params.compression.assetProof = (await metaplex\n      .rpc()\n      .getAssetProof(params.nftOrSft.address)) as GetAssetProofRpcResponse;\n  }\n\n  const [asset, merkleTree] = await Promise.all([\n    // get the asset from the ReadApi\n    metaplex.rpc().getAsset(params.nftOrSft.address),\n\n    // get the on-chain merkle tree AccountInfo (mainly needed for the `canopyHeight`)\n    ConcurrentMerkleTreeAccount.fromAccountAddress(\n      metaplex.connection,\n      new PublicKey(params.compression.assetProof.tree_id)\n    ),\n  ]);\n\n  // update the params data for use by the transfer operation\n  params.compression.merkleTree = merkleTree;\n  params.compression.data = (asset as ReadApiAsset).compression;\n  params.compression.ownership = (asset as ReadApiAsset).ownership;\n\n  return params as TransferCompressedNftBuilderParams;\n}\n"],"names":["Key","transferCompressedNftOperation","useOperation","transferCompressedNftOperationHandler","handle","operation","metaplex","scope","transferCompressedNftBuilder","input","sendAndConfirm","confirmOptions","params","options","payer","rpc","getDefaultFeePayer","toOwner","compression","merkleTree","assetProof","data","ownership","Error","PublicKey","tree_id","treeAuthority","getAuthority","canopyDepth","getCanopyDepth","leafOwner","owner","leafDelegate","delegate","MerkleTree","verify","root","toBuffer","leafIndex","leaf_id","leaf","proof","map","node","proofPath","pubkey","isSigner","isWritable","slice","length","TransactionBuilder","make","setFeePayer","add","instruction","createTransferInstruction","newLeafOwner","logWrapper","SPL_NOOP_PROGRAM_ID","compressionProgram","SPL_ACCOUNT_COMPRESSION_PROGRAM_ID","anchorRemainingAccounts","trim","toBytes","dataHash","data_hash","creatorHash","creator_hash","nonce","index","signers","key","instructionKey","prepareTransferCompressedNftBuilder","getAssetProof","nftOrSft","address","asset","Promise","all","getAsset","ConcurrentMerkleTreeAccount","fromAccountAddress","connection"],"mappings":"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"}