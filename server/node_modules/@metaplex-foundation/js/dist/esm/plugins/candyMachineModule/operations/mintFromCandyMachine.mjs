import { createMintInstruction } from '@metaplex-foundation/mpl-candy-guard';
import { createMintInstruction as createMintInstruction$1 } from '@metaplex-foundation/mpl-candy-machine-core';
import { Keypair, SYSVAR_SLOT_HASHES_PUBKEY, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';
import { CandyMachineBotTaxError } from '../errors.mjs';
import { makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';
import { token } from '../../../types/Amount.mjs';
import { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';

// -----------------
// Operation
// -----------------

const Key = 'MintFromCandyMachineOperation';

/**
 * Mints the next NFT from a given candy machine.
 *
 * ```ts
 * const { nft } = await metaplex
 *   .candyMachines()
 *   .mint({
 *     candyMachine,
 *     collectionUpdateAuthority,
 *   };
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const mintFromCandyMachineOperation = _mintFromCandyMachineOperation;
// eslint-disable-next-line @typescript-eslint/naming-convention
function _mintFromCandyMachineOperation(input) {
  return {
    key: Key,
    input
  };
}
_mintFromCandyMachineOperation.key = Key;

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const mintFromCandyMachineOperationHandler = {
  async handle(operation, metaplex, scope) {
    const builder = await mintFromCandyMachineBuilder(metaplex, operation.input, scope);
    scope.throwIfCanceled();
    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);
    const output = await builder.sendAndConfirm(metaplex, confirmOptions);
    scope.throwIfCanceled();
    let nft;
    try {
      nft = await metaplex.nfts().findByMint({
        mintAddress: output.mintSigner.publicKey,
        tokenAddress: output.tokenAddress
      }, scope);
    } catch (error) {
      const {
        candyGuard
      } = operation.input.candyMachine;
      if (!candyGuard) {
        throw error;
      }
      const activeGuards = metaplex.candyMachines().guards().resolveGroupSettings(candyGuard.guards, candyGuard.groups, operation.input.group ?? null);
      if (!('botTax' in activeGuards)) {
        throw error;
      }
      throw new CandyMachineBotTaxError(metaplex.rpc().getSolanaExporerUrl(output.response.signature), error);
    }
    return {
      nft,
      ...output
    };
  }
};

// -----------------
// Builder
// -----------------

/**
 * @group Transaction Builders
 * @category Inputs
 */

/**
 * Mints the next NFT from a given candy machine.
 *
 * ```ts
 * const transactionBuilder = await metaplex
 *   .candyMachines()
 *   .builders()
 *   .mint({
 *     candyMachine,
 *     collectionUpdateAuthority,
 *   });
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */
const mintFromCandyMachineBuilder = async (metaplex, params, options = {}) => {
  const {
    programs,
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const {
    candyMachine,
    collectionUpdateAuthority,
    mintAuthority = metaplex.identity(),
    mint = Keypair.generate(),
    owner = payer.publicKey,
    group = null,
    guards = {},
    token: token$1
  } = params;

  // Programs.
  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);
  const candyGuardProgram = metaplex.programs().getCandyGuard(programs);
  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);
  const tokenProgram = metaplex.programs().getToken(programs);
  const systemProgram = metaplex.programs().getSystem(programs);

  // PDAs.
  const authorityPda = metaplex.candyMachines().pdas().authority({
    candyMachine: candyMachine.address,
    programs
  });
  const nftMetadata = metaplex.nfts().pdas().metadata({
    mint: mint.publicKey,
    programs
  });
  const nftMasterEdition = metaplex.nfts().pdas().masterEdition({
    mint: mint.publicKey,
    programs
  });
  const collectionMetadata = metaplex.nfts().pdas().metadata({
    mint: candyMachine.collectionMintAddress,
    programs
  });
  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({
    mint: candyMachine.collectionMintAddress,
    programs
  });
  const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({
    mint: candyMachine.collectionMintAddress,
    collectionAuthority: authorityPda,
    programs
  });

  // Transaction Builder that prepares the mint and token accounts.
  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({
    decimals: 0,
    initialSupply: token(1),
    mint,
    mintAuthority: payer,
    freezeAuthority: payer.publicKey,
    owner,
    token: token$1,
    createMintAccountInstructionKey: params.createMintAccountInstructionKey,
    initializeMintInstructionKey: params.initializeMintInstructionKey,
    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,
    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,
    initializeTokenInstructionKey: params.initializeTokenInstructionKey,
    mintTokensInstructionKey: params.mintTokensInstructionKey
  }, {
    payer,
    programs
  });
  const {
    tokenAddress
  } = tokenWithMintBuilder.getContext();

  // Shared mint accounts
  const sharedMintAccounts = {
    candyMachine: candyMachine.address,
    payer: payer.publicKey,
    nftMetadata,
    nftMint: mint.publicKey,
    nftMintAuthority: payer.publicKey,
    nftMasterEdition,
    collectionAuthorityRecord,
    collectionMint: candyMachine.collectionMintAddress,
    collectionMetadata,
    collectionMasterEdition,
    collectionUpdateAuthority,
    candyMachineProgram: candyMachineProgram.address,
    tokenMetadataProgram: tokenMetadataProgram.address,
    tokenProgram: tokenProgram.address,
    systemProgram: systemProgram.address,
    recentSlothashes: SYSVAR_SLOT_HASHES_PUBKEY,
    instructionSysvarAccount: SYSVAR_INSTRUCTIONS_PUBKEY
  };

  // Mint instruction.
  let mintNftInstruction;
  let mintNftSigners;
  if (!!candyMachine.candyGuard) {
    const {
      candyGuard
    } = candyMachine;
    const guardClient = metaplex.candyMachines().guards();
    const parsedMintSettings = guardClient.parseMintSettings(candyMachine.address, candyGuard, owner, payer, mint, guards, group, programs);
    mintNftSigners = [payer, mint, ...parsedMintSettings.signers];
    mintNftInstruction = createMintInstruction({
      ...sharedMintAccounts,
      candyGuard: candyMachine.candyGuard.address,
      candyMachineAuthorityPda: authorityPda
    }, {
      mintArgs: parsedMintSettings.arguments,
      label: group
    }, candyGuardProgram.address);
    mintNftInstruction.keys.push(...parsedMintSettings.accountMetas);
  } else {
    mintNftSigners = [payer, mint, mintAuthority];
    mintNftInstruction = createMintInstruction$1({
      ...sharedMintAccounts,
      authorityPda,
      mintAuthority: mintAuthority.publicKey
    }, candyMachineProgram.address);
  }
  return TransactionBuilder.make().setFeePayer(payer).setContext({
    tokenAddress,
    mintSigner: mint
  })

  // Create token and mint accounts.
  .add(tokenWithMintBuilder)

  // Mint the new NFT.
  .add({
    instruction: mintNftInstruction,
    signers: mintNftSigners,
    key: params.mintFromCandyMachineInstructionKey ?? 'mintNft'
  });
};

export { mintFromCandyMachineBuilder, mintFromCandyMachineOperation, mintFromCandyMachineOperationHandler };
//# sourceMappingURL=mintFromCandyMachine.mjs.map
