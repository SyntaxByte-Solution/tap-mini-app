"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const aptos_1 = require("aptos");
const arbundles_1 = require("arbundles");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const token_1 = require("../token");
const js_sha3_1 = __importDefault(require("js-sha3"));
const async_retry_1 = __importDefault(require("async-retry"));
// import { Transaction_UserTransaction, TransactionPayload_EntryFunctionPayload, UserTransaction, } from "aptos/src/generated";
class AptosConfig extends token_1.BaseNodeToken {
    constructor(config) {
        var _a, _b;
        if (typeof config.wallet === "string" && config.wallet.length === 66)
            config.wallet = Buffer.from(config.wallet.slice(2), "hex");
        if (!((_a = config === null || config === void 0 ? void 0 : config.opts) === null || _a === void 0 ? void 0 : _a.signingFunction) && Buffer.isBuffer(config === null || config === void 0 ? void 0 : config.wallet)) {
            // @ts-expect-error custom prop
            config.accountInstance = new aptos_1.AptosAccount(config.wallet);
        }
        super(config);
        this.txLock = Promise.resolve();
        this.locked = false;
        // @ts-expect-error assignment doesn't carry through for some reason
        this.accountInstance = config.accountInstance;
        this.signingFn = (_b = config === null || config === void 0 ? void 0 : config.opts) === null || _b === void 0 ? void 0 : _b.signingFunction;
        this.needsFee = true;
        this.base = ["aptom", 1e8];
    }
    getProvider() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return ((_a = this.providerInstance) !== null && _a !== void 0 ? _a : (this.providerInstance = new aptos_1.AptosClient(this.providerUrl)));
        });
    }
    getTx(txId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            const tx = (yield client.waitForTransactionWithResult(txId /* , { checkSuccess: true } */));
            const payload = tx === null || tx === void 0 ? void 0 : tx.payload;
            if (!tx.success) {
                throw new Error((_a = tx === null || tx === void 0 ? void 0 : tx.vm_status) !== null && _a !== void 0 ? _a : "Unknown Aptos error");
            }
            if (!((payload === null || payload === void 0 ? void 0 : payload.function) === "0x1::coin::transfer" &&
                (payload === null || payload === void 0 ? void 0 : payload.type_arguments[0]) === "0x1::aptos_coin::AptosCoin" &&
                (tx === null || tx === void 0 ? void 0 : tx.vm_status) === "Executed successfully")) {
                throw new Error(`Aptos tx ${txId} failed validation`);
            }
            const isPending = tx.type === "pending_transaction";
            return {
                to: payload.arguments[0],
                from: tx.sender,
                amount: new bignumber_js_1.default(payload.arguments[1]),
                pending: isPending,
                confirmed: !isPending,
            };
        });
    }
    ownerToAddress(owner) {
        const hash = js_sha3_1.default.sha3_256.create();
        hash.update(Buffer.from(owner));
        hash.update("\x00");
        return `0x${hash.hex()}`;
    }
    sign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getSigner().sign(data);
        });
    }
    getSigner() {
        if (this.signerInstance)
            return this.signerInstance;
        if (this.signingFn) {
            const signer = new arbundles_1.AptosSigner("", "0x" + this.getPublicKey().toString("hex"));
            signer.sign = this.signingFn; // override signer fn
            return (this.signerInstance = signer);
        }
        else {
            return (this.signerInstance = new arbundles_1.AptosSigner(this.accountInstance.toPrivateKeyObject().privateKeyHex, this.accountInstance.toPrivateKeyObject().publicKeyHex));
        }
    }
    verify(pub, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield arbundles_1.AptosSigner.verify(pub, data, signature);
        });
    }
    getCurrentHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            return new bignumber_js_1.default((yield (yield this.getProvider()).client.blocks.httpRequest.request({ method: "GET", url: "/" })).block_height);
        });
    }
    getFee(amount, to) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            const client = yield this.getProvider();
            const builder = new aptos_1.TransactionBuilderRemoteABI(client, { sender: this.address });
            const rawTransaction = yield builder.build("0x1::coin::transfer", ["0x1::aptos_coin::AptosCoin"], [to !== null && to !== void 0 ? to : "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new bignumber_js_1.default(amount).toNumber()]);
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const txnBuilder = new aptos_1.TransactionBuilderEd25519((_signingMessage) => {
                const invalidSigBytes = new Uint8Array(64);
                return new aptos_1.TxnBuilderTypes.Ed25519Signature(invalidSigBytes);
            }, this.getPublicKey());
            const signedSimulation = txnBuilder.sign(rawTransaction);
            const queryParams = {
                estimate_gas_unit_price: true,
                estimate_max_gas_amount: true,
            };
            const simulationResult = yield (0, async_retry_1.default)((_) => __awaiter(this, void 0, void 0, function* () {
                const simulationResult = yield client.client.request.request({
                    url: "/transactions/simulate",
                    query: queryParams,
                    method: "POST",
                    body: signedSimulation,
                    mediaType: "application/x.aptos.signed_transaction+bcs",
                });
                if (!simulationResult[0].success || simulationResult[0].gas_used === "0")
                    throw new Error(`Tx simulation failed`);
                return simulationResult;
            }), { retries: 10 }).catch((_) => [{ gas_unit_price: "100", gas_used: "10" }]);
            return { gasUnitPrice: +simulationResult[0].gas_unit_price, maxGasAmount: Math.ceil(+simulationResult[0].gas_used * 2) };
            // const simulationResult = await client.simulateTransaction(this.accountInstance, rawTransaction, { estimateGasUnitPrice: true, estimateMaxGasAmount: true });
            // return new BigNumber(simulationResult?.[0].gas_unit_price).multipliedBy(simulationResult?.[0].gas_used);
            // const est = await provider.client.transactions.estimateGasPrice();
            // return new BigNumber(est.gas_estimate/* (await (await this.getProvider()).client.transactions.estimateGasPrice()).gas_estimate */); // * by gas limit (for upper limit)
        });
    }
    sendTx(data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const s = yield provider.submitSignedBCSTransaction(data.tx);
            yield provider.waitForTransactionWithResult(s.hash);
            (_a = data.unlock) === null || _a === void 0 ? void 0 : _a.call(data);
            return s.hash;
        });
    }
    createTx(amount, to, fee) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run irys.ready()");
            // mutex so multiple aptos txs aren't in flight with the same sequence number
            const unlock = yield this.lock();
            const client = yield this.getProvider();
            const builder = new aptos_1.TransactionBuilderRemoteABI(client, {
                sender: this.address,
                gasUnitPrice: BigInt((_a = fee === null || fee === void 0 ? void 0 : fee.gasUnitPrice) !== null && _a !== void 0 ? _a : 100),
                maxGasAmount: BigInt((_b = fee === null || fee === void 0 ? void 0 : fee.maxGasAmount) !== null && _b !== void 0 ? _b : 10),
            });
            const rawTransaction = yield builder.build("0x1::coin::transfer", ["0x1::aptos_coin::AptosCoin"], [to, new bignumber_js_1.default(amount).toNumber()]);
            // const bcsTxn = AptosClient.generateBCSTransaction(this.accountInstance, rawTransaction);
            const signingMessage = aptos_1.TransactionBuilder.getSigningMessage(rawTransaction);
            const sig = yield this.sign(signingMessage);
            const txnBuilder = new aptos_1.TransactionBuilderEd25519((_) => {
                return new aptos_1.TxnBuilderTypes.Ed25519Signature(sig);
            }, this.getPublicKey());
            const bcsTxn = txnBuilder.sign(rawTransaction);
            return { txId: undefined, tx: { tx: bcsTxn, unlock } };
        });
    }
    getPublicKey() {
        var _a;
        if ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.signingFunction)
            return this.wallet;
        return Buffer.from(this.accountInstance.pubKey().toString().slice(2), "hex");
    }
    ready() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            this._address = yield client
                .lookupOriginalAddress((_a = this.address) !== null && _a !== void 0 ? _a : "")
                .then((hs) => hs.toString())
                .catch((_) => this._address); // fallback to original
            if (((_b = this._address) === null || _b === void 0 ? void 0 : _b.length) == 66 && this._address.charAt(2) === "0") {
                this._address = this._address.slice(0, 2) + this._address.slice(3);
            }
        });
    }
    // basic async mutex for transaction creation - done so sequenceNumbers don't overlap
    lock() {
        return __awaiter(this, void 0, void 0, function* () {
            this.locked = true;
            let unlockNext;
            const willLock = new Promise((r) => (unlockNext = r));
            willLock.then(() => (this.locked = false));
            const willUnlock = this.txLock.then(() => unlockNext);
            this.txLock = this.txLock.then(() => willLock);
            return willUnlock;
        });
    }
}
exports.default = AptosConfig;
//# sourceMappingURL=aptos.js.map