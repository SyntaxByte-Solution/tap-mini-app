"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeFetchUseAuthorityRecordFromSeeds = exports.fetchUseAuthorityRecordFromSeeds = exports.findUseAuthorityRecordPda = exports.getUseAuthorityRecordSize = exports.getUseAuthorityRecordGpaBuilder = exports.safeFetchAllUseAuthorityRecord = exports.fetchAllUseAuthorityRecord = exports.safeFetchUseAuthorityRecord = exports.fetchUseAuthorityRecord = exports.deserializeUseAuthorityRecord = exports.getUseAuthorityRecordAccountDataSerializer = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const types_1 = require("../types");
function getUseAuthorityRecordAccountDataSerializer() {
    return (0, serializers_1.mapSerializer)((0, serializers_1.struct)([
        ['key', (0, types_1.getKeySerializer)()],
        ['allowedUses', (0, serializers_1.u64)()],
        ['bump', (0, serializers_1.u8)()],
    ], { description: 'UseAuthorityRecordAccountData' }), (value) => ({ ...value, key: types_1.Key.UseAuthorityRecord }));
}
exports.getUseAuthorityRecordAccountDataSerializer = getUseAuthorityRecordAccountDataSerializer;
function deserializeUseAuthorityRecord(rawAccount) {
    return (0, umi_1.deserializeAccount)(rawAccount, getUseAuthorityRecordAccountDataSerializer());
}
exports.deserializeUseAuthorityRecord = deserializeUseAuthorityRecord;
async function fetchUseAuthorityRecord(context, publicKey, options) {
    const maybeAccount = await context.rpc.getAccount((0, umi_1.publicKey)(publicKey, false), options);
    (0, umi_1.assertAccountExists)(maybeAccount, 'UseAuthorityRecord');
    return deserializeUseAuthorityRecord(maybeAccount);
}
exports.fetchUseAuthorityRecord = fetchUseAuthorityRecord;
async function safeFetchUseAuthorityRecord(context, publicKey, options) {
    const maybeAccount = await context.rpc.getAccount((0, umi_1.publicKey)(publicKey, false), options);
    return maybeAccount.exists
        ? deserializeUseAuthorityRecord(maybeAccount)
        : null;
}
exports.safeFetchUseAuthorityRecord = safeFetchUseAuthorityRecord;
async function fetchAllUseAuthorityRecord(context, publicKeys, options) {
    const maybeAccounts = await context.rpc.getAccounts(publicKeys.map((key) => (0, umi_1.publicKey)(key, false)), options);
    return maybeAccounts.map((maybeAccount) => {
        (0, umi_1.assertAccountExists)(maybeAccount, 'UseAuthorityRecord');
        return deserializeUseAuthorityRecord(maybeAccount);
    });
}
exports.fetchAllUseAuthorityRecord = fetchAllUseAuthorityRecord;
async function safeFetchAllUseAuthorityRecord(context, publicKeys, options) {
    const maybeAccounts = await context.rpc.getAccounts(publicKeys.map((key) => (0, umi_1.publicKey)(key, false)), options);
    return maybeAccounts
        .filter((maybeAccount) => maybeAccount.exists)
        .map((maybeAccount) => deserializeUseAuthorityRecord(maybeAccount));
}
exports.safeFetchAllUseAuthorityRecord = safeFetchAllUseAuthorityRecord;
function getUseAuthorityRecordGpaBuilder(context) {
    const programId = context.programs.getPublicKey('mplTokenMetadata', 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
    return (0, umi_1.gpaBuilder)(context, programId)
        .registerFields({
        key: [0, (0, types_1.getKeySerializer)()],
        allowedUses: [1, (0, serializers_1.u64)()],
        bump: [9, (0, serializers_1.u8)()],
    })
        .deserializeUsing((account) => deserializeUseAuthorityRecord(account))
        .whereField('key', types_1.Key.UseAuthorityRecord);
}
exports.getUseAuthorityRecordGpaBuilder = getUseAuthorityRecordGpaBuilder;
function getUseAuthorityRecordSize() {
    return 10;
}
exports.getUseAuthorityRecordSize = getUseAuthorityRecordSize;
function findUseAuthorityRecordPda(context, seeds) {
    const programId = context.programs.getPublicKey('mplTokenMetadata', 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
    return context.eddsa.findPda(programId, [
        (0, serializers_1.string)({ size: 'variable' }).serialize('metadata'),
        (0, serializers_1.publicKey)().serialize(programId),
        (0, serializers_1.publicKey)().serialize(seeds.mint),
        (0, serializers_1.string)({ size: 'variable' }).serialize('user'),
        (0, serializers_1.publicKey)().serialize(seeds.useAuthority),
    ]);
}
exports.findUseAuthorityRecordPda = findUseAuthorityRecordPda;
async function fetchUseAuthorityRecordFromSeeds(context, seeds, options) {
    return fetchUseAuthorityRecord(context, findUseAuthorityRecordPda(context, seeds), options);
}
exports.fetchUseAuthorityRecordFromSeeds = fetchUseAuthorityRecordFromSeeds;
async function safeFetchUseAuthorityRecordFromSeeds(context, seeds, options) {
    return safeFetchUseAuthorityRecord(context, findUseAuthorityRecordPda(context, seeds), options);
}
exports.safeFetchUseAuthorityRecordFromSeeds = safeFetchUseAuthorityRecordFromSeeds;
//# sourceMappingURL=useAuthorityRecord.js.map