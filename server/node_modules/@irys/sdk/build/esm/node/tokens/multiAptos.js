import { TransactionBuilder, TransactionBuilderMultiEd25519, TxnBuilderTypes, BCS, AptosAccount, TransactionBuilderEd25519, TransactionBuilderRemoteABI, } from "aptos";
import BigNumber from "bignumber.js";
import Aptos from "./aptos.js";
import { MultiSignatureAptosSigner } from "arbundles";
export default class MultiSignatureAptos extends Aptos {
    collectSignatures;
    constructor(config) {
        super(config);
        this.collectSignatures = this?.opts?.collectSignatures;
        this.needsFee = true;
    }
    /**
     * @param owner compound MultiEd25519PublicKey .toBytes()
     */
    ownerToAddress(pubKey) {
        // deserialise key
        const multiSigPublicKey = this.deserialisePubKey(pubKey);
        // derive address
        const authKey2 = TxnBuilderTypes.AuthenticationKey.fromMultiEd25519PublicKey(multiSigPublicKey);
        return authKey2.derivedAddress().toString();
    }
    deserialisePubKey(pubKey) {
        const threshold = +pubKey.slice(32 * 32).toString();
        const keys = [];
        const nullBuf = Buffer.alloc(32, 0);
        for (let i = 0; i < 32; i++) {
            const key = pubKey.subarray(i * 32, (i + 1) * 32);
            if (!key.equals(nullBuf))
                keys.push(new TxnBuilderTypes.Ed25519PublicKey(key));
        }
        // reconstruct key
        return new TxnBuilderTypes.MultiEd25519PublicKey(keys, threshold);
    }
    getPublicKey() {
        const { participants, threshold } = this.wallet;
        const pkey = Buffer.alloc(32 * 32 + 1);
        participants.forEach((k, i) => {
            pkey.set(k, i * 32);
        });
        pkey.set(Buffer.from(threshold.toString()), 1024);
        return pkey;
    }
    async getFee(amount, to) {
        const client = await this.getProvider();
        if (!this.address)
            throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
        const builder = new TransactionBuilderRemoteABI(client, { sender: this.address });
        const rawTransaction = await builder.build("0x1::coin::transfer", ["0x1::aptos_coin::AptosCoin"], [to ?? "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new BigNumber(amount).toNumber()]);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const txnBuilder = new TransactionBuilderEd25519((_signingMessage) => {
            const invalidSigBytes = new Uint8Array(64);
            return new TxnBuilderTypes.Ed25519Signature(invalidSigBytes);
        }, new Uint8Array(32));
        const signedSimulation = txnBuilder.sign(rawTransaction);
        const queryParams = {
            estimate_gas_unit_price: true,
            estimate_max_gas_amount: true,
        };
        const simulationResult = await client.client.request.request({
            url: "/transactions/simulate",
            query: queryParams,
            method: "POST",
            body: signedSimulation,
            mediaType: "application/x.aptos.signed_transaction+bcs",
        });
        return { gasUnitPrice: +simulationResult[0].gas_unit_price, maxGasAmount: +simulationResult[0].max_gas_amount };
    }
    async createTx(amount, to, fee) {
        const client = await this.getProvider();
        const { participants, threshold } = this.wallet;
        const multiSigPublicKey = new TxnBuilderTypes.MultiEd25519PublicKey(participants.map((v) => new TxnBuilderTypes.Ed25519PublicKey(v)), threshold);
        const authKey = TxnBuilderTypes.AuthenticationKey.fromMultiEd25519PublicKey(multiSigPublicKey);
        const mutisigAccountAddress = authKey.derivedAddress();
        const token = new TxnBuilderTypes.TypeTagStruct(TxnBuilderTypes.StructTag.fromString("0x1::aptos_coin::AptosCoin"));
        const entryFunctionPayload = new TxnBuilderTypes.TransactionPayloadEntryFunction(TxnBuilderTypes.EntryFunction.natural(
        // Fully qualified module name, `AccountAddress::ModuleName`
        "0x1::coin", 
        // Module function
        "transfer", 
        // The coin type to transfer
        [token], 
        // Arguments for function `transfer`: receiver account address and amount to transfer
        [BCS.bcsToBytes(TxnBuilderTypes.AccountAddress.fromHex(to)), BCS.bcsSerializeUint64(new BigNumber(amount).toNumber())]));
        const [{ sequence_number: sequenceNumber }, chainId] = await Promise.all([client.getAccount(mutisigAccountAddress), client.getChainId()]);
        const rawTx = new TxnBuilderTypes.RawTransaction(
        // Transaction sender account address
        TxnBuilderTypes.AccountAddress.fromHex(mutisigAccountAddress), BigInt(sequenceNumber), entryFunctionPayload, 
        // Max gas unit to spend
        BigInt(fee?.maxGasAmount ?? 100_00), 
        // Gas price per unit
        BigInt(fee?.gasUnitPrice ?? 100), 
        // Expiration timestamp. Transaction is discarded if it is not executed within 1000 seconds (16.6 minutes) from now.
        BigInt(Math.floor(Date.now() / 1000) + 1000), new TxnBuilderTypes.ChainId(chainId));
        return { tx: rawTx, txId: undefined };
    }
    async sendTx(data) {
        const client = await this.getProvider();
        const signingMessage = TransactionBuilder.getSigningMessage(data);
        const { signatures, bitmap } = await this.collectSignatures(signingMessage);
        const txnBuilder = new TransactionBuilderMultiEd25519((_) => {
            // Bitmap masks which public key has signed transaction.
            // See https://aptos-labs.github.io/ts-sdk-doc/classes/TxnBuilderTypes.MultiEd25519Signature.html#createBitmap
            const encodedBitmap = TxnBuilderTypes.MultiEd25519Signature.createBitmap(bitmap);
            // See https://aptos-labs.github.io/ts-sdk-doc/classes/TxnBuilderTypes.MultiEd25519Signature.html#constructor
            const muliEd25519Sig = new TxnBuilderTypes.MultiEd25519Signature(signatures.map((s) => new TxnBuilderTypes.Ed25519Signature(s)), encodedBitmap);
            return muliEd25519Sig;
        }, this.deserialisePubKey(this.getPublicKey()));
        const bcsTxn = txnBuilder.sign(data);
        const txRes = await client.submitSignedBCSTransaction(bcsTxn);
        return txRes.hash;
    }
    getSigner() {
        if (this.signerInstance)
            return this.signerInstance;
        const pkey = Buffer.alloc(1025);
        const deserKey = this.deserialisePubKey(this.getPublicKey());
        deserKey.public_keys.forEach((k, i) => {
            pkey.set(k.value, i * 32);
        });
        pkey.set(Buffer.from(deserKey.threshold.toString()), 1024);
        return (this.signerInstance ??= new MultiSignatureAptosSigner(pkey, this.collectSignatures));
    }
    async ready() {
        await super.ready();
        this.accountInstance = new AptosAccount(undefined, this.address);
    }
    async verify(pub, data, signature) {
        return await MultiSignatureAptosSigner.verify(pub, data, signature);
    }
}
//# sourceMappingURL=multiAptos.js.map