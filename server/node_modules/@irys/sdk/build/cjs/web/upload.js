"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebUploader = void 0;
const upload_1 = __importDefault(require("../common/upload"));
const arbundles_1 = require("arbundles");
class WebUploader extends upload_1.default {
    constructor(irys) {
        super(irys.api, irys.utils, irys.token, irys.tokenConfig, irys.IrysTransaction);
        this.irys = irys;
    }
    /**
     * Uploads a tagged file object, automatically adding the content-type tag if it's not present
     * @param file - File object to upload
     * @param opts - optional options for the upload / data item creation
     * @returns
     */
    uploadFile(file, opts) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const hasContentType = (opts === null || opts === void 0 ? void 0 : opts.tags) ? opts.tags.some(({ name }) => name.toLowerCase() === "content-type") : false;
            const tags = hasContentType ? opts === null || opts === void 0 ? void 0 : opts.tags : [...((_a = opts === null || opts === void 0 ? void 0 : opts.tags) !== null && _a !== void 0 ? _a : []), { name: "Content-Type", value: file.type }];
            return this.uploadData(Buffer.from(yield file.arrayBuffer()), Object.assign({ tags }, opts));
        });
    }
    /**
     * Uploads a list of `File` objects & a generated folder manifest as a nested bundle using a temporary signing key.
     *
     * @param files list of `File` objects to upload - note: this code determines the paths via the File's `webkitRelativePath` property - if it's undefined, it falls back to file.name
     * @param {string} [opts.indexFileRelPath] Relative path for the index file, i.e `folder/index.html`
     * @param {Tag[]} [opts.manifestTags] List of tags to add onto the manifest transaction
     * @param {JWKInterface} [opts.throwawayKey] Provide your own throwaway JWK to use for signing the items in the bundle
     * @param {boolean} [opts.seperateManifestTx=false] Whether upload the manifest as a seperate tx (not in the nested bundle) - note: transactions in a nested bundle are not indexed by bundlr GQL - if you have tags you want to use to find the manifest, set this option to true
     *
     * @returns Standard upload response from the bundler node, plus the throwaway key & address, manifest, manifest TxId and the list of generated transactions
     */
    uploadFolder(files, opts) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const txs = [];
            const txMap = new Map();
            const throwawayKey = (_a = opts === null || opts === void 0 ? void 0 : opts.throwawayKey) !== null && _a !== void 0 ? _a : (yield this.irys.arbundles.getCryptoDriver().generateJWK());
            const ephemeralSigner = new arbundles_1.ArweaveSigner(throwawayKey);
            for (const file of files) {
                const path = file.webkitRelativePath ? file.webkitRelativePath : file.name;
                const hasContentType = file.tags ? file.tags.some(({ name }) => name.toLowerCase() === "content-type") : false;
                const tags = hasContentType ? file.tags : [...((_b = file.tags) !== null && _b !== void 0 ? _b : []), { name: "Content-Type", value: file.type }];
                const tx = this.irys.arbundles.createData(Buffer.from(yield file.arrayBuffer()), ephemeralSigner, {
                    tags,
                });
                yield tx.sign(ephemeralSigner);
                txs.push(tx);
                txMap.set(path, tx.id);
            }
            // generate manifest, add to bundle
            const manifest = yield this.generateManifest({ items: txMap, indexFile: opts === null || opts === void 0 ? void 0 : opts.indexFileRelPath });
            const manifestTx = this.irys.arbundles.createData(JSON.stringify(manifest), (opts === null || opts === void 0 ? void 0 : opts.seperateManifestTx) ? this.irys.tokenConfig.getSigner() : ephemeralSigner, {
                tags: [
                    { name: "Type", value: "manifest" },
                    { name: "Content-Type", value: "application/x.arweave-manifest+json" },
                    ...((_c = opts === null || opts === void 0 ? void 0 : opts.manifestTags) !== null && _c !== void 0 ? _c : []),
                ],
            });
            if ((opts === null || opts === void 0 ? void 0 : opts.seperateManifestTx) === true) {
                yield manifestTx.sign(this.irys.tokenConfig.getSigner());
                yield this.uploadTransaction(manifestTx, Object.assign({}, opts));
            }
            else {
                yield manifestTx.sign(ephemeralSigner);
                txs.push(manifestTx);
            }
            // upload bundle
            const bundleRes = yield this.uploadBundle(txs, Object.assign({}, opts));
            return Object.assign(Object.assign({}, bundleRes.data), { manifestId: manifestTx.id, manifest, throwawayKey: bundleRes.throwawayKey, throwawayKeyAddress: bundleRes.throwawayKeyAddress, txs: bundleRes.txs });
        });
    }
}
exports.WebUploader = WebUploader;
//# sourceMappingURL=upload.js.map