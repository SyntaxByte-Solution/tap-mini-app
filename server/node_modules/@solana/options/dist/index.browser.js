import { isFixedSize, assertIsFixedSize, createEncoder, getEncodedSize, createDecoder, combineCodec } from '@solana/codecs-core';
import { getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';

// src/option.ts
var some = (value) => ({ __option: "Some", value });
var none = () => ({ __option: "None" });
var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
var isSome = (option) => option.__option === "Some";
var isNone = (option) => option.__option === "None";

// src/unwrap-option.ts
function unwrapOption(option, fallback) {
  if (isSome(option))
    return option.value;
  return fallback ? fallback() : null;
}
var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();

// src/option-codec.ts
function getOptionEncoder(item, config = {}) {
  const prefix = config.prefix ?? getU8Encoder();
  const fixed = config.fixed ?? false;
  const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;
  if (fixed || isZeroSizeItem) {
    assertIsFixedSize(item, "Fixed options can only be used with fixed-size codecs.");
    assertIsFixedSize(prefix, "Fixed options can only be used with fixed-size prefix.");
    const fixedSize = prefix.fixedSize + item.fixedSize;
    return createEncoder({
      fixedSize,
      write: (optionOrNullable, bytes, offset) => {
        const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);
        const prefixOffset = prefix.write(Number(isSome(option)), bytes, offset);
        if (isSome(option)) {
          item.write(option.value, bytes, prefixOffset);
        }
        return offset + fixedSize;
      }
    });
  }
  return createEncoder({
    getSizeFromValue: (optionOrNullable) => {
      const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);
      return getEncodedSize(Number(isSome(option)), prefix) + (isSome(option) ? getEncodedSize(option.value, item) : 0);
    },
    maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? void 0,
    write: (optionOrNullable, bytes, offset) => {
      const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);
      offset = prefix.write(Number(isSome(option)), bytes, offset);
      if (isSome(option)) {
        offset = item.write(option.value, bytes, offset);
      }
      return offset;
    }
  });
}
function getOptionDecoder(item, config = {}) {
  const prefix = config.prefix ?? getU8Decoder();
  const fixed = config.fixed ?? false;
  let fixedSize = null;
  const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;
  if (fixed || isZeroSizeItem) {
    assertIsFixedSize(item, "Fixed options can only be used with fixed-size codecs.");
    assertIsFixedSize(prefix, "Fixed options can only be used with fixed-size prefix.");
    fixedSize = prefix.fixedSize + item.fixedSize;
  }
  return createDecoder({
    ...fixedSize === null ? { maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? void 0 } : { fixedSize },
    read: (bytes, offset) => {
      if (bytes.length - offset <= 0) {
        return [none(), offset];
      }
      const [isSome2, prefixOffset] = prefix.read(bytes, offset);
      if (isSome2 === 0) {
        return [none(), fixedSize !== null ? offset + fixedSize : prefixOffset];
      }
      const [value, newOffset] = item.read(bytes, prefixOffset);
      return [some(value), fixedSize !== null ? offset + fixedSize : newOffset];
    }
  });
}
function getOptionCodec(item, config = {}) {
  return combineCodec(getOptionEncoder(item, config), getOptionDecoder(item, config));
}
function sumCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
}
function getMaxSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
}

// src/unwrap-option-recursively.ts
function unwrapOptionRecursively(input, fallback) {
  if (!input || ArrayBuffer.isView(input)) {
    return input;
  }
  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
  if (isOption(input)) {
    if (isSome(input))
      return next(input.value);
    return fallback ? fallback() : null;
  }
  if (Array.isArray(input)) {
    return input.map(next);
  }
  if (typeof input === "object") {
    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
  }
  return input;
}

export { getOptionCodec, getOptionDecoder, getOptionEncoder, isNone, isOption, isSome, none, some, unwrapOption, unwrapOptionRecursively, wrapNullable };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.browser.js.map