'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var beet = require('@metaplex-foundation/beet');
var SdkError = require('../errors/SdkError.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var beet__namespace = /*#__PURE__*/_interopNamespace(beet);

const mapSerializer = (serializer, map, unmap) => ({
  description: serializer.description,
  serialize: value => serializer.serialize(unmap(value)),
  deserialize: (buffer, offset) => {
    const [value, newOffset] = serializer.deserialize(buffer, offset);
    return [map(value), newOffset];
  }
});
const createSerializerFromBeet = beetArg => ({
  description: beetArg.description,
  serialize: value => {
    const fixedBeet = beet__namespace.isFixableBeet(beetArg) ? beetArg.toFixedFromValue(value) : beetArg;
    const writer = new beet__namespace.BeetWriter(fixedBeet.byteSize);
    writer.write(fixedBeet, value);
    return writer.buffer;
  },
  deserialize: (buffer, offset) => {
    const fixedBeet = beet__namespace.isFixableBeet(beetArg) ? beetArg.toFixedFromData(buffer, offset ?? 0) : beetArg;
    const reader = new beet__namespace.BeetReader(buffer, offset ?? 0);
    const value = reader.read(fixedBeet);
    return [value, reader.offset];
  }
});
const createSerializerFromSolitaType = (solitaType, description) => ({
  description: description ?? solitaType.name,
  serialize: value => {
    return solitaType.fromArgs(value).serialize()[0];
  },
  deserialize: (buffer, offset) => {
    return solitaType.deserialize(buffer, offset);
  }
});
const serialize = (value, serializer) => {
  try {
    return serializer.serialize(value);
  } catch (error) {
    throw new SdkError.FailedToSerializeDataError(serializer.description, error);
  }
};
const deserialize = (value, serializer) => {
  try {
    return serializer.deserialize(value);
  } catch (error) {
    throw new SdkError.FailedToDeserializeDataError(serializer.description, error);
  }
};
function deserializeAccount(account, serializer) {
  if ('exists' in account && !account.exists) {
    return account;
  }
  try {
    const data = serializer.deserialize(account.data)[0];
    return {
      ...account,
      data
    };
  } catch (error) {
    throw new SdkError.UnexpectedAccountError(account.publicKey, serializer.description, error);
  }
}
const serializeDiscriminator = discriminator => {
  const serializer = createSerializerFromBeet(beet__namespace.uniformFixedSizeArray(beet__namespace.u8, 8));
  return serialize(discriminator, serializer);
};

exports.createSerializerFromBeet = createSerializerFromBeet;
exports.createSerializerFromSolitaType = createSerializerFromSolitaType;
exports.deserialize = deserialize;
exports.deserializeAccount = deserializeAccount;
exports.mapSerializer = mapSerializer;
exports.serialize = serialize;
exports.serializeDiscriminator = serializeDiscriminator;
//# sourceMappingURL=Serializer.cjs.map
