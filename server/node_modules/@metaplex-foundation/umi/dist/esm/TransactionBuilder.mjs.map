{"version":3,"file":"TransactionBuilder.mjs","sources":["../../src/TransactionBuilder.ts"],"sourcesContent":["import { SolAmount } from './Amount';\nimport type { Context } from './Context';\nimport { SdkError } from './errors';\nimport type {\n  AccountMeta,\n  Instruction,\n  SignerMeta,\n  WrappedInstruction,\n} from './Instruction';\nimport type {\n  RpcConfirmTransactionOptions,\n  RpcConfirmTransactionResult,\n  RpcConfirmTransactionStrategy,\n  RpcGetLatestBlockhashOptions,\n  RpcSendTransactionOptions,\n} from './RpcInterface';\nimport { Signer, signTransaction, uniqueSigners } from './Signer';\nimport {\n  AddressLookupTableInput,\n  Blockhash,\n  BlockhashWithExpiryBlockHeight,\n  Transaction,\n  TransactionInput,\n  TransactionSignature,\n  TransactionVersion,\n  TRANSACTION_SIZE_LIMIT,\n} from './Transaction';\n\n/**\n * Defines an generic object with wrapped instructions,\n * such as a {@link TransactionBuilder}.\n * @category Transactions\n */\nexport type HasWrappedInstructions = { items: WrappedInstruction[] };\n\n/**\n * Defines all the possible inputs for adding items to a transaction builder.\n * @category Transactions\n */\nexport type TransactionBuilderItemsInput =\n  | WrappedInstruction\n  | WrappedInstruction[]\n  | HasWrappedInstructions\n  | HasWrappedInstructions[];\n\n/**\n * The available options of a transaction builder.\n * @category Transactions\n */\nexport type TransactionBuilderOptions = {\n  /** The signer paying for the transaction fee. */\n  feePayer?: Signer;\n  /** The version of the transaction to build. */\n  version?: TransactionVersion;\n  /** The address lookup tables to attach to the built transaction. */\n  addressLookupTables?: AddressLookupTableInput[];\n  /** The blockhash that should be associated with the built transaction. */\n  blockhash?: Blockhash | BlockhashWithExpiryBlockHeight;\n};\n\n/**\n * A set of options to use when sending and confirming\n * a transaction directly from a transaction builder.\n * @category Transactions\n */\nexport type TransactionBuilderSendAndConfirmOptions = {\n  send?: RpcSendTransactionOptions;\n  confirm?: Partial<RpcConfirmTransactionOptions>;\n};\n\n/**\n * A builder that helps construct transactions.\n * @category Transactions\n */\nexport class TransactionBuilder implements HasWrappedInstructions {\n  constructor(\n    readonly items: WrappedInstruction[] = [],\n    readonly options: TransactionBuilderOptions = {}\n  ) {}\n\n  empty(): TransactionBuilder {\n    return new TransactionBuilder([], this.options);\n  }\n\n  setItems(input: TransactionBuilderItemsInput): TransactionBuilder {\n    return new TransactionBuilder(this.parseItems(input), this.options);\n  }\n\n  prepend(input: TransactionBuilderItemsInput): TransactionBuilder {\n    return new TransactionBuilder(\n      [...this.parseItems(input), ...this.items],\n      this.options\n    );\n  }\n\n  append(input: TransactionBuilderItemsInput): TransactionBuilder {\n    return new TransactionBuilder(\n      [...this.items, ...this.parseItems(input)],\n      this.options\n    );\n  }\n\n  add(input: TransactionBuilderItemsInput): TransactionBuilder {\n    return this.append(input);\n  }\n\n  mapInstructions(\n    fn: (\n      wrappedInstruction: WrappedInstruction,\n      index: number,\n      array: WrappedInstruction[]\n    ) => WrappedInstruction\n  ): TransactionBuilder {\n    return new TransactionBuilder(this.items.map(fn), this.options);\n  }\n\n  addRemainingAccounts(\n    accountMeta: AccountMeta | SignerMeta | (AccountMeta | SignerMeta)[],\n    instructionIndex?: number\n  ): TransactionBuilder {\n    instructionIndex = instructionIndex ?? this.items.length - 1;\n    const metas = Array.isArray(accountMeta) ? accountMeta : [accountMeta];\n    const extraKeys = metas.map((meta) =>\n      'pubkey' in meta\n        ? meta\n        : {\n            pubkey: meta.signer.publicKey,\n            isSigner: true,\n            isWritable: meta.isWritable,\n          }\n    );\n    const extraSigners = metas.flatMap((meta) =>\n      'pubkey' in meta ? [] : [meta.signer]\n    );\n    return this.mapInstructions((wrappedInstruction, index) => {\n      if (index !== instructionIndex) return wrappedInstruction;\n      const keys = [...wrappedInstruction.instruction.keys, ...extraKeys];\n      return {\n        ...wrappedInstruction,\n        instruction: { ...wrappedInstruction.instruction, keys },\n        signers: [...wrappedInstruction.signers, ...extraSigners],\n      };\n    });\n  }\n\n  splitByIndex(index: number): [TransactionBuilder, TransactionBuilder] {\n    return [\n      new TransactionBuilder(this.items.slice(0, index), this.options),\n      new TransactionBuilder(this.items.slice(index), this.options),\n    ];\n  }\n\n  /**\n   * Split the builder into multiple builders, such that\n   * each of them should fit in a single transaction.\n   *\n   * This method is unsafe for several reasons:\n   * - Because transactions are atomic, splitting the builder\n   *   into multiple transactions may cause undesired side effects.\n   *   For example, if the first transaction succeeds but the second\n   *   one fails, you may end up with an inconsistent account state.\n   *   This is why it is recommended to manually split your transactions\n   *   such that each of them is valid on its own.\n   * - It can only split the instructions of the builder. Meaning that,\n   *   if the builder has a single instruction that is too big to fit in\n   *   a single transaction, it will not be able to split it.\n   */\n  unsafeSplitByTransactionSize(\n    context: Pick<Context, 'transactions' | 'payer'>\n  ): TransactionBuilder[] {\n    return this.items.reduce(\n      (builders, item) => {\n        const lastBuilder = builders.pop() as TransactionBuilder;\n        const lastBuilderWithItem = lastBuilder.add(item);\n        if (lastBuilderWithItem.fitsInOneTransaction(context)) {\n          builders.push(lastBuilderWithItem);\n        } else {\n          builders.push(lastBuilder);\n          builders.push(lastBuilder.empty().add(item));\n        }\n        return builders;\n      },\n      [this.empty()]\n    );\n  }\n\n  setFeePayer(feePayer: Signer): TransactionBuilder {\n    return new TransactionBuilder(this.items, { ...this.options, feePayer });\n  }\n\n  getFeePayer(context: Pick<Context, 'payer'>): Signer {\n    return this.options.feePayer ?? context.payer;\n  }\n\n  setVersion(version: TransactionVersion): TransactionBuilder {\n    return new TransactionBuilder(this.items, { ...this.options, version });\n  }\n\n  useLegacyVersion(): TransactionBuilder {\n    return this.setVersion('legacy');\n  }\n\n  useV0(): TransactionBuilder {\n    return this.setVersion(0);\n  }\n\n  setAddressLookupTables(\n    addressLookupTables: AddressLookupTableInput[]\n  ): TransactionBuilder {\n    return new TransactionBuilder(this.items, {\n      ...this.options,\n      addressLookupTables,\n    });\n  }\n\n  getBlockhash(): Blockhash | undefined {\n    return typeof this.options.blockhash === 'object'\n      ? this.options.blockhash.blockhash\n      : this.options.blockhash;\n  }\n\n  setBlockhash(\n    blockhash: Blockhash | BlockhashWithExpiryBlockHeight\n  ): TransactionBuilder {\n    return new TransactionBuilder(this.items, { ...this.options, blockhash });\n  }\n\n  async setLatestBlockhash(\n    context: Pick<Context, 'rpc'>,\n    options: RpcGetLatestBlockhashOptions = {}\n  ): Promise<TransactionBuilder> {\n    return this.setBlockhash(await context.rpc.getLatestBlockhash(options));\n  }\n\n  getInstructions(): Instruction[] {\n    return this.items.map((item) => item.instruction);\n  }\n\n  getSigners(context: Pick<Context, 'payer'>): Signer[] {\n    return uniqueSigners([\n      this.getFeePayer(context),\n      ...this.items.flatMap((item) => item.signers),\n    ]);\n  }\n\n  getBytesCreatedOnChain(): number {\n    return this.items.reduce((sum, item) => sum + item.bytesCreatedOnChain, 0);\n  }\n\n  async getRentCreatedOnChain(\n    context: Pick<Context, 'rpc'>\n  ): Promise<SolAmount> {\n    return context.rpc.getRent(this.getBytesCreatedOnChain(), {\n      includesHeaderBytes: true,\n    });\n  }\n\n  getTransactionSize(context: Pick<Context, 'transactions' | 'payer'>): number {\n    return context.transactions.serialize(\n      this.setBlockhash('11111111111111111111111111111111').build(context)\n    ).length;\n  }\n\n  minimumTransactionsRequired(\n    context: Pick<Context, 'transactions' | 'payer'>\n  ): number {\n    return Math.ceil(this.getTransactionSize(context) / TRANSACTION_SIZE_LIMIT);\n  }\n\n  fitsInOneTransaction(\n    context: Pick<Context, 'transactions' | 'payer'>\n  ): boolean {\n    return this.minimumTransactionsRequired(context) === 1;\n  }\n\n  build(context: Pick<Context, 'transactions' | 'payer'>): Transaction {\n    const blockhash = this.getBlockhash();\n    if (!blockhash) {\n      throw new SdkError(\n        'Setting a blockhash is required to build a transaction. ' +\n          'Please use the `setBlockhash` or `setLatestBlockhash` methods.'\n      );\n    }\n    const input: TransactionInput = {\n      version: this.options.version ?? 0,\n      payer: this.getFeePayer(context).publicKey,\n      instructions: this.getInstructions(),\n      blockhash,\n    };\n    if (input.version === 0 && this.options.addressLookupTables) {\n      input.addressLookupTables = this.options.addressLookupTables;\n    }\n    return context.transactions.create(input);\n  }\n\n  async buildWithLatestBlockhash(\n    context: Pick<Context, 'transactions' | 'rpc' | 'payer'>,\n    options: RpcGetLatestBlockhashOptions = {}\n  ): Promise<Transaction> {\n    let builder: TransactionBuilder = this;\n    if (!this.options.blockhash) {\n      builder = await this.setLatestBlockhash(context, options);\n    }\n    return builder.build(context);\n  }\n\n  async buildAndSign(\n    context: Pick<Context, 'transactions' | 'rpc' | 'payer'>\n  ): Promise<Transaction> {\n    return signTransaction(\n      await this.buildWithLatestBlockhash(context),\n      this.getSigners(context)\n    );\n  }\n\n  async send(\n    context: Pick<Context, 'transactions' | 'rpc' | 'payer'>,\n    options: RpcSendTransactionOptions = {}\n  ): Promise<TransactionSignature> {\n    const transaction = await this.buildAndSign(context);\n    return context.rpc.sendTransaction(transaction, options);\n  }\n\n  async confirm(\n    context: Pick<Context, 'transactions' | 'rpc' | 'payer'>,\n    signature: TransactionSignature,\n    options: Partial<RpcConfirmTransactionOptions> = {}\n  ): Promise<RpcConfirmTransactionResult> {\n    let builder: TransactionBuilder = this;\n    if (!this.options.blockhash) {\n      builder = await this.setLatestBlockhash(context);\n    }\n\n    let strategy: RpcConfirmTransactionStrategy;\n    if (options.strategy) {\n      strategy = options.strategy;\n    } else {\n      const blockhash =\n        typeof builder.options.blockhash === 'object'\n          ? builder.options.blockhash\n          : await context.rpc.getLatestBlockhash();\n      strategy = options.strategy ?? { type: 'blockhash', ...blockhash };\n    }\n\n    return context.rpc.confirmTransaction(signature, { ...options, strategy });\n  }\n\n  async sendAndConfirm(\n    context: Pick<Context, 'transactions' | 'rpc' | 'payer'>,\n    options: TransactionBuilderSendAndConfirmOptions = {}\n  ): Promise<{\n    signature: TransactionSignature;\n    result: RpcConfirmTransactionResult;\n  }> {\n    let builder: TransactionBuilder = this;\n    if (!this.options.blockhash) {\n      builder = await this.setLatestBlockhash(context);\n    }\n    const signature = await builder.send(context, options.send);\n    const result = await builder.confirm(context, signature, options.confirm);\n    return { signature, result };\n  }\n\n  protected parseItems(\n    input: TransactionBuilderItemsInput\n  ): WrappedInstruction[] {\n    return (Array.isArray(input) ? input : [input]).flatMap((item) =>\n      'items' in item ? item.items : [item]\n    );\n  }\n}\n\n/**\n * Creates a new transaction builder.\n * @category Transactions\n */\nexport const transactionBuilder = (items: WrappedInstruction[] = []) =>\n  new TransactionBuilder(items);\n"],"names":["TransactionBuilder","constructor","items","options","empty","setItems","input","parseItems","prepend","append","add","mapInstructions","fn","map","addRemainingAccounts","accountMeta","instructionIndex","length","metas","Array","isArray","extraKeys","meta","pubkey","signer","publicKey","isSigner","isWritable","extraSigners","flatMap","wrappedInstruction","index","keys","instruction","signers","splitByIndex","slice","unsafeSplitByTransactionSize","context","reduce","builders","item","lastBuilder","pop","lastBuilderWithItem","fitsInOneTransaction","push","setFeePayer","feePayer","getFeePayer","payer","setVersion","version","useLegacyVersion","useV0","setAddressLookupTables","addressLookupTables","getBlockhash","blockhash","setBlockhash","setLatestBlockhash","rpc","getLatestBlockhash","getInstructions","getSigners","uniqueSigners","getBytesCreatedOnChain","sum","bytesCreatedOnChain","getRentCreatedOnChain","getRent","includesHeaderBytes","getTransactionSize","transactions","serialize","build","minimumTransactionsRequired","Math","ceil","TRANSACTION_SIZE_LIMIT","SdkError","instructions","create","buildWithLatestBlockhash","builder","buildAndSign","signTransaction","send","transaction","sendTransaction","confirm","signature","strategy","type","confirmTransaction","sendAndConfirm","result","transactionBuilder"],"mappings":";;;;AA4BA;AACA;AACA;AACA;AACA;;AAsCA;AACA;AACA;AACA;AACO,MAAMA,kBAAkB,CAAmC;EAChEC,WAAW,CACAC,KAA2B,GAAG,EAAE,EAChCC,OAAkC,GAAG,EAAE,EAChD;IAAA,IAFSD,CAAAA,KAA2B,GAA3BA,KAA2B,CAAA;IAAA,IAC3BC,CAAAA,OAAkC,GAAlCA,OAAkC,CAAA;AAC1C,GAAA;AAEHC,EAAAA,KAAK,GAAuB;IAC1B,OAAO,IAAIJ,kBAAkB,CAAC,EAAE,EAAE,IAAI,CAACG,OAAO,CAAC,CAAA;AACjD,GAAA;EAEAE,QAAQ,CAACC,KAAmC,EAAsB;AAChE,IAAA,OAAO,IAAIN,kBAAkB,CAAC,IAAI,CAACO,UAAU,CAACD,KAAK,CAAC,EAAE,IAAI,CAACH,OAAO,CAAC,CAAA;AACrE,GAAA;EAEAK,OAAO,CAACF,KAAmC,EAAsB;IAC/D,OAAO,IAAIN,kBAAkB,CAC3B,CAAC,GAAG,IAAI,CAACO,UAAU,CAACD,KAAK,CAAC,EAAE,GAAG,IAAI,CAACJ,KAAK,CAAC,EAC1C,IAAI,CAACC,OAAO,CACb,CAAA;AACH,GAAA;EAEAM,MAAM,CAACH,KAAmC,EAAsB;IAC9D,OAAO,IAAIN,kBAAkB,CAC3B,CAAC,GAAG,IAAI,CAACE,KAAK,EAAE,GAAG,IAAI,CAACK,UAAU,CAACD,KAAK,CAAC,CAAC,EAC1C,IAAI,CAACH,OAAO,CACb,CAAA;AACH,GAAA;EAEAO,GAAG,CAACJ,KAAmC,EAAsB;AAC3D,IAAA,OAAO,IAAI,CAACG,MAAM,CAACH,KAAK,CAAC,CAAA;AAC3B,GAAA;EAEAK,eAAe,CACbC,EAIuB,EACH;AACpB,IAAA,OAAO,IAAIZ,kBAAkB,CAAC,IAAI,CAACE,KAAK,CAACW,GAAG,CAACD,EAAE,CAAC,EAAE,IAAI,CAACT,OAAO,CAAC,CAAA;AACjE,GAAA;AAEAW,EAAAA,oBAAoB,CAClBC,WAAoE,EACpEC,gBAAyB,EACL;IACpBA,gBAAgB,GAAGA,gBAAgB,IAAI,IAAI,CAACd,KAAK,CAACe,MAAM,GAAG,CAAC,CAAA;AAC5D,IAAA,MAAMC,KAAK,GAAGC,KAAK,CAACC,OAAO,CAACL,WAAW,CAAC,GAAGA,WAAW,GAAG,CAACA,WAAW,CAAC,CAAA;AACtE,IAAA,MAAMM,SAAS,GAAGH,KAAK,CAACL,GAAG,CAAES,IAAI,IAC/B,QAAQ,IAAIA,IAAI,GACZA,IAAI,GACJ;AACEC,MAAAA,MAAM,EAAED,IAAI,CAACE,MAAM,CAACC,SAAS;AAC7BC,MAAAA,QAAQ,EAAE,IAAI;MACdC,UAAU,EAAEL,IAAI,CAACK,UAAAA;AACnB,KAAC,CACN,CAAA;AACD,IAAA,MAAMC,YAAY,GAAGV,KAAK,CAACW,OAAO,CAAEP,IAAI,IACtC,QAAQ,IAAIA,IAAI,GAAG,EAAE,GAAG,CAACA,IAAI,CAACE,MAAM,CAAC,CACtC,CAAA;IACD,OAAO,IAAI,CAACb,eAAe,CAAC,CAACmB,kBAAkB,EAAEC,KAAK,KAAK;AACzD,MAAA,IAAIA,KAAK,KAAKf,gBAAgB,EAAE,OAAOc,kBAAkB,CAAA;AACzD,MAAA,MAAME,IAAI,GAAG,CAAC,GAAGF,kBAAkB,CAACG,WAAW,CAACD,IAAI,EAAE,GAAGX,SAAS,CAAC,CAAA;MACnE,OAAO;AACL,QAAA,GAAGS,kBAAkB;AACrBG,QAAAA,WAAW,EAAE;UAAE,GAAGH,kBAAkB,CAACG,WAAW;AAAED,UAAAA,IAAAA;SAAM;QACxDE,OAAO,EAAE,CAAC,GAAGJ,kBAAkB,CAACI,OAAO,EAAE,GAAGN,YAAY,CAAA;OACzD,CAAA;AACH,KAAC,CAAC,CAAA;AACJ,GAAA;EAEAO,YAAY,CAACJ,KAAa,EAA4C;AACpE,IAAA,OAAO,CACL,IAAI/B,kBAAkB,CAAC,IAAI,CAACE,KAAK,CAACkC,KAAK,CAAC,CAAC,EAAEL,KAAK,CAAC,EAAE,IAAI,CAAC5B,OAAO,CAAC,EAChE,IAAIH,kBAAkB,CAAC,IAAI,CAACE,KAAK,CAACkC,KAAK,CAACL,KAAK,CAAC,EAAE,IAAI,CAAC5B,OAAO,CAAC,CAC9D,CAAA;AACH,GAAA;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkC,4BAA4B,CAC1BC,OAAgD,EAC1B;IACtB,OAAO,IAAI,CAACpC,KAAK,CAACqC,MAAM,CACtB,CAACC,QAAQ,EAAEC,IAAI,KAAK;AAClB,MAAA,MAAMC,WAAW,GAAGF,QAAQ,CAACG,GAAG,EAAwB,CAAA;AACxD,MAAA,MAAMC,mBAAmB,GAAGF,WAAW,CAAChC,GAAG,CAAC+B,IAAI,CAAC,CAAA;AACjD,MAAA,IAAIG,mBAAmB,CAACC,oBAAoB,CAACP,OAAO,CAAC,EAAE;AACrDE,QAAAA,QAAQ,CAACM,IAAI,CAACF,mBAAmB,CAAC,CAAA;AACpC,OAAC,MAAM;AACLJ,QAAAA,QAAQ,CAACM,IAAI,CAACJ,WAAW,CAAC,CAAA;AAC1BF,QAAAA,QAAQ,CAACM,IAAI,CAACJ,WAAW,CAACtC,KAAK,EAAE,CAACM,GAAG,CAAC+B,IAAI,CAAC,CAAC,CAAA;AAC9C,OAAA;AACA,MAAA,OAAOD,QAAQ,CAAA;AACjB,KAAC,EACD,CAAC,IAAI,CAACpC,KAAK,EAAE,CAAC,CACf,CAAA;AACH,GAAA;EAEA2C,WAAW,CAACC,QAAgB,EAAsB;AAChD,IAAA,OAAO,IAAIhD,kBAAkB,CAAC,IAAI,CAACE,KAAK,EAAE;MAAE,GAAG,IAAI,CAACC,OAAO;AAAE6C,MAAAA,QAAAA;AAAS,KAAC,CAAC,CAAA;AAC1E,GAAA;EAEAC,WAAW,CAACX,OAA+B,EAAU;IACnD,OAAO,IAAI,CAACnC,OAAO,CAAC6C,QAAQ,IAAIV,OAAO,CAACY,KAAK,CAAA;AAC/C,GAAA;EAEAC,UAAU,CAACC,OAA2B,EAAsB;AAC1D,IAAA,OAAO,IAAIpD,kBAAkB,CAAC,IAAI,CAACE,KAAK,EAAE;MAAE,GAAG,IAAI,CAACC,OAAO;AAAEiD,MAAAA,OAAAA;AAAQ,KAAC,CAAC,CAAA;AACzE,GAAA;AAEAC,EAAAA,gBAAgB,GAAuB;AACrC,IAAA,OAAO,IAAI,CAACF,UAAU,CAAC,QAAQ,CAAC,CAAA;AAClC,GAAA;AAEAG,EAAAA,KAAK,GAAuB;AAC1B,IAAA,OAAO,IAAI,CAACH,UAAU,CAAC,CAAC,CAAC,CAAA;AAC3B,GAAA;EAEAI,sBAAsB,CACpBC,mBAA8C,EAC1B;AACpB,IAAA,OAAO,IAAIxD,kBAAkB,CAAC,IAAI,CAACE,KAAK,EAAE;MACxC,GAAG,IAAI,CAACC,OAAO;AACfqD,MAAAA,mBAAAA;AACF,KAAC,CAAC,CAAA;AACJ,GAAA;AAEAC,EAAAA,YAAY,GAA0B;IACpC,OAAO,OAAO,IAAI,CAACtD,OAAO,CAACuD,SAAS,KAAK,QAAQ,GAC7C,IAAI,CAACvD,OAAO,CAACuD,SAAS,CAACA,SAAS,GAChC,IAAI,CAACvD,OAAO,CAACuD,SAAS,CAAA;AAC5B,GAAA;EAEAC,YAAY,CACVD,SAAqD,EACjC;AACpB,IAAA,OAAO,IAAI1D,kBAAkB,CAAC,IAAI,CAACE,KAAK,EAAE;MAAE,GAAG,IAAI,CAACC,OAAO;AAAEuD,MAAAA,SAAAA;AAAU,KAAC,CAAC,CAAA;AAC3E,GAAA;EAEA,MAAME,kBAAkB,CACtBtB,OAA6B,EAC7BnC,OAAqC,GAAG,EAAE,EACb;AAC7B,IAAA,OAAO,IAAI,CAACwD,YAAY,CAAC,MAAMrB,OAAO,CAACuB,GAAG,CAACC,kBAAkB,CAAC3D,OAAO,CAAC,CAAC,CAAA;AACzE,GAAA;AAEA4D,EAAAA,eAAe,GAAkB;IAC/B,OAAO,IAAI,CAAC7D,KAAK,CAACW,GAAG,CAAE4B,IAAI,IAAKA,IAAI,CAACR,WAAW,CAAC,CAAA;AACnD,GAAA;EAEA+B,UAAU,CAAC1B,OAA+B,EAAY;IACpD,OAAO2B,aAAa,CAAC,CACnB,IAAI,CAAChB,WAAW,CAACX,OAAO,CAAC,EACzB,GAAG,IAAI,CAACpC,KAAK,CAAC2B,OAAO,CAAEY,IAAI,IAAKA,IAAI,CAACP,OAAO,CAAC,CAC9C,CAAC,CAAA;AACJ,GAAA;AAEAgC,EAAAA,sBAAsB,GAAW;AAC/B,IAAA,OAAO,IAAI,CAAChE,KAAK,CAACqC,MAAM,CAAC,CAAC4B,GAAG,EAAE1B,IAAI,KAAK0B,GAAG,GAAG1B,IAAI,CAAC2B,mBAAmB,EAAE,CAAC,CAAC,CAAA;AAC5E,GAAA;EAEA,MAAMC,qBAAqB,CACzB/B,OAA6B,EACT;IACpB,OAAOA,OAAO,CAACuB,GAAG,CAACS,OAAO,CAAC,IAAI,CAACJ,sBAAsB,EAAE,EAAE;AACxDK,MAAAA,mBAAmB,EAAE,IAAA;AACvB,KAAC,CAAC,CAAA;AACJ,GAAA;EAEAC,kBAAkB,CAAClC,OAAgD,EAAU;AAC3E,IAAA,OAAOA,OAAO,CAACmC,YAAY,CAACC,SAAS,CACnC,IAAI,CAACf,YAAY,CAAC,kCAAkC,CAAC,CAACgB,KAAK,CAACrC,OAAO,CAAC,CACrE,CAACrB,MAAM,CAAA;AACV,GAAA;EAEA2D,2BAA2B,CACzBtC,OAAgD,EACxC;AACR,IAAA,OAAOuC,IAAI,CAACC,IAAI,CAAC,IAAI,CAACN,kBAAkB,CAAClC,OAAO,CAAC,GAAGyC,sBAAsB,CAAC,CAAA;AAC7E,GAAA;EAEAlC,oBAAoB,CAClBP,OAAgD,EACvC;AACT,IAAA,OAAO,IAAI,CAACsC,2BAA2B,CAACtC,OAAO,CAAC,KAAK,CAAC,CAAA;AACxD,GAAA;EAEAqC,KAAK,CAACrC,OAAgD,EAAe;AACnE,IAAA,MAAMoB,SAAS,GAAG,IAAI,CAACD,YAAY,EAAE,CAAA;IACrC,IAAI,CAACC,SAAS,EAAE;AACd,MAAA,MAAM,IAAIsB,QAAQ,CAChB,0DAA0D,GACxD,gEAAgE,CACnE,CAAA;AACH,KAAA;AACA,IAAA,MAAM1E,KAAuB,GAAG;AAC9B8C,MAAAA,OAAO,EAAE,IAAI,CAACjD,OAAO,CAACiD,OAAO,IAAI,CAAC;MAClCF,KAAK,EAAE,IAAI,CAACD,WAAW,CAACX,OAAO,CAAC,CAACb,SAAS;AAC1CwD,MAAAA,YAAY,EAAE,IAAI,CAAClB,eAAe,EAAE;AACpCL,MAAAA,SAAAA;KACD,CAAA;IACD,IAAIpD,KAAK,CAAC8C,OAAO,KAAK,CAAC,IAAI,IAAI,CAACjD,OAAO,CAACqD,mBAAmB,EAAE;AAC3DlD,MAAAA,KAAK,CAACkD,mBAAmB,GAAG,IAAI,CAACrD,OAAO,CAACqD,mBAAmB,CAAA;AAC9D,KAAA;AACA,IAAA,OAAOlB,OAAO,CAACmC,YAAY,CAACS,MAAM,CAAC5E,KAAK,CAAC,CAAA;AAC3C,GAAA;EAEA,MAAM6E,wBAAwB,CAC5B7C,OAAwD,EACxDnC,OAAqC,GAAG,EAAE,EACpB;IACtB,IAAIiF,OAA2B,GAAG,IAAI,CAAA;AACtC,IAAA,IAAI,CAAC,IAAI,CAACjF,OAAO,CAACuD,SAAS,EAAE;MAC3B0B,OAAO,GAAG,MAAM,IAAI,CAACxB,kBAAkB,CAACtB,OAAO,EAAEnC,OAAO,CAAC,CAAA;AAC3D,KAAA;AACA,IAAA,OAAOiF,OAAO,CAACT,KAAK,CAACrC,OAAO,CAAC,CAAA;AAC/B,GAAA;EAEA,MAAM+C,YAAY,CAChB/C,OAAwD,EAClC;AACtB,IAAA,OAAOgD,eAAe,CACpB,MAAM,IAAI,CAACH,wBAAwB,CAAC7C,OAAO,CAAC,EAC5C,IAAI,CAAC0B,UAAU,CAAC1B,OAAO,CAAC,CACzB,CAAA;AACH,GAAA;EAEA,MAAMiD,IAAI,CACRjD,OAAwD,EACxDnC,OAAkC,GAAG,EAAE,EACR;IAC/B,MAAMqF,WAAW,GAAG,MAAM,IAAI,CAACH,YAAY,CAAC/C,OAAO,CAAC,CAAA;IACpD,OAAOA,OAAO,CAACuB,GAAG,CAAC4B,eAAe,CAACD,WAAW,EAAErF,OAAO,CAAC,CAAA;AAC1D,GAAA;EAEA,MAAMuF,OAAO,CACXpD,OAAwD,EACxDqD,SAA+B,EAC/BxF,OAA8C,GAAG,EAAE,EACb;IACtC,IAAIiF,OAA2B,GAAG,IAAI,CAAA;AACtC,IAAA,IAAI,CAAC,IAAI,CAACjF,OAAO,CAACuD,SAAS,EAAE;AAC3B0B,MAAAA,OAAO,GAAG,MAAM,IAAI,CAACxB,kBAAkB,CAACtB,OAAO,CAAC,CAAA;AAClD,KAAA;AAEA,IAAA,IAAIsD,QAAuC,CAAA;IAC3C,IAAIzF,OAAO,CAACyF,QAAQ,EAAE;MACpBA,QAAQ,GAAGzF,OAAO,CAACyF,QAAQ,CAAA;AAC7B,KAAC,MAAM;MACL,MAAMlC,SAAS,GACb,OAAO0B,OAAO,CAACjF,OAAO,CAACuD,SAAS,KAAK,QAAQ,GACzC0B,OAAO,CAACjF,OAAO,CAACuD,SAAS,GACzB,MAAMpB,OAAO,CAACuB,GAAG,CAACC,kBAAkB,EAAE,CAAA;AAC5C8B,MAAAA,QAAQ,GAAGzF,OAAO,CAACyF,QAAQ,IAAI;AAAEC,QAAAA,IAAI,EAAE,WAAW;QAAE,GAAGnC,SAAAA;OAAW,CAAA;AACpE,KAAA;AAEA,IAAA,OAAOpB,OAAO,CAACuB,GAAG,CAACiC,kBAAkB,CAACH,SAAS,EAAE;AAAE,MAAA,GAAGxF,OAAO;AAAEyF,MAAAA,QAAAA;AAAS,KAAC,CAAC,CAAA;AAC5E,GAAA;EAEA,MAAMG,cAAc,CAClBzD,OAAwD,EACxDnC,OAAgD,GAAG,EAAE,EAIpD;IACD,IAAIiF,OAA2B,GAAG,IAAI,CAAA;AACtC,IAAA,IAAI,CAAC,IAAI,CAACjF,OAAO,CAACuD,SAAS,EAAE;AAC3B0B,MAAAA,OAAO,GAAG,MAAM,IAAI,CAACxB,kBAAkB,CAACtB,OAAO,CAAC,CAAA;AAClD,KAAA;AACA,IAAA,MAAMqD,SAAS,GAAG,MAAMP,OAAO,CAACG,IAAI,CAACjD,OAAO,EAAEnC,OAAO,CAACoF,IAAI,CAAC,CAAA;AAC3D,IAAA,MAAMS,MAAM,GAAG,MAAMZ,OAAO,CAACM,OAAO,CAACpD,OAAO,EAAEqD,SAAS,EAAExF,OAAO,CAACuF,OAAO,CAAC,CAAA;IACzE,OAAO;MAAEC,SAAS;AAAEK,MAAAA,MAAAA;KAAQ,CAAA;AAC9B,GAAA;EAEUzF,UAAU,CAClBD,KAAmC,EACb;AACtB,IAAA,OAAO,CAACa,KAAK,CAACC,OAAO,CAACd,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC,EAAEuB,OAAO,CAAEY,IAAI,IAC3D,OAAO,IAAIA,IAAI,GAAGA,IAAI,CAACvC,KAAK,GAAG,CAACuC,IAAI,CAAC,CACtC,CAAA;AACH,GAAA;AACF,CAAA;;AAEA;AACA;AACA;AACA;AACawD,MAAAA,kBAAkB,GAAG,CAAC/F,KAA2B,GAAG,EAAE,KACjE,IAAIF,kBAAkB,CAACE,KAAK;;;;"}