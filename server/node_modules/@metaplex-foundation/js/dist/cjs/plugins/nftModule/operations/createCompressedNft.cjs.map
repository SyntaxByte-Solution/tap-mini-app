{"version":3,"file":"createCompressedNft.cjs","sources":["../../../../../src/plugins/nftModule/operations/createCompressedNft.ts"],"sourcesContent":["import {\n  Uses,\n  PROGRAM_ID as TOKEN_METADATA_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport {\n  TokenProgramVersion,\n  createMintToCollectionV1Instruction,\n  getLeafAssetId,\n  TokenStandard,\n  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-bubblegum';\nimport {\n  SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  SPL_NOOP_PROGRAM_ID,\n  deserializeChangeLogEventV1,\n} from '@solana/spl-account-compression';\nimport { PublicKey } from '@solana/web3.js';\nimport { BN } from 'bn.js';\nimport base58 from 'bs58';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertNft, Nft } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Creator,\n  CreatorInput,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCompressedNftOperation' as const;\n\n/**\n * Creates a new compressed NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .createNft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *     tree: merkleTreeAccount\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createCompressedNftOperation =\n  useOperation<CreateCompressedNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateCompressedNftOperation = Operation<\n  typeof Key,\n  CreateCompressedNftInput,\n  CreateCompressedNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateCompressedNftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The address corresponding to the merkle tree where this\n   * compressed NFT will be stored.\n   *\n   * Must be created ahead of time.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  tree: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateCompressedNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created NFT and, potentially, its associated token. */\n  nft: Nft;\n\n  /** The mint address is the compressed NFT's assetId. */\n  mintAddress: PublicKey;\n\n  /** The metadata address is the compressed NFT's assetId. */\n  metadataAddress: PublicKey;\n\n  /** The master edition address is the compressed NFT's assetId. */\n  masterEditionAddress: PublicKey;\n\n  /** The token address is the compressed NFT's assetId. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createCompressedNftOperationHandler: OperationHandler<CreateCompressedNftOperation> =\n  {\n    handle: async (\n      operation: CreateCompressedNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const builder = await createCompressedNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const txInfo = await metaplex.connection.getTransaction(\n        output.response.signature,\n        {\n          maxSupportedTransactionVersion: 0,\n        }\n      );\n      scope.throwIfCanceled();\n\n      // find the index of the bubblegum instruction\n      const relevantIndex =\n        txInfo!.transaction.message.compiledInstructions.findIndex(\n          (instruction) => {\n            return (\n              txInfo?.transaction.message.staticAccountKeys[\n                instruction.programIdIndex\n              ].toBase58() === 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY'\n            );\n          }\n        );\n\n      // locate the no-op inner instructions called via cpi from bubblegum\n      const relevantInnerIxs = txInfo!.meta?.innerInstructions?.[\n        relevantIndex\n      ].instructions.filter((instruction) => {\n        return (\n          txInfo?.transaction.message.staticAccountKeys[\n            instruction.programIdIndex\n          ].toBase58() === 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV'\n        );\n      });\n\n      // when no valid noop instructions are found, throw an error\n      if (!relevantInnerIxs || relevantInnerIxs.length == 0)\n        throw Error('Unable to locate valid noop instructions');\n\n      // locate the asset index by attempting to locate and parse the correct `relevantInnerIx`\n      let assetIndex: number | undefined = undefined;\n      // note: the `assetIndex` is expected to be at position `1`, and normally expect only 2 `relevantInnerIx`\n      for (let i = relevantInnerIxs.length - 1; i > 0; i--) {\n        try {\n          const changeLogEvent = deserializeChangeLogEventV1(\n            Buffer.from(base58.decode(relevantInnerIxs[i]?.data!))\n          );\n\n          // extract a successful changelog index\n          assetIndex = changeLogEvent?.index;\n        } catch (__) {\n          // do nothing, invalid data is handled just after the for loop\n        }\n      }\n\n      // when no `assetIndex` was found, throw an error\n      if (typeof assetIndex == 'undefined')\n        throw Error('Unable to locate the newly minted assetId ');\n\n      const assetId = await getLeafAssetId(\n        operation.input.tree,\n        new BN(assetIndex)\n      );\n\n      const nft = await metaplex.nfts().findByAssetId(\n        {\n          assetId,\n        },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      assertNft(nft);\n\n      return {\n        ...output,\n        nft,\n        /**\n         * the assetId is impossible to know before the compressed nft is minted\n         * all these addresses are derived from, or are, the `assetId`\n         */\n        mintAddress: assetId,\n        tokenAddress: assetId,\n        metadataAddress: nft.metadataAddress,\n        masterEditionAddress: nft.edition.address,\n      };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateCompressedNftBuilderParams = Omit<\n  CreateCompressedNftInput,\n  'confirmOptions' | 'tokenAddress' | 'metadataAddress' | 'masterEditionAddress'\n> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateCompressedNftBuilderContext = Omit<\n  CreateCompressedNftOutput,\n  'response' | 'nft'\n>;\n\n/**\n * Creates a new compressed NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createCompressedNft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *     tree: merkleTreeAccount\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createCompressedNftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateCompressedNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateCompressedNftBuilderContext>> => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { updateAuthority = metaplex.identity(), tree } = params;\n\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  // Likely that this information can only be derived after the mint\n  // const verifyAdditionalCreatorInstructions = creatorsInput\n  //   .filter((creator) => {\n  //     return (\n  //       !!creator.authority &&\n  //       !creator.address.equals(updateAuthority.publicKey)\n  //     );\n  //   })\n  //   .map((creator) => {\n  //     return metaplex.nfts().builders().verifyCreator(\n  //       {\n  //         mintAddress,\n  //         creator: creator.authority,\n  //       },\n  //       { programs, payer }\n  //     );\n  //   });\n\n  return (\n    TransactionBuilder.make<CreateCompressedNftBuilderContext>()\n      .setFeePayer(payer)\n\n      // Verify additional creators.\n      // TODO(jon): Add the creator verification instructions\n      // .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) => {\n        const { collection, collectionAuthority } = params;\n\n        const [collectionMetadataAddress] = PublicKey.findProgramAddressSync(\n          [\n            Buffer.from('metadata', 'utf8'),\n            TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n            (collection as PublicKey).toBuffer(),\n          ],\n          TOKEN_METADATA_PROGRAM_ID\n        );\n\n        const [collectionMasterEditionAccount] =\n          PublicKey.findProgramAddressSync(\n            [\n              Buffer.from('metadata', 'utf8'),\n              TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n              (collection as PublicKey).toBuffer(),\n              Buffer.from('edition', 'utf8'),\n            ],\n            TOKEN_METADATA_PROGRAM_ID\n          );\n\n        const [treeAuthority] = PublicKey.findProgramAddressSync(\n          [tree.toBuffer()],\n          BUBBLEGUM_PROGRAM_ID\n        );\n\n        const [bubblegumPDA] = PublicKey.findProgramAddressSync(\n          [Buffer.from('collection_cpi', 'utf8')],\n          BUBBLEGUM_PROGRAM_ID\n        );\n\n        return builder.add({\n          instruction:\n            // TODO(jon): We should be able to infer some of these in an intermediary SDK\n            createMintToCollectionV1Instruction(\n              {\n                payer: payer.publicKey,\n\n                merkleTree: tree,\n                treeAuthority,\n                // TODO(jon): Replace this delegate\n                treeDelegate: payer.publicKey,\n\n                // TODO(jon): This should respect the configured owner\n                leafOwner: payer.publicKey,\n                leafDelegate: payer.publicKey,\n\n                collectionMetadata: collectionMetadataAddress,\n                collectionMint: collection as PublicKey,\n                collectionAuthority: (collectionAuthority as Signer).publicKey,\n                // TODO(jon): This should be `collectionMasterEditionAccount`\n                editionAccount: collectionMasterEditionAccount,\n\n                // TODO(jon): Pass along another parameter for this field and default to the BUBBLEGUM_PROGRAM_ID\n                collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID,\n\n                bubblegumSigner: bubblegumPDA,\n\n                // Programs\n                /* Account Compression */\n                compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n                // TODO(jon): This argument should be `logWrapperProgram`\n                logWrapper: SPL_NOOP_PROGRAM_ID,\n\n                /* Bubblegum */\n                tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n              },\n              {\n                metadataArgs: {\n                  ...params,\n\n                  symbol: params.symbol ?? '',\n                  creators: creators ?? [],\n\n                  isMutable: !!params.isMutable,\n                  uses: params.uses ?? null,\n\n                  // Only NonFungible tokens are supported.\n                  tokenStandard: TokenStandard.NonFungible,\n                  collection: {\n                    key: collection as PublicKey,\n                    // TODO(jon): Can we verify this here or do we need to send a separate instruction?\n                    verified: false,\n                  },\n\n                  primarySaleHappened: false,\n                  editionNonce: null,\n\n                  tokenProgramVersion: TokenProgramVersion.Original,\n                },\n              }\n            ),\n          signers: [payer, params.collectionAuthority as Signer],\n        });\n      })\n  );\n};\n"],"names":["Key","createCompressedNftOperation","useOperation","createCompressedNftOperationHandler","handle","operation","metaplex","scope","builder","createCompressedNftBuilder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","txInfo","connection","getTransaction","response","signature","maxSupportedTransactionVersion","relevantIndex","transaction","message","compiledInstructions","findIndex","instruction","staticAccountKeys","programIdIndex","toBase58","relevantInnerIxs","meta","innerInstructions","instructions","filter","length","Error","assetIndex","undefined","i","changeLogEvent","deserializeChangeLogEventV1","Buffer","from","base58","decode","data","index","__","assetId","getLeafAssetId","tree","BN","nft","nfts","findByAssetId","assertNft","mintAddress","tokenAddress","metadataAddress","masterEditionAddress","edition","address","params","options","payer","rpc","getDefaultFeePayer","updateAuthority","identity","creatorsInput","creators","publicKey","authority","share","map","creator","verified","equals","TransactionBuilder","make","setFeePayer","when","collection","collectionAuthority","collectionMetadataAddress","PublicKey","findProgramAddressSync","TOKEN_METADATA_PROGRAM_ID","toBuffer","collectionMasterEditionAccount","treeAuthority","BUBBLEGUM_PROGRAM_ID","bubblegumPDA","add","createMintToCollectionV1Instruction","merkleTree","treeDelegate","leafOwner","leafDelegate","collectionMetadata","collectionMint","editionAccount","collectionAuthorityRecordPda","bubblegumSigner","compressionProgram","SPL_ACCOUNT_COMPRESSION_PROGRAM_ID","logWrapper","SPL_NOOP_PROGRAM_ID","tokenMetadataProgram","metadataArgs","symbol","isMutable","uses","tokenStandard","TokenStandard","NonFungible","key","primarySaleHappened","editionNonce","tokenProgramVersion","TokenProgramVersion","Original","signers"],"mappings":"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"}