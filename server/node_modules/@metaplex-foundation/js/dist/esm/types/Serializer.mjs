import * as beet from '@metaplex-foundation/beet';
import { FailedToSerializeDataError, FailedToDeserializeDataError, UnexpectedAccountError } from '../errors/SdkError.mjs';

const mapSerializer = (serializer, map, unmap) => ({
  description: serializer.description,
  serialize: value => serializer.serialize(unmap(value)),
  deserialize: (buffer, offset) => {
    const [value, newOffset] = serializer.deserialize(buffer, offset);
    return [map(value), newOffset];
  }
});
const createSerializerFromBeet = beetArg => ({
  description: beetArg.description,
  serialize: value => {
    const fixedBeet = beet.isFixableBeet(beetArg) ? beetArg.toFixedFromValue(value) : beetArg;
    const writer = new beet.BeetWriter(fixedBeet.byteSize);
    writer.write(fixedBeet, value);
    return writer.buffer;
  },
  deserialize: (buffer, offset) => {
    const fixedBeet = beet.isFixableBeet(beetArg) ? beetArg.toFixedFromData(buffer, offset ?? 0) : beetArg;
    const reader = new beet.BeetReader(buffer, offset ?? 0);
    const value = reader.read(fixedBeet);
    return [value, reader.offset];
  }
});
const createSerializerFromSolitaType = (solitaType, description) => ({
  description: description ?? solitaType.name,
  serialize: value => {
    return solitaType.fromArgs(value).serialize()[0];
  },
  deserialize: (buffer, offset) => {
    return solitaType.deserialize(buffer, offset);
  }
});
const serialize = (value, serializer) => {
  try {
    return serializer.serialize(value);
  } catch (error) {
    throw new FailedToSerializeDataError(serializer.description, error);
  }
};
const deserialize = (value, serializer) => {
  try {
    return serializer.deserialize(value);
  } catch (error) {
    throw new FailedToDeserializeDataError(serializer.description, error);
  }
};
function deserializeAccount(account, serializer) {
  if ('exists' in account && !account.exists) {
    return account;
  }
  try {
    const data = serializer.deserialize(account.data)[0];
    return {
      ...account,
      data
    };
  } catch (error) {
    throw new UnexpectedAccountError(account.publicKey, serializer.description, error);
  }
}
const serializeDiscriminator = discriminator => {
  const serializer = createSerializerFromBeet(beet.uniformFixedSizeArray(beet.u8, 8));
  return serialize(discriminator, serializer);
};

export { createSerializerFromBeet, createSerializerFromSolitaType, deserialize, deserializeAccount, mapSerializer, serialize, serializeDiscriminator };
//# sourceMappingURL=Serializer.mjs.map
