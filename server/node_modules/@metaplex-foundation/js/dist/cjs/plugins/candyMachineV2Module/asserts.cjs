'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mplCandyMachine = require('@metaplex-foundation/mpl-candy-machine');
var constants = require('./constants.cjs');
var errors = require('./errors.cjs');
var assert = require('../../utils/assert.cjs');
var BigNumber = require('../../types/BigNumber.cjs');
var DateTime = require('../../types/DateTime.cjs');

const assertName = name => {
  assert["default"](name.length <= constants.MAX_NAME_LENGTH, `Candy Machine name too long: ${name} (max ${constants.MAX_NAME_LENGTH})`);
};
const assertUri = uri => {
  assert["default"](uri.length <= constants.MAX_URI_LENGTH, `Candy Machine URI too long: ${uri} (max ${constants.MAX_URI_LENGTH})`);
};
const assertNotFull = (candyMachine, index) => {
  if (candyMachine.itemsAvailable.lte(candyMachine.itemsLoaded)) {
    throw new errors.CandyMachineV2IsFullError(index, candyMachine.itemsAvailable);
  }
};
const assertNotEmpty = candyMachine => {
  if (candyMachine.itemsRemaining.isZero()) {
    throw new errors.CandyMachineV2IsEmptyError(candyMachine.itemsAvailable);
  }
};
const assertCanAdd = (candyMachine, index, amount) => {
  if (index.addn(amount).gt(candyMachine.itemsAvailable)) {
    throw new errors.CandyMachineV2CannotAddAmountError(index, amount, candyMachine.itemsAvailable);
  }
};
const assertAllConfigLineConstraints = configLines => {
  for (let i = 0; i < configLines.length; i++) {
    try {
      assertName(configLines[i].name);
      assertUri(configLines[i].uri);
    } catch (error) {
      throw new errors.CandyMachineV2AddItemConstraintsViolatedError(BigNumber.toBigNumber(i), configLines[i], error);
    }
  }
};
const assertCandyMachineV2IsLive = candyMachine => {
  const hasWhitelistPresale = candyMachine.whitelistMintSettings?.presale ?? false;
  if (hasWhitelistPresale) {
    return;
  }
  const liveDate = candyMachine.goLiveDate;
  if (!liveDate || liveDate.gte(DateTime.now())) {
    throw new errors.CandyMachineV2NotLiveError(liveDate);
  }
};
const assertCandyMachineV2HasNotEnded = candyMachine => {
  const {
    endSettings
  } = candyMachine;
  if (!endSettings) {
    return;
  }
  const hasEndedByAmount = endSettings.endSettingType === mplCandyMachine.EndSettingType.Amount && candyMachine.itemsMinted.gte(endSettings.number);
  const hasEndedByDate = endSettings.endSettingType === mplCandyMachine.EndSettingType.Date && endSettings.date.lt(DateTime.now());
  if (hasEndedByAmount || hasEndedByDate) {
    throw new errors.CandyMachineV2EndedError(endSettings);
  }
};
const assertCanMintCandyMachineV2 = (candyMachine, payer) => {
  assertNotEmpty(candyMachine);
  if (candyMachine.authorityAddress.equals(payer.publicKey)) {
    return;
  }
  assertCandyMachineV2IsLive(candyMachine);
  assertCandyMachineV2HasNotEnded(candyMachine);
};

exports.assertAllConfigLineConstraints = assertAllConfigLineConstraints;
exports.assertCanAdd = assertCanAdd;
exports.assertCanMintCandyMachineV2 = assertCanMintCandyMachineV2;
exports.assertCandyMachineV2HasNotEnded = assertCandyMachineV2HasNotEnded;
exports.assertCandyMachineV2IsLive = assertCandyMachineV2IsLive;
exports.assertName = assertName;
exports.assertNotEmpty = assertNotEmpty;
exports.assertNotFull = assertNotFull;
exports.assertUri = assertUri;
//# sourceMappingURL=asserts.cjs.map
