import { toCandyMachineV2Account, parseCandyMachineV2CollectionAccount } from '../accounts.mjs';
import { findCandyMachineV2CollectionPda } from '../pdas.mjs';
import { toCandyMachineV2 } from '../models/CandyMachineV2.mjs';
import { useOperation } from '../../../types/Operation.mjs';
import { assertAccountExists } from '../../../types/Account.mjs';

// -----------------
// Operation
// -----------------

const Key = 'FindCandyMachineV2ByAddressOperation';

/**
 * Find an existing Candy Machine by its address.
 *
 * ```ts
 * const candyMachine = await metaplex.candyMachinesV2().findbyAddress({ address });
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const findCandyMachineV2ByAddressOperation = useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const findCandyMachineV2ByAddressOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const {
      commitment
    } = scope;
    const {
      address
    } = operation.input;
    const collectionPda = findCandyMachineV2CollectionPda(address);
    const accounts = await metaplex.rpc().getMultipleAccounts([address, collectionPda], commitment);
    const unparsedAccount = accounts[0];
    assertAccountExists(unparsedAccount);
    const account = toCandyMachineV2Account(unparsedAccount);
    const collectionAccount = parseCandyMachineV2CollectionAccount(accounts[1]);
    const mint = account.data.tokenMint ? await metaplex.tokens().findMintByAddress({
      address: account.data.tokenMint
    }, scope) : null;
    return toCandyMachineV2(account, unparsedAccount, collectionAccount, mint);
  }
};

export { findCandyMachineV2ByAddressOperation, findCandyMachineV2ByAddressOperationHandler };
//# sourceMappingURL=findCandyMachineV2ByAddress.mjs.map
