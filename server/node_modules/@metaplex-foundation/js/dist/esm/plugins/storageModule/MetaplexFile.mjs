import { Buffer } from 'buffer';
import { randomStr, getContentType, getExtension } from '../../utils/common.mjs';
import { InvalidJsonVariableError } from '../../errors/SdkError.mjs';

const toMetaplexFile = (content, fileName, options = {}) => ({
  buffer: parseMetaplexFileContent(content),
  fileName,
  displayName: options.displayName ?? fileName,
  uniqueName: options.uniqueName ?? randomStr(),
  contentType: options.contentType ?? getContentType(fileName),
  extension: options.extension ?? getExtension(fileName),
  tags: options.tags ?? []
});
const toMetaplexFileFromBrowser = async (file, options = {}) => {
  const buffer = await file.arrayBuffer();
  return toMetaplexFile(buffer, file.name, options);
};
const toMetaplexFileFromJson = (json, fileName = 'inline.json', options = {}) => {
  let jsonString;
  try {
    jsonString = JSON.stringify(json);
  } catch (error) {
    throw new InvalidJsonVariableError(error);
  }
  return toMetaplexFile(jsonString, fileName, options);
};
const parseMetaplexFileContent = content => {
  if (content instanceof ArrayBuffer) {
    return Buffer.from(new Uint8Array(content));
  }
  return Buffer.from(content);
};
const getBytesFromMetaplexFiles = (...files) => files.reduce((acc, file) => acc + file.buffer.byteLength, 0);
const getBrowserFileFromMetaplexFile = file => new File([file.buffer], file.fileName);
const isMetaplexFile = metaplexFile => {
  return metaplexFile != null && typeof metaplexFile === 'object' && 'buffer' in metaplexFile && 'fileName' in metaplexFile && 'displayName' in metaplexFile && 'uniqueName' in metaplexFile && 'contentType' in metaplexFile && 'extension' in metaplexFile && 'tags' in metaplexFile;
};

export { getBrowserFileFromMetaplexFile, getBytesFromMetaplexFiles, isMetaplexFile, parseMetaplexFileContent, toMetaplexFile, toMetaplexFileFromBrowser, toMetaplexFileFromJson };
//# sourceMappingURL=MetaplexFile.mjs.map
