{"version":3,"file":"Authorization.mjs","sources":["../../../../src/plugins/nftModule/Authorization.ts"],"sourcesContent":["import {\n  AuthorityType,\n  AuthorizationData,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Metaplex } from '../../Metaplex';\nimport {\n  MetadataDelegateInput,\n  parseTokenMetadataDelegateInput,\n  TokenDelegateInput,\n} from './DelegateInput';\nimport { Signer, PublicKey, Program } from '@/types';\nimport { Option } from '@/utils';\nimport { UnreachableCaseError } from '@/errors';\n\n/**\n * Defines an authority that can handle a digital asset (NFT, SFT, etc.).\n *\n * An authority can be one of the following:\n * - Metadata: the update authority of the metadata account.\n * - Holder: the owner of the token account, i.e. the owner of the asset.\n * - Metadata Delegate: an approved delegate authority of the metadata account for a given action.\n * - Token Delegate: an approved delegate authority of the token account for a given action.\n */\nexport type TokenMetadataAuthority =\n  | TokenMetadataAuthorityMetadata\n  | TokenMetadataAuthorityHolder\n  | TokenMetadataAuthorityMetadataDelegate\n  | TokenMetadataAuthorityTokenDelegate;\n\n/** The update authority of the metadata account. */\nexport type TokenMetadataAuthorityMetadata = {\n  __kind: 'metadata';\n  updateAuthority: Signer;\n  token?: PublicKey;\n};\n\n/** An approved delegate authority of the metadata account for a given action. */\nexport type TokenMetadataAuthorityMetadataDelegate =\n  MetadataDelegateInput<Signer> & {\n    __kind: 'metadataDelegate';\n  };\n\n/** An approved delegate authority of the token account for a given action. */\nexport type TokenMetadataAuthorityTokenDelegate = TokenDelegateInput<Signer> & {\n  __kind: 'tokenDelegate';\n};\n\n/** The owner of the token account, i.e. the owner of the asset. */\nexport type TokenMetadataAuthorityHolder = {\n  __kind: 'holder';\n  owner: Signer;\n  token: PublicKey;\n};\n\n/**\n * Allows us to provide additional authorization details for an operation.\n *\n * This includes:\n * - The account defining the rules that should be used to authorize the operation.\n * - Optionally, the extra data that should be used by those rules.\n */\nexport type TokenMetadataAuthorizationDetails = {\n  rules: PublicKey;\n  data?: AuthorizationData;\n};\n\nexport type ParsedTokenMetadataAuthorization = {\n  accounts: {\n    /** The authority that will sign the transaction. */\n    authority: PublicKey;\n    /**\n     * If \"holder\" or \"token delegate\" authority,\n     * the address of the token account.\n     */\n    token?: PublicKey;\n    /**\n     * If \"delegate\" authority, the address of the update\n     * authority or the token owner depending on the type.\n     */\n    approver?: PublicKey;\n    /**\n     * If \"delegate\" authority, the address of the token record\n     * or the metadata delegate record PDA depending on the type.\n     */\n    delegateRecord?: PublicKey;\n    /** If any auth rules are provided, the address of the auth rule account. */\n    authorizationRules?: PublicKey;\n  };\n  signers: Signer[];\n  data: {\n    authorityType: AuthorityType;\n    authorizationData: Option<AuthorizationData>;\n  };\n};\n\nexport const parseTokenMetadataAuthorization = (\n  metaplex: Metaplex,\n  input: {\n    mint: PublicKey;\n    authority: TokenMetadataAuthority;\n    authorizationDetails?: TokenMetadataAuthorizationDetails;\n    programs?: Program[];\n  }\n): ParsedTokenMetadataAuthorization => {\n  const auth = {\n    accounts: { authorizationRules: input.authorizationDetails?.rules ?? null },\n    signers: [] as Signer[],\n    data: { authorizationData: input.authorizationDetails?.data ?? null },\n  } as ParsedTokenMetadataAuthorization;\n\n  if (input.authority.__kind === 'metadata') {\n    auth.accounts.authority = input.authority.updateAuthority.publicKey;\n    auth.accounts.token = input.authority.token;\n    auth.signers.push(input.authority.updateAuthority);\n    auth.data.authorityType = AuthorityType.Metadata;\n  } else if (input.authority.__kind === 'metadataDelegate') {\n    const { delegateRecord, approver } = parseTokenMetadataDelegateInput(\n      metaplex,\n      input.mint,\n      input.authority,\n      input.programs\n    );\n    auth.accounts.authority = input.authority.delegate.publicKey;\n    auth.accounts.delegateRecord = delegateRecord;\n    auth.accounts.approver = approver;\n    auth.signers.push(input.authority.delegate);\n    auth.data.authorityType = AuthorityType.MetadataDelegate;\n  } else if (input.authority.__kind === 'tokenDelegate') {\n    const { delegateRecord, approver, tokenAccount } =\n      parseTokenMetadataDelegateInput(\n        metaplex,\n        input.mint,\n        input.authority,\n        input.programs\n      );\n    auth.accounts.authority = input.authority.delegate.publicKey;\n    auth.accounts.token = tokenAccount;\n    auth.accounts.delegateRecord = delegateRecord;\n    auth.accounts.approver = approver;\n    auth.signers.push(input.authority.delegate);\n    auth.data.authorityType = AuthorityType.TokenDelegate;\n  } else if (input.authority.__kind === 'holder') {\n    auth.accounts.authority = input.authority.owner.publicKey;\n    auth.accounts.token = input.authority.token;\n    auth.signers.push(input.authority.owner);\n    auth.data.authorityType = AuthorityType.Holder;\n  } else {\n    throw new UnreachableCaseError((input.authority as any).__kind as never);\n  }\n\n  return auth;\n};\n\nexport const getSignerFromTokenMetadataAuthority = (\n  authority: TokenMetadataAuthority | Signer\n): Signer => {\n  if (!('__kind' in authority)) {\n    return authority;\n  }\n\n  switch (authority.__kind) {\n    case 'metadata':\n      return authority.updateAuthority;\n    case 'metadataDelegate':\n    case 'tokenDelegate':\n      return authority.delegate;\n    case 'holder':\n      return authority.owner;\n    default:\n      throw new UnreachableCaseError((authority as any).__kind as never);\n  }\n};\n"],"names":["parseTokenMetadataAuthorization","metaplex","input","auth","accounts","authorizationRules","authorizationDetails","rules","signers","data","authorizationData","authority","__kind","updateAuthority","publicKey","token","push","authorityType","AuthorityType","Metadata","delegateRecord","approver","parseTokenMetadataDelegateInput","mint","programs","delegate","MetadataDelegate","tokenAccount","TokenDelegate","owner","Holder","UnreachableCaseError","getSignerFromTokenMetadataAuthority"],"mappings":"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"}