import { AptosClient, TransactionBuilderEd25519, TransactionBuilderRemoteABI, TxnBuilderTypes } from "aptos";
import { InjectedAptosSigner } from "arbundles/web";
import BigNumber from "bignumber.js";
import sha3 from "js-sha3";
// import { Ed25519PublicKey } from "aptos/src/aptos_types/ed25519";
// import { Transaction_UserTransaction, TransactionPayload_EntryFunctionPayload, TransactionPayload, PendingTransaction, UserTransaction } from "aptos/src/generated";
import BaseWebToken from "../token.js";
export default class AptosConfig extends BaseWebToken {
    signerInstance;
    _publicKey;
    constructor(config) {
        // if (typeof config.wallet === "string" && config.wallet.length === 66) config.wallet = Buffer.from(config.wallet.slice(2), "hex");
        // // @ts-ignore
        // config.accountInstance = new AptosAccount(config.wallet);
        super(config);
        this.base = ["aptom", 1e8];
    }
    async getProvider() {
        return (this.providerInstance ??= new AptosClient(this.providerUrl));
    }
    async getTx(txId) {
        const client = await this.getProvider();
        const tx = (await client.waitForTransactionWithResult(txId, /* { checkSuccess: true } */ { timeoutSecs: 1, checkSuccess: true }));
        const payload = tx?.payload;
        if (!tx.success) {
            throw new Error(tx?.vm_status ?? "Unknown Aptos error");
        }
        if (!(payload?.function === "0x1::coin::transfer" &&
            payload?.type_arguments[0] === "0x1::aptos_coin::AptosCoin" &&
            tx?.vm_status === "Executed successfully")) {
            throw new Error(`Aptos tx ${txId} failed validation`);
        }
        const isPending = tx.type === "pending_transaction";
        return {
            to: payload.arguments[0],
            from: tx.sender,
            amount: new BigNumber(payload.arguments[1]),
            pending: isPending,
            confirmed: !isPending,
        };
    }
    ownerToAddress(owner) {
        const hash = sha3.sha3_256.create();
        hash.update(Buffer.from(owner));
        hash.update("\x00");
        return `0x${hash.hex()}`;
    }
    async sign(data) {
        return await this.getSigner().sign(data);
    }
    getSigner() {
        return (this.signerInstance ??= new InjectedAptosSigner(this.wallet, this._publicKey));
    }
    async verify(pub, data, signature) {
        return await InjectedAptosSigner.verify(pub, data, signature);
    }
    async getCurrentHeight() {
        return new BigNumber((await (await this.getProvider()).client.blocks.httpRequest.request({ method: "GET", url: "/" })).block_height);
    }
    async getFee(amount, to) {
        const client = await this.getProvider();
        if (!this.address)
            throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
        const builder = new TransactionBuilderRemoteABI(client, { sender: this.address });
        const rawTransaction = await builder.build("0x1::coin::transfer", ["0x1::aptos_coin::AptosCoin"], [to ?? "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new BigNumber(amount).toNumber()]);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const txnBuilder = new TransactionBuilderEd25519((_signingMessage) => {
            const invalidSigBytes = new Uint8Array(64);
            return new TxnBuilderTypes.Ed25519Signature(invalidSigBytes);
        }, (await this.getPublicKey()));
        const signedSimulation = txnBuilder.sign(rawTransaction);
        const queryParams = {
            estimate_gas_unit_price: true,
            estimate_max_gas_amount: true,
        };
        const simulationResult = await client.client.request.request({
            url: "/transactions/simulate",
            query: queryParams,
            method: "POST",
            body: signedSimulation,
            mediaType: "application/x.aptos.signed_transaction+bcs",
        });
        return { gasUnitPrice: +simulationResult[0].gas_unit_price, maxGasAmount: +simulationResult[0].max_gas_amount };
        // const simulationResult = await client.simulateTransaction(this.accountInstance, rawTransaction, { estimateGasUnitPrice: true, estimateMaxGasAmount: true });
        // return new BigNumber(simulationResult?.[0].gas_unit_price).multipliedBy(simulationResult?.[0].gas_used);
        // const est = await provider.client.transactions.estimateGasPrice();
        // return new BigNumber(est.gas_estimate/* (await (await this.getProvider()).client.transactions.estimateGasPrice()).gas_estimate */); // * by gas limit (for upper limit)
    }
    async sendTx(data) {
        return (await this.wallet.signAndSubmitTransaction(data)).hash;
        // return (await (await (this.getProvider())).submitSignedBCSTransaction(data)).hash;
    }
    async createTx(amount, to, _fee) {
        // const client = await this.getProvider();
        // const payload = new CoinClient(client).transactionBuilder.buildTransactionPayload(
        //     "0x1::coin::transfer",
        //     ["0x1::aptos_coin::AptosCoin"],
        //     [to, new BigNumber(amount).toNumber()],
        // );
        const tx = {
            arguments: [to, new BigNumber(amount).toNumber()],
            function: "0x1::coin::transfer",
            type: "entry_function_payload",
            type_arguments: ["0x1::aptos_coin::AptosCoin"],
        };
        // const rawTransaction = await client.generateRawTransaction(this.accountInstance.address(), payload);
        // const bcsTxn = AptosClient.generateBCSTransaction(this.accountInstance, rawTransaction);
        // const tx = await this.wallet.signTransaction(transaction);
        return { txId: undefined, tx };
    }
    async getPublicKey() {
        return (this._publicKey ??= Buffer.from((await this.wallet.account()).publicKey.toString().slice(2), "hex"));
    }
    async ready() {
        this._publicKey = (await this.getPublicKey());
        this._address = this.ownerToAddress(this._publicKey);
        const client = await this.getProvider();
        this._address = await client
            .lookupOriginalAddress(this.address ?? "")
            .then((hs) => hs.toString())
            .catch((_) => this._address); // fallback to original
        if (this._address?.length == 66 && this._address.charAt(2) === "0") {
            this._address = this._address.slice(0, 2) + this._address.slice(3);
        }
    }
}
//# sourceMappingURL=aptos.js.map