import type { AxiosResponse } from "axios";
import BigNumber from "bignumber.js";
import type Api from "./api.js";
import type { Arbundles, Token, UploadReceipt, UploadReceiptData } from "./types.js";
export declare const sleep: (ms: any) => Promise<void>;
export default class Utils {
    api: Api;
    token: string;
    tokenConfig: Token;
    protected arbundles: Arbundles;
    constructor(api: Api, token: string, tokenConfig: Token);
    /**
     * Throws an error if the provided axios reponse has a status code != 200
     * @param res an axios response
     * @returns nothing if the status code is 200
     */
    static checkAndThrow(res: AxiosResponse, context?: string, exceptions?: number[]): void;
    /**
     * Gets the nonce used for withdrawal request validation from the bundler
     * @returns nonce for the current user
     */
    getNonce(): Promise<number>;
    /**
     * Gets the balance on the current bundler for the specified user
     * @param address the user's address to query
     * @returns the balance in winston
     */
    getBalance(address: string): Promise<BigNumber>;
    /**
     * Queries the bundler to get it's address for a specific token
     * @returns the bundler's address
     */
    getBundlerAddress(token: string): Promise<string>;
    /**
     * Calculates the price for [bytes] bytes paid for with [token] for the loaded Irys node.
     * @param token
     * @param bytes
     * @returns
     */
    getPrice(token: string, bytes: number): Promise<BigNumber>;
    /**
     * This function *estimates* the cost in atomic units for uploading a given set of files
     * note: this function becomes less accurate the smaller your transactions, unless you provide it with an accurate headerSizeAvg
     * @param folderInfo either an array of file sizes in bytes, or an object containing the total number of files and the sum total size of the files in bytes
     * note: for a more precise estimate, you can create an empty (dataless) transaction (make sure you still set tags and other metadata!) and then pass `tx.size` as `headerSizeAvg`
     */
    estimateFolderPrice(folderInfo: number[] | {
        fileCount: number;
        totalBytes: number;
        headerSizeAvg?: number;
    }): Promise<BigNumber>;
    /**
     * Returns the decimal values' equivalent in atomic units
     * @example
     * 0.1 ETH -> 100,000,000,000,000,000 wei
     * ```
     * toAtomic(100_000_000_000_000_000) -> 0.1
     * ```
     * @param decimalAmount - amount in decimal
     * @returns amount in atomic units
     */
    toAtomic(decimalAmount: BigNumber.Value): BigNumber;
    /**
     * Returns the atomic amounts' equivalent in decimal units
     * @example
     * 100,000,000,000,000,000 wei -> 0.1 ETH
     * ```
     * fromAtomic(0.1) -> 100_000_000_000_000_000
     * ```
     * @param atomicAmount
     * @returns
     */
    fromAtomic(atomicAmount: BigNumber.Value): BigNumber;
    /**
     * Polls for transaction confirmation (or at least pending status) - used for fast currencies (i.e not arweave)
     * before posting the fund request to the server (so the server doesn't have to poll)
     * @param txid
     * @returns
     */
    confirmationPoll(txid: string, seconds?: number): Promise<any>;
    /**
     * @deprecated this method is deprecated in favour of fromAtomic - removal slated for 0.12.0
     */
    unitConverter(baseUnits: BigNumber.Value): BigNumber;
    verifyReceipt(receipt: UploadReceiptData): Promise<boolean>;
    static verifyReceipt(dependencies: Pick<Arbundles, "stringToBuffer" | "getCryptoDriver" | "deepHash">, receipt: UploadReceiptData): Promise<boolean>;
    getReceipt(txId: string): Promise<UploadReceipt>;
}
