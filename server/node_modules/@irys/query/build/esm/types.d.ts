import type { Options as RetryOptions } from "async-retry";
export type GQLResponse<T> = {
    data: Record<string, {
        edges: T;
        pageInfo: PageInfo;
    }> | T;
    errors?: {
        message: string;
    }[];
};
export type PageInfo = {
    endCursor: string | undefined;
    hasNextPage: boolean;
};
/** Object describing metadata about a query, including the type, enum values, vars, and other info */
export type QueryInfo = {
    /** Name of the query (GQL query name) */
    name: string;
    /** Minimal object representing the return shape of the query */
    query: Record<string, any>;
    /** Names of all enumeration values - these need special formatting */
    enumValues?: string[];
    /** variables to supply the query */
    vars: Record<string, any>;
    /** Tell the GQL compiler to remap the variable with name <key> to variable with name <value> */
    remapVars?: Record<string, string | ((key: string, value: string, vars: any) => undefined | void | [newKey: string, newValue: string])>;
    paging?: {
        /** name of the hasNextPage pageInfo var */
        hasNextPage: string;
        /** name of the cursor edge var*/
        cursor: string;
    };
};
export type SearchOpts = {
    skipVariableSetters?: boolean;
    query?: QueryInfo | false;
};
export type QueryCtorOpts = {
    url: URL | string;
    retryConfig?: RetryOptions;
};
export type Pretty<T> = T extends (...args: any[]) => any ? T : T extends abstract new (...args: any[]) => any ? T : {
    [K in keyof T]: T[K];
};
export type ReturnFields<F extends S, S extends UserField> = {
    [K in keyof S]: F[K] extends (infer U)[] ? Pick<U, keyof S[K]>[] : S[K] extends object ? ReturnFields<F[K], S[K]> : S[K] extends true ? Required<F[K]> : undefined;
} | undefined;
type UserField = Record<string, true | (string | UserField)[] | UserField>;
export type Field<T extends Record<string, any>> = {
    [K in keyof T]?: T[K] extends (infer U extends object)[] ? Field<U> : T[K] extends object ? Field<T[K]> : boolean;
};
export type BuilderMethods<T extends Record<string, any>, R = any> = {
    [K in keyof T]-?: T[K] extends object ? BuilderMethods<T[K]> : (field: T[K]) => BuilderMethods<T, R>;
} & R;
export type ArrayElement<T> = T extends (infer U)[] ? U : T;
export declare function assertIs<T>(value: unknown): asserts value is T;
export type HasBuilderMethods<T extends Record<string, any>, R = any> = {
    [K in keyof T]-?: T[K] extends object ? BuilderMethods<T[K]> : (field: T[K]) => R & BuilderMethods<T, R>;
};
export {};
