'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mplCandyMachineCore = require('@metaplex-foundation/mpl-candy-machine-core');
var web3_js = require('@solana/web3.js');
var CandyMachine = require('../models/CandyMachine.cjs');
var Operation = require('../../../types/Operation.cjs');
var BigNumber = require('../../../types/BigNumber.cjs');
var PublicKey = require('../../../types/PublicKey.cjs');
var TransactionBuilder = require('../../../utils/TransactionBuilder.cjs');
var Signer = require('../../../types/Signer.cjs');
var SdkError = require('../../../errors/SdkError.cjs');

// -----------------
// Operation
// -----------------

const Key = 'CreateCandyMachineOperation';

/**
 * Creates a brand new Candy Machine with the provided settings.
 *
 * Unless the `withoutCandyGuard` option is set to `true`, a
 * Candy Guard will be created with the given guards and
 * immediately linked to the Candy Machine.
 *
 * ```ts
 *  const { candyMachine } = await metaplex
 *    .candyMachines()
 *    .create({
 *      itemsAvailable: toBigNumber(5000),
 *      sellerFeeBasisPoints: 333, // 3.33%
 *      collection: {
 *        address: collectionNft.address,
 *        updateAuthority: collectionUpdateAuthority,
 *      },
 *    });
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const createCandyMachineOperation = _createCandyMachineOperation;
// eslint-disable-next-line @typescript-eslint/naming-convention
function _createCandyMachineOperation(input) {
  return {
    key: Key,
    input
  };
}
_createCandyMachineOperation.key = Key;

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const createCandyMachineOperationHandler = {
  async handle(operation, metaplex, scope) {
    const builder = await createCandyMachineBuilder(metaplex, operation.input, scope);
    scope.throwIfCanceled();
    const confirmOptions = Operation.makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);
    const output = await builder.sendAndConfirm(metaplex, confirmOptions);
    scope.throwIfCanceled();
    const candyMachine = await metaplex.candyMachines().findByAddress({
      address: output.candyMachineSigner.publicKey
    }, scope);
    scope.throwIfCanceled();
    return {
      ...output,
      candyMachine
    };
  }
};

// -----------------
// Builder
// -----------------

/**
 * @group Transaction Builders
 * @category Inputs
 */

/**

 * Creates a brand new Candy Machine with the provided settings.
 *
 * Unless the `withoutCandyGuard` option is set to `true`, a
 * Candy Guard will be created with the given guards and
 * immediately linked to the Candy Machine.
 *
 * ```ts
 *  const transactionBuilder = await metaplex
 *    .candyMachines()
 *    .builders()
 *    .create({
 *      itemsAvailable: toBigNumber(5000),
 *      sellerFeeBasisPoints: 333, // 3.33%
 *      collection: {
 *        address: collectionNft.address,
 *        updateAuthority: collectionUpdateAuthority,
 *      },
 *    });
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */
const createCandyMachineBuilder = async (metaplex, params, options = {}) => {
  // Input.
  const {
    programs,
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const {
    candyMachine = web3_js.Keypair.generate(),
    authority = metaplex.identity(),
    collection,
    sellerFeeBasisPoints,
    itemsAvailable,
    symbol = '',
    maxEditionSupply = BigNumber.toBigNumber(0),
    isMutable = true,
    withoutCandyGuard = false
  } = params;
  const creators = params.creators ?? [{
    address: PublicKey.toPublicKey(authority),
    share: 100
  }];
  const itemSettings = params.itemSettings ?? {
    type: 'configLines',
    prefixName: '',
    nameLength: 32,
    prefixUri: '',
    uriLength: 200,
    isSequential: false
  };

  // PDAs.
  const authorityPda = metaplex.candyMachines().pdas().authority({
    candyMachine: candyMachine.publicKey,
    programs
  });
  const collectionMetadata = metaplex.nfts().pdas().metadata({
    mint: collection.address,
    programs
  });
  const collectionMasterEdition = metaplex.nfts().pdas().masterEdition({
    mint: collection.address,
    programs
  });
  const collectionAuthorityRecord = metaplex.nfts().pdas().collectionAuthorityRecord({
    mint: collection.address,
    collectionAuthority: authorityPda,
    programs
  });

  // Programs.
  const candyMachineProgram = metaplex.programs().getCandyMachine(programs);
  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);
  const candyMachineData = CandyMachine.toCandyMachineData({
    itemsAvailable,
    symbol,
    sellerFeeBasisPoints,
    maxEditionSupply,
    isMutable,
    creators,
    itemSettings
  });
  const builder = TransactionBuilder.TransactionBuilder.make().setFeePayer(payer).setContext({
    candyMachineSigner: candyMachine
  });
  let mintAuthority = PublicKey.toPublicKey(authority);
  if (!withoutCandyGuard) {
    const createCandyGuard = metaplex.candyMachines().builders().createCandyGuard({
      base: candyMachine,
      authority: PublicKey.toPublicKey(authority),
      guards: params.guards ?? {},
      groups: params.groups
    }, {
      programs,
      payer
    });
    const {
      candyGuardAddress
    } = createCandyGuard.getContext();
    mintAuthority = candyGuardAddress;
    builder.add(createCandyGuard);
  }
  return builder.add(await metaplex.system().builders().createAccount({
    space: CandyMachine.getCandyMachineSize(candyMachineData),
    newAccount: candyMachine,
    program: candyMachineProgram.address
  }, {
    payer,
    programs
  })).add({
    instruction: mplCandyMachineCore.createInitializeInstruction({
      candyMachine: candyMachine.publicKey,
      authorityPda,
      authority: PublicKey.toPublicKey(authority),
      payer: payer.publicKey,
      collectionMetadata,
      collectionMint: collection.address,
      collectionMasterEdition,
      collectionUpdateAuthority: collection.updateAuthority.publicKey,
      collectionAuthorityRecord,
      tokenMetadataProgram: tokenMetadataProgram.address
    }, {
      data: candyMachineData
    }, candyMachineProgram.address),
    signers: [payer, candyMachine, collection.updateAuthority],
    key: params.initializeCandyMachineInstructionKey ?? 'initializeCandyMachine'
  }).when(!withoutCandyGuard, builder => {
    if (!Signer.isSigner(authority)) {
      throw new SdkError.ExpectedSignerError('authority', 'PublicKey', 'In order to create a Candy Machine with an associated ' + 'Candy Guard you must provide the authority as a Signer.');
    }
    return builder.add(metaplex.candyMachines().builders().wrapCandyGuard({
      candyMachine: candyMachine.publicKey,
      candyMachineAuthority: authority,
      candyGuard: mintAuthority,
      candyGuardAuthority: authority,
      wrapCandyGuardInstructionKey: params.wrapCandyGuardInstructionKey
    }, {
      payer,
      programs
    }));
  });
};

exports.createCandyMachineBuilder = createCandyMachineBuilder;
exports.createCandyMachineOperation = createCandyMachineOperation;
exports.createCandyMachineOperationHandler = createCandyMachineOperationHandler;
//# sourceMappingURL=createCandyMachine.cjs.map
