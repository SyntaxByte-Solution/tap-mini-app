{"version":3,"file":"FeatureFlags.cjs","sources":["../../../src/types/FeatureFlags.ts"],"sourcesContent":["import { Buffer } from 'buffer';\n\nexport type FeatureFlags = boolean[];\n\n/**\n * Serializes an array of boolean into a Buffer. The `byteSize` parameter\n * can be used to create a fixed-size Buffer, otherwise the Buffer will\n * have the minimum amount of bytes required to store the boolean array.\n *\n * Returns a Buffer whose bits are ordered from left to right, unless\n * `backward` is set to true, in which case the bits are ordered from\n * right to left.\n */\nexport const serializeFeatureFlags = (\n  features: FeatureFlags,\n  byteSize?: number,\n  backward = false\n): Buffer => {\n  byteSize = byteSize ?? Math.ceil(features.length / 8);\n  const bytes: number[] = [];\n\n  for (let i = 0; i < byteSize; i++) {\n    let byte = 0;\n    for (let j = 0; j < 8; j++) {\n      const feature = Number(features[i * 8 + j] ?? 0);\n      byte |= feature << (backward ? j : 7 - j);\n    }\n    if (backward) {\n      bytes.unshift(byte);\n    } else {\n      bytes.push(byte);\n    }\n  }\n\n  return Buffer.from(bytes);\n};\n\n/**\n * Parses a Buffer into an array of booleans using the\n * bits of the buffer. The number of flags can be provided\n * to determine how many booleans to return.\n *\n * Expects the bits in the Buffer to be ordered from left to right,\n * unless `backward` is set to true, we expect the bits to be\n * ordered from right to left.\n */\nexport const deserializeFeatureFlags = (\n  buffer: Buffer,\n  numberOfFlags?: number,\n  backward = false\n): FeatureFlags => {\n  const booleans: boolean[] = [];\n  buffer = backward ? buffer.reverse() : buffer;\n\n  for (let byte of buffer) {\n    for (let i = 0; i < 8; i++) {\n      if (backward) {\n        booleans.push(Boolean(byte & 1));\n        byte >>= 1;\n      } else {\n        booleans.push(Boolean(byte & 0b1000_0000));\n        byte <<= 1;\n      }\n    }\n  }\n\n  return booleans.slice(0, numberOfFlags);\n};\n"],"names":["serializeFeatureFlags","features","byteSize","backward","Math","ceil","length","bytes","i","byte","j","feature","Number","unshift","push","Buffer","from","deserializeFeatureFlags","buffer","numberOfFlags","booleans","reverse","Boolean","slice"],"mappings":";;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,qBAAqB,GAAG,CACnCC,QAAsB,EACtBC,QAAiB,EACjBC,QAAQ,GAAG,KAAK,KACL;AACXD,EAAAA,QAAQ,GAAGA,QAAQ,IAAIE,IAAI,CAACC,IAAI,CAACJ,QAAQ,CAACK,MAAM,GAAG,CAAC,CAAC,CAAA;EACrD,MAAMC,KAAe,GAAG,EAAE,CAAA;EAE1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,QAAQ,EAAEM,CAAC,EAAE,EAAE;IACjC,IAAIC,IAAI,GAAG,CAAC,CAAA;IACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;AAC1B,MAAA,MAAMC,OAAO,GAAGC,MAAM,CAACX,QAAQ,CAACO,CAAC,GAAG,CAAC,GAAGE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAA;MAChDD,IAAI,IAAIE,OAAO,KAAKR,QAAQ,GAAGO,CAAC,GAAG,CAAC,GAAGA,CAAC,CAAC,CAAA;AAC3C,KAAA;AACA,IAAA,IAAIP,QAAQ,EAAE;AACZI,MAAAA,KAAK,CAACM,OAAO,CAACJ,IAAI,CAAC,CAAA;AACrB,KAAC,MAAM;AACLF,MAAAA,KAAK,CAACO,IAAI,CAACL,IAAI,CAAC,CAAA;AAClB,KAAA;AACF,GAAA;AAEA,EAAA,OAAOM,aAAM,CAACC,IAAI,CAACT,KAAK,CAAC,CAAA;AAC3B,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMU,uBAAuB,GAAG,CACrCC,MAAc,EACdC,aAAsB,EACtBhB,QAAQ,GAAG,KAAK,KACC;EACjB,MAAMiB,QAAmB,GAAG,EAAE,CAAA;EAC9BF,MAAM,GAAGf,QAAQ,GAAGe,MAAM,CAACG,OAAO,EAAE,GAAGH,MAAM,CAAA;AAE7C,EAAA,KAAK,IAAIT,IAAI,IAAIS,MAAM,EAAE;IACvB,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;AAC1B,MAAA,IAAIL,QAAQ,EAAE;QACZiB,QAAQ,CAACN,IAAI,CAACQ,OAAO,CAACb,IAAI,GAAG,CAAC,CAAC,CAAC,CAAA;AAChCA,QAAAA,IAAI,KAAK,CAAC,CAAA;AACZ,OAAC,MAAM;QACLW,QAAQ,CAACN,IAAI,CAACQ,OAAO,CAACb,IAAI,GAAG,WAAW,CAAC,CAAC,CAAA;AAC1CA,QAAAA,IAAI,KAAK,CAAC,CAAA;AACZ,OAAA;AACF,KAAA;AACF,GAAA;AAEA,EAAA,OAAOW,QAAQ,CAACG,KAAK,CAAC,CAAC,EAAEJ,aAAa,CAAC,CAAA;AACzC;;;;;"}