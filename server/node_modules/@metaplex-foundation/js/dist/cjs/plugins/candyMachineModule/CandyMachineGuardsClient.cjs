'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.cjs');
var buffer = require('buffer');
var beet = require('@metaplex-foundation/beet');
var constants = require('./constants.cjs');
var errors = require('./errors.cjs');
var Serializer = require('../../types/Serializer.cjs');
var FeatureFlags = require('../../types/FeatureFlags.cjs');
var common = require('../../utils/common.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var beet__namespace = /*#__PURE__*/_interopNamespace(beet);

/**
 * This client enables us to register custom guards from
 * custom Candy Guard programs and interact with them.
 *
 * @see {@link CandyGuardClient}
 * @group Module
 */
class CandyMachineGuardsClient {
  constructor(metaplex) {
    _rollupPluginBabelHelpers.defineProperty(this, "guards", []);
    this.metaplex = metaplex;
  }

  /** Registers one or many guards by providing their manifest. */
  register(...guard) {
    this.guards.push(...guard);
  }

  /** Gets the manifest of a guard using its name. */
  get(name) {
    const guard = this.guards.find(guard => guard.name === name);
    if (!guard) {
      throw new errors.UnregisteredCandyGuardError(name);
    }
    return guard;
  }

  /** Gets all registered guard manifests. */
  all() {
    return this.guards;
  }

  /**
   * Gets all guard manifests for a registered Candy Guard program.
   *
   * It fails if the manifest of any guard expected by the program
   * is not registered. Manifests are returned in the order in which
   * they are defined on the `availableGuards` property of the program.
   */
  forProgram(program = 'CandyGuardProgram') {
    const candyGuardProgram = typeof program === 'object' && 'availableGuards' in program ? program : this.metaplex.programs().get(program);
    return candyGuardProgram.availableGuards.map(name => this.get(name));
  }

  /**
   * Gets all guard manifests for the registered Candy Guard program.
   *
   * @see {@link CandyMachineGuardsClient.forProgram}
   */
  forCandyGuardProgram(programs = []) {
    const candyGuardProgram = this.metaplex.programs().getCandyGuard(programs);
    return this.forProgram(candyGuardProgram);
  }

  /** Serializes the settings of all guards and groups. */
  serializeSettings(guards, groups = [], programs = []) {
    const availableGuards = this.forCandyGuardProgram(programs);
    this.assertGuardsAreRegistered(guards, groups, availableGuards.map(({
      name
    }) => name));
    const serializeSet = set => {
      const {
        features,
        buffer: buffer$1
      } = availableGuards.reduce((acc, guard, index) => {
        const value = set[guard.name] ?? null;
        acc.features[index] = Boolean(value);
        if (value) {
          acc.buffer = buffer.Buffer.concat([acc.buffer, Serializer.serialize(value, guard.settingsSerializer)]);
        }
        return acc;
      }, {
        features: [],
        buffer: buffer.Buffer.from([])
      });
      const serializedfeatures = FeatureFlags.serializeFeatureFlags(features, 8, true);
      serializedfeatures.reverse();
      return buffer.Buffer.concat([serializedfeatures, buffer$1]);
    };
    let buffer$1 = serializeSet(guards);
    const groupCountBuffer = buffer.Buffer.alloc(4);
    beet__namespace.u32.write(groupCountBuffer, 0, groups.length);
    buffer$1 = buffer.Buffer.concat([buffer$1, groupCountBuffer]);
    groups.forEach(group => {
      if (group.label.length > constants.CANDY_GUARD_LABEL_SIZE) {
        throw new errors.GuardGroupLabelTooLongError(group.label, constants.CANDY_GUARD_LABEL_SIZE);
      }
      const labelBuffer = buffer.Buffer.alloc(constants.CANDY_GUARD_LABEL_SIZE);
      labelBuffer.write(common.padEmptyChars(group.label, constants.CANDY_GUARD_LABEL_SIZE), 0, constants.CANDY_GUARD_LABEL_SIZE, 'utf8');
      buffer$1 = buffer.Buffer.concat([buffer$1, labelBuffer, serializeSet(group.guards)]);
    });
    return buffer$1;
  }

  /** Deserializes the settings of all guards and groups. */
  deserializeSettings(buffer, program = 'CandyGuardProgram') {
    const availableGuards = this.forProgram(program);
    const deserializeSet = () => {
      const serializedFeatures = buffer.slice(0, 8);
      serializedFeatures.reverse();
      const features = FeatureFlags.deserializeFeatureFlags(serializedFeatures, 64, true);
      buffer = buffer.slice(8);
      return availableGuards.reduce((acc, guard, index) => {
        const isEnabled = features[index] ?? false;
        acc[guard.name] = null;
        if (!isEnabled) return acc;
        const [settings] = Serializer.deserialize(buffer, guard.settingsSerializer);
        buffer = buffer.slice(guard.settingsBytes);
        acc[guard.name] = settings;
        return acc;
      }, {});
    };
    const guards = deserializeSet();
    const groups = [];
    const groupsCount = beet__namespace.u32.read(buffer, 0);
    buffer = buffer.slice(4);
    for (let i = 0; i < groupsCount; i++) {
      const label = common.removeEmptyChars(buffer.slice(0, constants.CANDY_GUARD_LABEL_SIZE).toString('utf8'));
      buffer = buffer.slice(constants.CANDY_GUARD_LABEL_SIZE);
      groups.push({
        label,
        guards: deserializeSet()
      });
    }
    return {
      guards,
      groups
    };
  }

  /**
   * Resolves the set of settings that should be used when minting.
   *
   * If no group exists, the `guards` settings will be used.
   * Otherwise, the `guards` settings will act as default settings and
   * the settings of the selected group will override them.
   */
  resolveGroupSettings(guards, groups = [], groupLabel) {
    const availableGroups = groups.map(group => group.label);
    const activeGroup = groups.find(group => group.label === groupLabel);
    if (groupLabel && !activeGroup) {
      throw new errors.SelectedGuardGroupDoesNotExistError(groupLabel, availableGroups);
    }
    if (groups.length === 0) {
      return guards;
    }
    if (!activeGroup) {
      throw new errors.GuardGroupRequiredError(availableGroups);
    }
    const activeGroupGuardsWithoutNullGuards = Object.fromEntries(Object.entries(activeGroup.guards).filter(([, v]) => v != null));
    return {
      ...guards,
      ...activeGroupGuardsWithoutNullGuards
    };
  }

  /**
   * Parses the arguments and remaining accounts of
   * all relevant guards for the mint instruction.
   */
  parseMintSettings(candyMachine, candyGuard, owner, payer, mint, guardMintSettings, groupLabel, programs = []) {
    const availableGuards = this.forCandyGuardProgram(programs);
    const guardSettings = this.resolveGroupSettings(candyGuard.guards, candyGuard.groups, groupLabel);
    const initialAccumulator = {
      arguments: buffer.Buffer.from([]),
      accountMetas: [],
      signers: []
    };
    return availableGuards.reduce((acc, guard) => {
      const settings = guardSettings[guard.name] ?? null;
      const mintSettings = guardMintSettings[guard.name] ?? null;
      if (!guard.mintSettingsParser || !settings) return acc;
      const parsedSettings = guard.mintSettingsParser({
        metaplex: this.metaplex,
        settings,
        mintSettings,
        owner,
        payer,
        mint,
        candyMachine,
        candyGuard: candyGuard.address,
        candyGuardAuthority: candyGuard.authorityAddress,
        programs
      });
      const accounts = this.getAccountMetas(parsedSettings.remainingAccounts);
      const signers = this.getSigners(parsedSettings.remainingAccounts);
      acc.arguments = buffer.Buffer.concat([acc.arguments, parsedSettings.arguments]);
      acc.accountMetas.push(...accounts);
      acc.signers.push(...signers);
      return acc;
    }, initialAccumulator);
  }

  /**
   * Parses the arguments and remaining accounts of
   * the requested guard for the route instruction.
   */
  parseRouteSettings(candyMachine, candyGuard, payer, guard, routeSettings, groupLabel, programs = []) {
    const guardManifest = this.get(guard);
    if (!guardManifest.routeSettingsParser) {
      throw new errors.GuardRouteNotSupportedError(guard);
    }
    const guardSettings = this.resolveGroupSettings(candyGuard.guards, candyGuard.groups, groupLabel);
    const settings = guardSettings[guard] ?? null;
    if (!settings) {
      throw new errors.GuardNotEnabledError(guard, groupLabel);
    }
    const parsedSettings = guardManifest.routeSettingsParser({
      metaplex: this.metaplex,
      settings,
      routeSettings,
      payer,
      candyMachine,
      candyGuard: candyGuard.address,
      candyGuardAuthority: candyGuard.authorityAddress,
      programs
    });
    return {
      arguments: parsedSettings.arguments,
      accountMetas: this.getAccountMetas(parsedSettings.remainingAccounts),
      signers: this.getSigners(parsedSettings.remainingAccounts)
    };
  }

  /** @internal */
  getAccountMetas(remainingAccounts) {
    return remainingAccounts.map(account => ({
      pubkey: account.isSigner ? account.address.publicKey : account.address,
      isSigner: account.isSigner,
      isWritable: account.isWritable
    }));
  }

  /** @internal */
  getSigners(remainingAccounts) {
    return remainingAccounts.filter(account => account.isSigner).map(account => account.address);
  }

  /** @internal */
  assertGuardsAreRegistered(guards, groups, availableGuardNames) {
    const guardNames = new Set();
    const addGuardSet = guardSet => {
      Object.keys(guardSet).forEach(name => {
        if (!!guardSet[name]) {
          guardNames.add(name);
        }
      });
    };
    addGuardSet(guards);
    groups.forEach(group => addGuardSet(group.guards));
    guardNames.forEach(name => {
      if (!availableGuardNames.includes(name)) {
        throw new errors.UnregisteredCandyGuardError(name);
      }
    });
  }
}

exports.CandyMachineGuardsClient = CandyMachineGuardsClient;
//# sourceMappingURL=CandyMachineGuardsClient.cjs.map
