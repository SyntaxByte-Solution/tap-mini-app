'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../_virtual/_rollupPluginBabelHelpers.cjs');
var mplTokenMetadata = require('@metaplex-foundation/mpl-token-metadata');
var mplBubblegum = require('@metaplex-foundation/mpl-bubblegum');
var web3_js = require('@solana/web3.js');
var BN = require('bn.js');
var ReadApiError = require('../errors/ReadApiError.cjs');
var BigNumber = require('../types/BigNumber.cjs');
var Amount = require('../types/Amount.cjs');
var Pda = require('../types/Pda.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);

const toNftEditionFromReadApiAsset = input => {
  return {
    model: 'nftEdition',
    isOriginal: true,
    address: new web3_js.PublicKey(input.id),
    supply: BigNumber.toBigNumber(input.supply.print_current_supply),
    maxSupply: BigNumber.toBigNumber(input.supply.print_max_supply)
  };
};
const toMintFromReadApiAsset = input => {
  const currency = {
    symbol: 'Token',
    decimals: 0,
    namespace: 'spl-token'
  };
  return {
    model: 'mint',
    address: new web3_js.PublicKey(input.id),
    // TODO(jon): Presumably, this should be the Master Edition address upon decompression
    mintAuthorityAddress: new web3_js.PublicKey(input.id),
    // TODO(jon): Presumably, this should be the Master Edition address upon decompression
    freezeAuthorityAddress: new web3_js.PublicKey(input.id),
    decimals: 0,
    supply: Amount.amount(1, currency),
    isWrappedSol: false,
    currency
  };
};
const toMetadataFromReadApiAsset = input => {
  const updateAuthority = input.authorities?.find(authority => authority.scopes.includes('full'));
  const collection = input.grouping.find(({
    group_key
  }) => group_key === 'collection');
  return {
    model: 'metadata',
    // TODO(jon): We technically don't have a metadata address anymore. We can derive one though
    address: Pda.Pda.find(mplBubblegum.PROGRAM_ID, [Buffer.from('asset', 'utf-8'), new web3_js.PublicKey(input.compression.tree).toBuffer(), Uint8Array.from(new BN__default["default"](input.compression.leaf_id).toArray('le', 8))]),
    mintAddress: new web3_js.PublicKey(input.id),
    updateAuthorityAddress: new web3_js.PublicKey(updateAuthority.address),
    name: input.content.metadata?.name ?? '',
    symbol: input.content.metadata?.symbol ?? '',
    json: input.content.metadata,
    jsonLoaded: true,
    uri: input.content.json_uri,
    isMutable: input.mutable,
    primarySaleHappened: input.royalty.primary_sale_happened,
    sellerFeeBasisPoints: input.royalty.basis_points,
    creators: input.creators,
    editionNonce: input.supply.edition_nonce,
    tokenStandard: mplTokenMetadata.TokenStandard.NonFungible,
    collection: collection ? {
      address: new web3_js.PublicKey(collection.group_value),
      verified: false
    } : null,
    compression: input.compression,
    // TODO(jon): Read API doesn't return this info
    collectionDetails: null,
    // TODO(jon): Read API doesn't return this info
    uses: null,
    // TODO(jon): Read API doesn't return this info
    programmableConfig: null
  };
};
class ReadApiConnection extends web3_js.Connection {
  constructor(endpoint, commitmentOrConfig) {
    // TODO(jon): Take in an optional override for the Read API, or potentially adapters for other endpoints
    super(endpoint, commitmentOrConfig);
    _rollupPluginBabelHelpers.defineProperty(this, "callReadApi", async jsonRpcParams => {
      const response = await fetch(this.rpcEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          jsonrpc: '2.0',
          method: jsonRpcParams.method,
          id: jsonRpcParams.id ?? 'rpd-op-123',
          params: jsonRpcParams.params
        })
      });
      return await response.json();
    });
  }
  // Asset id can be calculated via Bubblegum#getLeafAssetId
  // It is a PDA with the following seeds: ["asset", tree, leafIndex]
  async getAsset(assetId) {
    const {
      result: asset
    } = await this.callReadApi({
      method: 'getAsset',
      params: {
        id: assetId.toBase58()
      }
    });
    if (!asset) throw new ReadApiError.ReadApiError('No asset returned');
    return asset;
  }

  // Asset id can be calculated via Bubblegum#getLeafAssetId
  // It is a PDA with the following seeds: ["asset", tree, leafIndex]
  async getAssetProof(assetId) {
    const {
      result: proof
    } = await this.callReadApi({
      method: 'getAssetProof',
      params: {
        id: assetId.toBase58()
      }
    });
    if (!proof) throw new ReadApiError.ReadApiError('No asset proof returned');
    return proof;
  }

  //
  async getAssetsByGroup({
    groupKey,
    groupValue,
    page,
    limit,
    sortBy,
    before,
    after
  }) {
    // `page` cannot be supplied with `before` or `after`
    if (typeof page == 'number' && (before || after)) throw new ReadApiError.ReadApiError('Pagination Error. Only one pagination parameter supported per query.');
    // a pagination method MUST be selected
    if (typeof page == 'number' || before || after) throw new ReadApiError.ReadApiError('Pagination Error. No Pagination Method Selected.');
    const {
      result
    } = await this.callReadApi({
      method: 'getAssetsByGroup',
      params: {
        groupKey,
        groupValue,
        after: after ?? null,
        before: before ?? null,
        limit: limit ?? null,
        page: page ?? 0,
        sortBy: sortBy ?? null
      }
    });
    if (!result) throw new ReadApiError.ReadApiError('No results returned');
    return result;
  }

  //
  async getAssetsByOwner({
    ownerAddress,
    page,
    limit,
    sortBy,
    before,
    after
  }) {
    // `page` cannot be supplied with `before` or `after`
    if (typeof page == 'number' && (before || after)) throw new ReadApiError.ReadApiError('Pagination Error. Only one pagination parameter supported per query.');
    // a pagination method MUST be selected
    if (typeof page == 'number' || before || after) throw new ReadApiError.ReadApiError('Pagination Error. No Pagination Method Selected.');
    const {
      result
    } = await this.callReadApi({
      method: 'getAssetsByOwner',
      params: {
        ownerAddress,
        after: after ?? null,
        before: before ?? null,
        limit: limit ?? null,
        page: page ?? 0,
        sortBy: sortBy ?? null
      }
    });
    if (!result) throw new ReadApiError.ReadApiError('No results returned');
    return result;
  }
}

exports.ReadApiConnection = ReadApiConnection;
exports.toMetadataFromReadApiAsset = toMetadataFromReadApiAsset;
exports.toMintFromReadApiAsset = toMintFromReadApiAsset;
exports.toNftEditionFromReadApiAsset = toNftEditionFromReadApiAsset;
//# sourceMappingURL=readApiConnection.cjs.map
