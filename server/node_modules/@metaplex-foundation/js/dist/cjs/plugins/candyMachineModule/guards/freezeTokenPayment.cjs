'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = require('buffer');
var beet = require('@metaplex-foundation/beet');
var mplCandyGuard = require('@metaplex-foundation/mpl-candy-guard');
var errors = require('../errors.cjs');
var assert = require('../../../utils/assert.cjs');
var Serializer = require('../../../types/Serializer.cjs');
var Amount = require('../../../types/Amount.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var beet__namespace = /*#__PURE__*/_interopNamespace(beet);

/**
 * The freezeTokenPayment guard allows minting frozen NFTs by charging
 * the payer a specific amount of tokens from a certain mint acount.
 * Frozen NFTs cannot be transferred or listed on any marketplaces until thawed.
 *
 * The funds are transferred to a freeze escrow until all NFTs are thaw,
 * at which point, they can be transferred (unlocked) to the configured
 * destination account.
 *
 * This object defines the settings that should be
 * provided when creating and/or updating a Candy
 * Machine if you wish to enable this guard.
 *
 * @see {@link FreezeTokenPaymentGuardRouteSettings} to learn more about
 * the instructions that can be executed against this guard.
 */

/** @internal */
const freezeTokenPaymentGuardManifest = {
  name: 'freezeTokenPayment',
  settingsBytes: 72,
  settingsSerializer: Serializer.mapSerializer(Serializer.createSerializerFromBeet(mplCandyGuard.freezeTokenPaymentBeet), settings => ({
    mint: settings.mint,
    amount: Amount.token(settings.amount),
    destinationAta: settings.destinationAta
  }), settings => ({
    mint: settings.mint,
    amount: settings.amount.basisPoints,
    destinationAta: settings.destinationAta
  })),
  mintSettingsParser: ({
    metaplex,
    settings,
    owner,
    payer,
    mint: nftMint,
    candyMachine,
    candyGuard,
    programs
  }) => {
    if (!owner.equals(payer.publicKey)) {
      throw new errors.MintOwnerMustBeMintPayerError('freezeTokenPayment');
    }
    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
      destination: settings.destinationAta,
      candyMachine,
      candyGuard,
      programs
    });
    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({
      mint: nftMint.publicKey,
      owner: payer.publicKey
    });
    const tokenAddress = metaplex.tokens().pdas().associatedTokenAccount({
      mint: settings.mint,
      owner: payer.publicKey,
      programs
    });
    const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({
      mint: settings.mint,
      owner: freezeEscrow,
      programs
    });
    return {
      arguments: buffer.Buffer.from([]),
      remainingAccounts: [{
        isSigner: false,
        address: freezeEscrow,
        isWritable: true
      }, {
        isSigner: false,
        address: nftAta,
        isWritable: false
      }, {
        isSigner: false,
        address: tokenAddress,
        isWritable: true
      }, {
        isSigner: false,
        address: freezeAta,
        isWritable: true
      }]
    };
  },
  routeSettingsParser: input => {
    switch (input.routeSettings.path) {
      case 'initialize':
        return initializeRouteInstruction(input);
      case 'thaw':
        return thawRouteInstruction(input);
      case 'unlockFunds':
        return unlockFundsRouteInstruction(input);
      default:
        throw new errors.UnrecognizePathForRouteInstructionError('freezeTokenPayment',
        // @ts-ignore
        input.routeSettings.path);
    }
  }
};
function initializeRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert["default"](routeSettings.path === 'initialize');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destinationAta,
    candyMachine,
    candyGuard,
    programs
  });
  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: settings.mint,
    owner: freezeEscrow,
    programs
  });
  const systemProgram = metaplex.programs().getSystem(programs);
  const tokenProgram = metaplex.programs().getToken(programs);
  const associatedTokenProgram = metaplex.programs().getAssociatedToken(programs);
  const args = buffer.Buffer.alloc(9);
  beet__namespace.u8.write(args, 0, mplCandyGuard.FreezeInstruction.Initialize);
  beet__namespace.u64.write(args, 1, routeSettings.period);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: true,
      address: routeSettings.candyGuardAuthority,
      isWritable: false
    }, {
      isSigner: false,
      address: systemProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: freezeAta,
      isWritable: true
    }, {
      isSigner: false,
      address: settings.mint,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: associatedTokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: settings.destinationAta,
      isWritable: true
    }]
  };
}
function thawRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert["default"](routeSettings.path === 'thaw');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destinationAta,
    candyMachine,
    candyGuard,
    programs
  });
  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: routeSettings.nftMint,
    owner: routeSettings.nftOwner,
    programs
  });
  const nftEdition = metaplex.nfts().pdas().masterEdition({
    mint: routeSettings.nftMint,
    programs
  });
  const tokenProgram = metaplex.programs().getToken(programs);
  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);
  const args = buffer.Buffer.alloc(1);
  beet__namespace.u8.write(args, 0, mplCandyGuard.FreezeInstruction.Thaw);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: false,
      address: routeSettings.nftMint,
      isWritable: false
    }, {
      isSigner: false,
      address: routeSettings.nftOwner,
      isWritable: false
    }, {
      isSigner: false,
      address: nftAta,
      isWritable: true
    }, {
      isSigner: false,
      address: nftEdition,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenMetadataProgram.address,
      isWritable: false
    }]
  };
}
function unlockFundsRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert["default"](routeSettings.path === 'unlockFunds');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destinationAta,
    candyMachine,
    candyGuard,
    programs
  });
  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: settings.mint,
    owner: freezeEscrow,
    programs
  });
  const systemProgram = metaplex.programs().getSystem(programs);
  const tokenProgram = metaplex.programs().getToken(programs);
  const args = buffer.Buffer.alloc(1);
  beet__namespace.u8.write(args, 0, mplCandyGuard.FreezeInstruction.UnlockFunds);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: true,
      address: routeSettings.candyGuardAuthority,
      isWritable: false
    }, {
      isSigner: false,
      address: freezeAta,
      isWritable: true
    }, {
      isSigner: false,
      address: settings.destinationAta,
      isWritable: true
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: systemProgram.address,
      isWritable: false
    }]
  };
}

exports.freezeTokenPaymentGuardManifest = freezeTokenPaymentGuardManifest;
//# sourceMappingURL=freezeTokenPayment.cjs.map
