"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLQuery = void 0;
const axios_1 = __importDefault(require("axios"));
const stream_1 = require("stream");
const async_retry_1 = __importDefault(require("async-retry"));
// GraphQL query builder class, uses overload signatures to modify class generics to provide concise typings for any configured query
// this approach does mean (atm anyway) we need to explicitly coerce return types to the correct "shape", but as most of the methods are dynamic, this isn't much of an issue.
// TODO: look into constructor facade pattern - https://gist.github.com/kourge/9715e0dd59c28e776fb598d407636106
// TODO: look into https://discord.com/channels/508357248330760243/1122523559097548870
/**
 * GraphQL query class - encapsulates all logic, types, and methods required to resolve queries
 */
class GraphQLQuery {
    constructor({ url, retryConfig, query, queryName, opts, }) {
        /* implements BuilderMethods<TVars, GraphQLQuery<TQuery, TVars, TReturn>> */
        // query variables
        this.queryVars = {};
        // result tracker object, used to hold state for paging operations
        this.resultTracker = { numPages: 0, numResults: 0, done: false };
        if (!url)
            throw new Error("URL is required");
        this.url = new URL(url);
        this.config = {
            first: false,
            userProvided: false,
            numPages: Infinity,
            numResults: 1000,
            retryOpts: Object.assign({ retries: 3, maxTimeout: 2000, minTimeout: 500 }, retryConfig),
        };
        if (query === false)
            return this;
        if (!query)
            throw new Error(`Unable to find query with name ${queryName}`);
        this.queryInfo = Object.assign({}, query);
        this.queryFields = query.query;
        if (queryName.includes("arweave") && this.url.host === "node1.bundlr.network")
            this.url = new URL("https://arweave.net/graphql");
        if (!(opts === null || opts === void 0 ? void 0 : opts.skipVariableSetters)) {
            // generate dynamic variable setter builder methods
            for (const k of Object.keys(query.vars)) {
                if (this[k])
                    throw new Error(`Field setter ${k} has a key conflict - disable with opts.skipVariableSetters OR change the field name and add to query.remapVars`);
                this[k] = (value) => {
                    this.queryVars[k] = value;
                    return this;
                };
            }
        }
        return this;
    }
    /**
     * Builds a query from fields and variables, formatting it into a GQL compatible string.
     * stores built query under `this.query` (protected) - accessible via `.toQuery`
     * @returns `this` (chainable)
     */
    buildQuery() {
        var _a, _b, _c, _d;
        // @ts-expect-error overloading
        if (this.config.userProvided)
            return this; // don't build if it's a user provided query string
        // builds query, reducing `this.queryFields` to a structured string with correct formatting
        const toGQLString = (s) => JSON.stringify(s, (_, v) => {
            if (v instanceof Array)
                return v[0]; /* JSON.stringify(v); */
            if (typeof v === "object")
                return v;
            if (v === false)
                return undefined;
            return "";
        })
            .replaceAll(`:`, "")
            .replaceAll(`"`, "")
            .replaceAll(",", "\n          ");
        const nodeQuery = toGQLString(this.queryFields);
        // the hasNextPage field can vary
        const pageInfo = toGQLString({ pageInfo: { [(_b = (_a = this.queryInfo.paging) === null || _a === void 0 ? void 0 : _a.hasNextPage) !== null && _b !== void 0 ? _b : "hasNextPage"]: undefined } }).slice(1, -1); // remove leading "{" and finishing "}"
        const enumValues = this.queryInfo.enumValues;
        // incorporates defaults from queryInfo
        const vars = Object.assign(Object.assign({}, this.queryInfo.vars), this.queryVars);
        // remap keys - primarily done to prevent conflicts with builder methods.
        // {limit: "first"} -> remaps `limit` variable to `first` variable
        // {limit: (k,v) => ["first",v]} does the same thing
        for (const [k, v] of Object.entries((_c = this.queryInfo.remapVars) !== null && _c !== void 0 ? _c : {})) {
            if ((vars === null || vars === void 0 ? void 0 : vars[k]) === undefined)
                continue;
            if (typeof v === "function") {
                // provided mapper fn
                const m = v(k, vars[k], vars);
                if (!m)
                    continue;
                const [nk, nv] = m;
                vars[nk] = nv;
                if (nk === k)
                    continue; // don't null out key if it's the same key
            }
            else {
                vars[v] = vars[k];
            }
            vars[k] = undefined; // null keys are removed below
        }
        // reduces queryVars to inline vars, for convenience. (using separate means we have to annotate the GQL type)
        const qVars = JSON.stringify(vars, function (k, v) {
            // console.log(this, k, v);
            if (v === undefined)
                return v; // remove null keys
            if (v instanceof Array)
                return v; // don't break recursion
            if (typeof v === "object")
                return v; // ^
            if (typeof v === "number")
                return v; // numbers don't need string escaping
            // TODO: improve this so it's context aware and doesn't alter anything unintentional
            // can probably do by logging key names into array if value is an object, popping when object is a primitive
            if (enumValues === null || enumValues === void 0 ? void 0 : enumValues.includes(k))
                return v; // exclude enum variants from quote addition
            return `'${v}'`; // this value needs to be quote padded
        })
            .replaceAll('"', "") // remove double quotes,
            .replaceAll("'", '"') // add needed double quotes
            .slice(1, -1); // remove leading "{" and finishing "}"
        if (!((_d = this === null || this === void 0 ? void 0 : this.queryInfo) === null || _d === void 0 ? void 0 : _d.name))
            throw new Error(`Query name is undefined!`);
        // discriminate based on whether the query is pageable
        const query = this.queryInfo.paging
            ? `query {
      ${this.queryInfo.name}(
        ${qVars}
      ) {
        edges {
          cursor
          node ${nodeQuery}
        }
        ${pageInfo}
      }
    }`
            : `query {
    ${this.queryInfo.name}(
      ${qVars}
    ) 
    ${nodeQuery}
  }`;
        this._query = query;
        // @ts-expect-error types - DO NOT SET RETURN TYPE TO `this` - TS will assume this should be an async function as `this` implements promise methods
        return this;
    }
    /**
     * Primary query execution method - builds & runs the query, returning result nodes and updating cursor info in queryVars
     * @returns query result nodes
     */
    getPage() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.resultTracker.done)
                return undefined;
            this.buildQuery();
            if (!this._query)
                throw new Error(`Unable to run undefined query`);
            let res;
            try {
                res = yield (0, async_retry_1.default)((_) => __awaiter(this, void 0, void 0, function* () {
                    const r = yield (0, axios_1.default)(this.url.toString(), {
                        method: "post",
                        headers: { "Content-Type": "application/json" },
                        data: { query: this._query },
                    });
                    if (r.data.errors)
                        throw r;
                    return r;
                }), this.config.retryOpts);
            }
            catch (e) {
                throw new Error(`Error running query\n ${this._query} - ${e.message ? e.message + " -" : ""} (${JSON.stringify((_c = (_b = (_a = e === null || e === void 0 ? void 0 : e.data) === null || _a === void 0 ? void 0 : _a.errors.map((e) => e.message)) !== null && _b !== void 0 ? _b : e === null || e === void 0 ? void 0 : e.errors) !== null && _c !== void 0 ? _c : e)}) `);
            }
            if (this.config.userProvided)
                return this.trimmer([res.data.data].flat(20));
            const data = res.data.data[this.queryInfo.name];
            // if this is a pageable query if this is defined
            if (this.queryInfo.paging) {
                const nextCursor = data.pageInfo[this.queryInfo.paging.hasNextPage] ? data.edges.at(-1)[this.queryInfo.paging.cursor] : undefined;
                this.queryVars.after = nextCursor;
                return this.trimmer(data.edges.map((v) => v.node));
            }
            return this.trimmer([data].flat(20));
        });
    }
    // tracks & controls output
    trimmer(res) {
        var _a, _b;
        const numPages = ++this.resultTracker.numPages;
        const numResults = (this.resultTracker.numResults += res.length);
        if (res.length === 0) {
            this.resultTracker.done = true;
            return res;
        }
        if (numPages >= ((_a = this === null || this === void 0 ? void 0 : this.config) === null || _a === void 0 ? void 0 : _a.numPages))
            this.resultTracker.done = true;
        if (numResults >= ((_b = this === null || this === void 0 ? void 0 : this.config) === null || _b === void 0 ? void 0 : _b.numResults)) {
            this.resultTracker.done = true;
            const delta = this.config.numResults - (numResults - res.length);
            return res.slice(0, delta);
        }
        return res;
    }
    // return modifier functions
    /**
     * Get the first result from the query
     * @returns the first result from the query - gets at maximum one page
     */
    first() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getPage();
            return (_a = res === null || res === void 0 ? void 0 : res.at(0)) !== null && _a !== void 0 ? _a : undefined;
        });
    }
    /**
     * Limiter on the number of pages a given query should resolve to
     * @param numPages Maximum number of pages to return
     * @returns this (chainable)
     */
    maxPages(numPages) {
        this.config.numPages = numPages;
        // @ts-expect-error types
        return this;
    }
    /**
     * Limiter on the maximum number of results a given query should resolve to
     * @param numResults Maximum number of results to return
     * @returns this (chainable)
     */
    limit(numResults) {
        this.config.numResults = numResults;
        // @ts-expect-error types
        return this;
    }
    // return functions
    /**
     * Gets all results from the built query
     * @returns array of results
     */
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            do {
                const page = yield this.getPage();
                if (!page)
                    break;
                // @ts-expect-error types
                results.push(...page);
            } while (this.queryVars.after);
            return results;
        });
    }
    /**
     * Async generator, yields individual query result items
     */
    generator() {
        return __asyncGenerator(this, arguments, function* generator_1() {
            do {
                const res = yield __await(this.getPage());
                if (!res)
                    return yield __await(void 0);
                // @ts-expect-error constraints
                for (const r of res)
                    yield yield __await(r);
            } while (this.queryVars.after); // getPage sets after to undefined if there are no more pages
        });
    }
    /**
     * Readable stream produced from `this.generator`
     * @returns a readable instance, with the "data" event yielding individual results
     */
    stream() {
        return stream_1.Readable.from(this.generator());
    }
    /**
     * Provide a custom query string to resolve
     * @param query Query string to use
     * @returns result of the query - this method does not support paging or extraction
     */
    query(query) {
        this._query = query;
        this.config.userProvided = true;
        // @ts-expect-error overloading
        return this;
    }
    // TODO issue: this allows for additional (top level only?!) fields that aren't part of TQuery - for now we perform JS level shape checks and throw.
    /**
     * Set the fields you want the query to return
     * @param fields - Object structured like a graphql query body, truthy values including, falsy excluding
     * @param skipFieldCheck - whether to skip JS level fields object shape validation
     * @returns `this` (chainable)
     */
    fields(fields, skipFieldCheck = false) {
        // validate provided fields against default fields
        // default/allowed fields is under `this.queryFields`
        // user selected fields are under `fields`
        // path, allowed, user provided - it's flat so we don't need super precise comparision
        const recursiveValidate = (p, a, b) => {
            for (const k of Object.keys(b)) {
                let ak = a[k];
                if (Array.isArray(ak))
                    ak = ak[0];
                const bk = b[k];
                if (ak === undefined)
                    throw new Error(`Illegal field ${p}${k}`);
                if (typeof bk === "object")
                    recursiveValidate(p + k + ".", ak, bk);
            }
        };
        if (!skipFieldCheck)
            recursiveValidate("", this.queryFields, fields);
        this.queryFields = fields;
        // @ts-expect-error TODO: fix this
        return this;
    }
    /**
     * Sets variables/filters using an object
     * @param variables variable object to set
     * @returns this (chainable)
     */
    variables(variables) {
        this.queryVars = Object.assign(Object.assign({}, this.queryVars), variables);
        // @ts-expect-error - dynamic builder props
        return this;
    }
    /**
     * Builds the current query and returns a ready to POST query string
     * @returns string form of the current query
     */
    toQuery() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.buildQuery();
            return this._query;
        });
    }
    // instance generic type accessors
    /**
     * Dummy method to access the internal `TReturn` generic type
     * @returns "tReturn"
     */
    tReturn() {
        return "tReturn";
    }
    /**
     * Dummy method to access the internal `TQuery` generic type
     * @returns "tQuery"
     */
    tQuery() {
        return "tQuery";
    }
    /**
     * Dummy method to access the internal `TVars` generic type
     * @returns "tVars"
     */
    tVars() {
        return "tVars";
    }
    // Promise contract functions, so users can `await` a GraphQLQuery instance to resolve the built query.
    // very cool, thanks Knex.
    /**
     * Resolves `this` by getting all results for the query (including paging)
     * @param onFulfilled - optional onFulfilled callback
     * @returns - all results for built query
     */
    then(onFulfilled, onRejected) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = this.all();
            return res.then(onFulfilled, onRejected);
        });
    }
    catch(onReject) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.then().catch(onReject);
        });
    }
    finally(onFinally) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.then().finally(onFinally);
        });
    }
}
exports.GraphQLQuery = GraphQLQuery;
// this was definitely not over engineered 👀
//# sourceMappingURL=graphql.js.map