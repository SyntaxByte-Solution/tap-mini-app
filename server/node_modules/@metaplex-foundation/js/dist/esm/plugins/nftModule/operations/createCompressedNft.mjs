import { PROGRAM_ID } from '@metaplex-foundation/mpl-token-metadata';
import { getLeafAssetId, PROGRAM_ID as PROGRAM_ID$1, createMintToCollectionV1Instruction, TokenStandard, TokenProgramVersion } from '@metaplex-foundation/mpl-bubblegum';
import { deserializeChangeLogEventV1, SPL_ACCOUNT_COMPRESSION_PROGRAM_ID, SPL_NOOP_PROGRAM_ID } from '@solana/spl-account-compression';
import { PublicKey } from '@solana/web3.js';
import { BN } from 'bn.js';
import base58 from 'bs58';
import { assertNft } from '../models/Nft.mjs';
import { useOperation, makeConfirmOptionsFinalizedOnMainnet } from '../../../types/Operation.mjs';
import { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';

// -----------------
// Operation
// -----------------

const Key = 'CreateCompressedNftOperation';

/**
 * Creates a new compressed NFT.
 *
 * ```ts
 * const { nft } = await metaplex
 *   .nfts()
 *   .createNft({
 *     name: 'My SFT',
 *     uri: 'https://example.com/my-nft',
 *     sellerFeeBasisPoints: 250, // 2.5%
 *     tree: merkleTreeAccount
 *   };
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const createCompressedNftOperation = useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const createCompressedNftOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const builder = await createCompressedNftBuilder(metaplex, operation.input, scope);
    scope.throwIfCanceled();
    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);
    const output = await builder.sendAndConfirm(metaplex, confirmOptions);
    scope.throwIfCanceled();
    const txInfo = await metaplex.connection.getTransaction(output.response.signature, {
      maxSupportedTransactionVersion: 0
    });
    scope.throwIfCanceled();

    // find the index of the bubblegum instruction
    const relevantIndex = txInfo.transaction.message.compiledInstructions.findIndex(instruction => {
      return txInfo?.transaction.message.staticAccountKeys[instruction.programIdIndex].toBase58() === 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY';
    });

    // locate the no-op inner instructions called via cpi from bubblegum
    const relevantInnerIxs = txInfo.meta?.innerInstructions?.[relevantIndex].instructions.filter(instruction => {
      return txInfo?.transaction.message.staticAccountKeys[instruction.programIdIndex].toBase58() === 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV';
    });

    // when no valid noop instructions are found, throw an error
    if (!relevantInnerIxs || relevantInnerIxs.length == 0) throw Error('Unable to locate valid noop instructions');

    // locate the asset index by attempting to locate and parse the correct `relevantInnerIx`
    let assetIndex = undefined;
    // note: the `assetIndex` is expected to be at position `1`, and normally expect only 2 `relevantInnerIx`
    for (let i = relevantInnerIxs.length - 1; i > 0; i--) {
      try {
        const changeLogEvent = deserializeChangeLogEventV1(Buffer.from(base58.decode(relevantInnerIxs[i]?.data)));

        // extract a successful changelog index
        assetIndex = changeLogEvent?.index;
      } catch (__) {
        // do nothing, invalid data is handled just after the for loop
      }
    }

    // when no `assetIndex` was found, throw an error
    if (typeof assetIndex == 'undefined') throw Error('Unable to locate the newly minted assetId ');
    const assetId = await getLeafAssetId(operation.input.tree, new BN(assetIndex));
    const nft = await metaplex.nfts().findByAssetId({
      assetId
    }, scope);
    scope.throwIfCanceled();
    assertNft(nft);
    return {
      ...output,
      nft,
      /**
       * the assetId is impossible to know before the compressed nft is minted
       * all these addresses are derived from, or are, the `assetId`
       */
      mintAddress: assetId,
      tokenAddress: assetId,
      metadataAddress: nft.metadataAddress,
      masterEditionAddress: nft.edition.address
    };
  }
};

// -----------------
// Builder
// -----------------

/**
 * @group Transaction Builders
 * @category Inputs
 */

/**
 * Creates a new compressed NFT.
 *
 * ```ts
 * const transactionBuilder = await metaplex
 *   .nfts()
 *   .builders()
 *   .createCompressedNft({
 *     name: 'My SFT',
 *     uri: 'https://example.com/my-nft',
 *     sellerFeeBasisPoints: 250, // 2.5%
 *     tree: merkleTreeAccount
 *   });
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */
const createCompressedNftBuilder = async (metaplex, params, options = {}) => {
  const {
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const {
    updateAuthority = metaplex.identity(),
    tree
  } = params;
  const creatorsInput = params.creators ?? [{
    address: updateAuthority.publicKey,
    authority: updateAuthority,
    share: 100
  }];
  const creators = creatorsInput.length > 0 ? creatorsInput.map(creator => ({
    ...creator,
    verified: creator.address.equals(updateAuthority.publicKey)
  })) : null;

  // Likely that this information can only be derived after the mint
  // const verifyAdditionalCreatorInstructions = creatorsInput
  //   .filter((creator) => {
  //     return (
  //       !!creator.authority &&
  //       !creator.address.equals(updateAuthority.publicKey)
  //     );
  //   })
  //   .map((creator) => {
  //     return metaplex.nfts().builders().verifyCreator(
  //       {
  //         mintAddress,
  //         creator: creator.authority,
  //       },
  //       { programs, payer }
  //     );
  //   });

  return TransactionBuilder.make().setFeePayer(payer)

  // Verify additional creators.
  // TODO(jon): Add the creator verification instructions
  // .add(...verifyAdditionalCreatorInstructions)

  // Verify collection.
  .when(!!params.collection && !!params.collectionAuthority, builder => {
    const {
      collection,
      collectionAuthority
    } = params;
    const [collectionMetadataAddress] = PublicKey.findProgramAddressSync([Buffer.from('metadata', 'utf8'), PROGRAM_ID.toBuffer(), collection.toBuffer()], PROGRAM_ID);
    const [collectionMasterEditionAccount] = PublicKey.findProgramAddressSync([Buffer.from('metadata', 'utf8'), PROGRAM_ID.toBuffer(), collection.toBuffer(), Buffer.from('edition', 'utf8')], PROGRAM_ID);
    const [treeAuthority] = PublicKey.findProgramAddressSync([tree.toBuffer()], PROGRAM_ID$1);
    const [bubblegumPDA] = PublicKey.findProgramAddressSync([Buffer.from('collection_cpi', 'utf8')], PROGRAM_ID$1);
    return builder.add({
      instruction:
      // TODO(jon): We should be able to infer some of these in an intermediary SDK
      createMintToCollectionV1Instruction({
        payer: payer.publicKey,
        merkleTree: tree,
        treeAuthority,
        // TODO(jon): Replace this delegate
        treeDelegate: payer.publicKey,
        // TODO(jon): This should respect the configured owner
        leafOwner: payer.publicKey,
        leafDelegate: payer.publicKey,
        collectionMetadata: collectionMetadataAddress,
        collectionMint: collection,
        collectionAuthority: collectionAuthority.publicKey,
        // TODO(jon): This should be `collectionMasterEditionAccount`
        editionAccount: collectionMasterEditionAccount,
        // TODO(jon): Pass along another parameter for this field and default to the BUBBLEGUM_PROGRAM_ID
        collectionAuthorityRecordPda: PROGRAM_ID$1,
        bubblegumSigner: bubblegumPDA,
        // Programs
        /* Account Compression */
        compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
        // TODO(jon): This argument should be `logWrapperProgram`
        logWrapper: SPL_NOOP_PROGRAM_ID,
        /* Bubblegum */
        tokenMetadataProgram: PROGRAM_ID
      }, {
        metadataArgs: {
          ...params,
          symbol: params.symbol ?? '',
          creators: creators ?? [],
          isMutable: !!params.isMutable,
          uses: params.uses ?? null,
          // Only NonFungible tokens are supported.
          tokenStandard: TokenStandard.NonFungible,
          collection: {
            key: collection,
            // TODO(jon): Can we verify this here or do we need to send a separate instruction?
            verified: false
          },
          primarySaleHappened: false,
          editionNonce: null,
          tokenProgramVersion: TokenProgramVersion.Original
        }
      }),
      signers: [payer, params.collectionAuthority]
    });
  });
};

export { createCompressedNftBuilder, createCompressedNftOperation, createCompressedNftOperationHandler };
//# sourceMappingURL=createCompressedNft.mjs.map
