{"version":3,"file":"unwrapOptionRecursively.cjs","sources":["../../src/unwrapOptionRecursively.ts"],"sourcesContent":["import { None, Some, isOption, isSome } from './common';\n\n/**\n * A type that defines the recursive unwrapping of a type `T`\n * such that all nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns the type of its value, otherwise, it returns the provided\n * fallback type `U` which defaults to `null`.\n *\n * @category Utils — Options\n */\nexport type UnwrappedOption<T, U = null> = T extends Some<infer TValue>\n  ? UnwrappedOption<TValue, U>\n  : T extends None\n  ? U\n  : T extends\n      | string\n      | number\n      | boolean\n      | symbol\n      | bigint\n      | undefined\n      | null\n      | Uint8Array\n      | Date\n  ? T\n  : T extends object\n  ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n  : T extends Array<infer TItem>\n  ? Array<UnwrappedOption<TItem, U>>\n  : T;\n\n/**\n * Recursively go through a type `T`such that all\n * nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns its value, otherwise, it returns the provided fallback value\n * which defaults to `null`.\n *\n * @category Utils — Options\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(\n  input: T,\n  fallback: () => U\n): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(\n  input: T,\n  fallback?: () => U\n): UnwrappedOption<T, U> {\n  // Types to bypass.\n  if (!input || ArrayBuffer.isView(input)) {\n    return input as UnwrappedOption<T, U>;\n  }\n\n  const next = <X>(x: X) =>\n    (fallback\n      ? unwrapOptionRecursively(x, fallback)\n      : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n  // Handle Option.\n  if (isOption(input)) {\n    if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n    return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n  }\n\n  // Walk.\n  if (Array.isArray(input)) {\n    return input.map(next) as UnwrappedOption<T, U>;\n  }\n  if (typeof input === 'object') {\n    return Object.fromEntries(\n      Object.entries(input).map(([k, v]) => [k, next(v)])\n    ) as UnwrappedOption<T, U>;\n  }\n  return input as UnwrappedOption<T, U>;\n}\n"],"names":["unwrapOptionRecursively","input","fallback","ArrayBuffer","isView","next","x","isOption","isSome","value","Array","isArray","map","Object","fromEntries","entries","k","v"],"mappings":";;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAqCO,SAASA,uBAAuB,CACrCC,KAAQ,EACRC,QAAkB,EACK;AACvB;EACA,IAAI,CAACD,KAAK,IAAIE,WAAW,CAACC,MAAM,CAACH,KAAK,CAAC,EAAE;AACvC,IAAA,OAAOA,KAAK,CAAA;AACd,GAAA;AAEA,EAAA,MAAMI,IAAI,GAAOC,CAAI,IAClBJ,QAAQ,GACLF,uBAAuB,CAACM,CAAC,EAAEJ,QAAQ,CAAC,GACpCF,uBAAuB,CAACM,CAAC,CAA2B,CAAA;;AAE1D;AACA,EAAA,IAAIC,eAAQ,CAACN,KAAK,CAAC,EAAE;IACnB,IAAIO,aAAM,CAACP,KAAK,CAAC,EAAE,OAAOI,IAAI,CAACJ,KAAK,CAACQ,KAAK,CAAC,CAAA;AAC3C,IAAA,OAAQP,QAAQ,GAAGA,QAAQ,EAAE,GAAG,IAAI,CAAA;AACtC,GAAA;;AAEA;AACA,EAAA,IAAIQ,KAAK,CAACC,OAAO,CAACV,KAAK,CAAC,EAAE;AACxB,IAAA,OAAOA,KAAK,CAACW,GAAG,CAACP,IAAI,CAAC,CAAA;AACxB,GAAA;AACA,EAAA,IAAI,OAAOJ,KAAK,KAAK,QAAQ,EAAE;AAC7B,IAAA,OAAOY,MAAM,CAACC,WAAW,CACvBD,MAAM,CAACE,OAAO,CAACd,KAAK,CAAC,CAACW,GAAG,CAAC,CAAC,CAACI,CAAC,EAAEC,CAAC,CAAC,KAAK,CAACD,CAAC,EAAEX,IAAI,CAACY,CAAC,CAAC,CAAC,CAAC,CACpD,CAAA;AACH,GAAA;AACA,EAAA,OAAOhB,KAAK,CAAA;AACd;;;;"}