"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("@near-js/crypto");
const providers_1 = require("@near-js/providers");
const borsh_1 = require("borsh");
const arbundles_1 = require("arbundles");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const token_1 = require("../token");
const bs58_1 = __importDefault(require("bs58"));
const bn_js_1 = __importDefault(require("bn.js"));
const js_sha256_1 = require("js-sha256");
const transactions_1 = require("@near-js/transactions");
const near_seed_phrase_1 = require("near-seed-phrase");
const base64url_1 = __importDefault(require("base64url"));
const axios_1 = __importDefault(require("axios"));
class NearConfig extends token_1.BaseNodeToken {
    constructor(config) {
        var _a;
        let wallet = config.wallet;
        if (typeof wallet === "string" && ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.split(":")) === null || _a === void 0 ? void 0 : _a[0]) !== "ed25519") {
            wallet = (0, near_seed_phrase_1.parseSeedPhrase)(wallet, near_seed_phrase_1.KEY_DERIVATION_PATH).secretKey;
        }
        config.wallet = wallet;
        super(config);
        this.base = ["yoctoNEAR", 1e24];
        this.keyPair = crypto_1.KeyPair.fromString(this.wallet);
    }
    getProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.providerInstance) {
                this.providerInstance = new providers_1.JsonRpcProvider({ url: this.providerUrl });
            }
            return this.providerInstance;
        });
    }
    /**
     * NEAR wants both the sender ID and tx Hash, so we have to concatenate to keep with the interface.
     * @param txId assumes format senderID:txHash
     */
    getTx(txId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // NOTE: their type defs are out of date with their actual API (23-01-2022)... beware the expect-error when debugging!
            const provider = yield this.getProvider();
            const [id, hash] = txId.split(":");
            const status = yield provider.txStatusReceipts(bs58_1.default.decode(hash), id);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            const blockHeight = yield provider.block(status.transaction_outcome.block_hash);
            const latestBlockHeight = (yield provider.block({ finality: "final" })).header.height;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            if (status.receipts_outcome[0].outcome.status.SuccessValue !== "") {
                throw new Error("Transaction failed!");
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            const deposit = (_a = status.receipts[0].receipt.Action.actions[0].Transfer.deposit) !== null && _a !== void 0 ? _a : 0;
            return {
                from: id,
                to: status.transaction.receiver_id,
                amount: new bignumber_js_1.default(deposit),
                blockHeight: new bignumber_js_1.default(blockHeight.header.height),
                pending: false,
                confirmed: latestBlockHeight - blockHeight.header.height >= this.minConfirm,
            };
        });
    }
    /**
     * address = accountID
     * @param owner // assumed to be the "ed25519:" header + b58 encoded key
     */
    ownerToAddress(owner) {
        return Buffer.from(typeof owner === "string" ? bs58_1.default.decode(owner.replace("ed25519:", "")) : bs58_1.default.decode(bs58_1.default.encode(owner))).toString("hex");
    }
    sign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getSigner().sign(data);
        });
    }
    getSigner() {
        return new arbundles_1.NearSigner(this.wallet);
    }
    verify(pub, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return arbundles_1.NearSigner.verify(pub, data, signature);
        });
    }
    getCurrentHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const res = yield provider.status();
            return new bignumber_js_1.default(res.sync_info.latest_block_height);
        });
    }
    /**
     * NOTE: assumes only operation is transfer
     * @param _amount
     * @param _to
     * @returns
     */
    getFee(_amount, _to) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: use https://docs.near.org/docs/concepts/gas and https://docs.near.org/docs/api/rpc/protocol#genesis-config
            // to derive cost from genesis config to generalise support.
            const provider = yield this.getProvider();
            const res = yield provider.gasPrice(null); // null == gas price as of latest block
            // multiply by action cost in gas units (assume only action is transfer)
            // 4.5x10^11 gas units for fund transfers
            return new bignumber_js_1.default(res.gas_price).multipliedBy(450000000000);
        });
    }
    sendTx(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            // // hack to fix near SDK issue
            // we manually encode as due to a lack of node_module flattening, two classes (who are otherwise identical)
            // are imported from two different locations, meaning JS's equivalency is broken (not the same internal object)
            // this bypasses this issue by ensuring the class is imported from the "flat" version
            // const res = await provider.sendTransaction(data);
            const expectedSignedTransactionClass = [...transactions_1.SCHEMA.keys()].find((c) => c.name === "SignedTransaction");
            data.constructor = expectedSignedTransactionClass;
            const encodedTransaction = (0, transactions_1.encodeTransaction)(data);
            const res = (yield provider.sendJsonRpc("broadcast_tx_commit", [Buffer.from(encodedTransaction).toString("base64")]));
            return `${this.address}:${res.transaction.hash}`; // encode into compound format
        });
    }
    createTx(amount, to, _fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const accessKey = yield provider.query({
                request_type: "view_access_key",
                finality: "final",
                account_id: this.address,
                public_key: this.keyPair.getPublicKey().toString(),
            });
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            const nonce = ++accessKey.nonce;
            const recentBlockHash = Buffer.from(bs58_1.default.decode(accessKey.block_hash));
            const actions = [transactions_1.actionCreators.transfer(new bn_js_1.default(new bignumber_js_1.default(amount).toFixed().toString()))];
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            const tx = (0, transactions_1.createTransaction)(this.address, this.keyPair.getPublicKey(), to, nonce, actions, recentBlockHash);
            // hack to fix near SDK issue
            const expectedPublicKeyClass = [...transactions_1.SCHEMA.keys()].find((c) => c.name === "PublicKey");
            tx.publicKey.constructor = expectedPublicKeyClass;
            const serialTx = (0, borsh_1.serialize)(transactions_1.SCHEMA, tx);
            const serialTxHash = new Uint8Array(js_sha256_1.sha256.array(serialTx));
            const signature = this.keyPair.sign(serialTxHash);
            const signedTx = new transactions_1.SignedTransaction({
                transaction: tx,
                signature: new transactions_1.Signature({
                    keyType: tx.publicKey.keyType,
                    data: signature.signature,
                }),
            });
            return { tx: signedTx, txId: undefined };
        });
    }
    getPublicKey() {
        this.keyPair = crypto_1.KeyPair.fromString(this.wallet);
        return Buffer.from(this.keyPair.getPublicKey().data);
    }
    ready() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // resolve loaded pubkey to parent address
                const pubkey = this.keyPair.getPublicKey().toString();
                const resolved = (yield axios_1.default.get(`${this.IrysUrl}account/near/lookup?address=${base64url_1.default.encode(pubkey.split(":")[1])}`).catch((e) => {
                    return e;
                }));
                this._address = (_b = (_a = resolved === null || resolved === void 0 ? void 0 : resolved.data) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : this._address;
            }
            catch (e) {
                console.error(e);
            }
        });
    }
}
exports.default = NearConfig;
//# sourceMappingURL=near.js.map