"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReservationAlreadyMadeError = exports.ReservationNotSetError = exports.ReservationDoesNotExistError = exports.ReservationExistsError = exports.ShareTotalMustBe100Error = exports.NoBalanceInAccountForAuthorizationError = exports.OwnerMismatchError = exports.PrimarySaleCanOnlyBeFlippedToTrueError = exports.InvalidBasisPointsError = exports.CreatorNotFoundError = exports.NoCreatorsPresentOnMetadataError = exports.MustBeOneOfCreatorsError = exports.CreatorsMustBeAtleastOneError = exports.CreatorsTooLongError = exports.DisabledError = exports.AuthorizationTokenAccountOwnerMismatchError = exports.PrintingMintAuthorizationAccountMismatchError = exports.NotEnoughTokensError = exports.TokenAccountMintMismatchV2Error = exports.TokenAccountMintMismatchError = exports.OneTimePrintingAuthMintMismatchError = exports.PrintingMintMismatchError = exports.DerivedKeyInvalidError = exports.TokenAccountOneTimeAuthMintMismatchError = exports.TokenBurnFailedError = exports.EditionMintDecimalsShouldBeZeroError = exports.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = exports.PrintingMintDecimalsShouldBeZeroError = exports.EditionAlreadyMintedError = exports.DestinationMintMismatchError = exports.MasterRecordMismatchError = exports.TokenMintToFailedError = exports.MaxEditionsMintedAlreadyError = exports.EditionsMustHaveExactlyOneTokenError = exports.MintMismatchError = exports.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = exports.UriTooLongError = exports.SymbolTooLongError = exports.NameTooLongError = exports.InvalidMintAuthorityError = exports.NotMintAuthorityError = exports.UpdateAuthorityIsNotSignerError = exports.UpdateAuthorityIncorrectError = exports.InvalidEditionKeyError = exports.InvalidMetadataKeyError = exports.UninitializedError = exports.AlreadyInitializedError = exports.NotRentExemptError = exports.InstructionPackErrorError = exports.InstructionUnpackErrorError = void 0;
exports.RevokeCollectionAuthoritySignerIncorrectError = exports.InvalidUserError = exports.EditionOverrideCannotBeZeroError = exports.NotAllowedToChangeSellerFeeBasisPointsError = exports.CannotWipeVerifiedCreatorsError = exports.CannotRemoveVerifiedCreatorError = exports.CannotAdjustVerifiedCreatorError = exports.InvalidDelegateError = exports.InvalidFreezeAuthorityError = exports.InvalidCollectionAuthorityRecordError = exports.InvalidUseAuthorityRecordError = exports.CollectionAuthorityDoesNotExistError = exports.CollectionAuthorityRecordAlreadyExistsError = exports.NotEnoughUsesError = exports.UnusableError = exports.UseAuthorityRecordAlreadyRevokedError = exports.UseAuthorityRecordAlreadyExistsError = exports.CollectionMustBeAUniqueMasterEditionError = exports.InvalidCollectionUpdateAuthorityError = exports.CollectionNotFoundError = exports.CannotChangeUsesAfterFirstUseError = exports.CannotChangeUseMethodAfterFirstUseError = exports.InvalidUseMethodError = exports.MustBeBurnedError = exports.RemovedError = exports.CollectionCannotBeVerifiedInThisInstructionError = exports.IsMutableCanOnlyBeFlippedToFalseError = exports.ReservationArrayShouldBeSizeOneError = exports.InvalidEditionIndexError = exports.OneTimeAuthMintSupplyMustBeZeroForConversionError = exports.PrintingMintSupplyMustBeZeroForConversionError = exports.InvalidOwnerError = exports.InvalidOperationError = exports.TriedToReplaceAnExistingReservationError = exports.ReservationNotCompleteError = exports.BeyondAlottedAddressSizeError = exports.DataTypeMismatchError = exports.InvalidTokenProgramError = exports.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = exports.DuplicateCreatorAddressError = exports.DataIsImmutableError = exports.PrintingWouldBreachMaximumSupplyError = exports.IncorrectOwnerError = exports.SpotMismatchError = exports.CannotUnverifyAnotherCreatorError = exports.CannotVerifyAnotherCreatorError = exports.AddressNotInReservationError = exports.ReservationBreachesMaximumSupplyError = exports.NumericalOverflowErrorError = exports.BeyondMaxAddressSizeError = void 0;
exports.MissingSplTokenProgramError = exports.MissingTokenAccountError = exports.OnlySaleDelegateCanTransferError = exports.InvalidSystemWalletError = exports.FeatureNotSupportedError = exports.MissingArgumentInBuilderError = exports.MissingAccountInBuilderError = exports.DelegateNotFoundError = exports.DelegateAlreadyExistsError = exports.InvalidProgrammableConfigError = exports.MissingProgrammableConfigError = exports.MissingAuthorizationRulesError = exports.InvalidAuthorizationRulesError = exports.InvalidMintForTokenStandardError = exports.InvalidTokenStandardError = exports.MintIsNotSignerError = exports.EscrowParentHasDelegateError = exports.InvalidBubblegumSignerError = exports.InvalidCollectionSizeChangeError = exports.NoFreezeAuthoritySetError = exports.BorshSerializationErrorError = exports.InsufficientTokensError = exports.MustBeNonFungibleError = exports.InvalidSystemProgramError = exports.MustBeEscrowAuthorityError = exports.InvalidEscrowBumpSeedError = exports.MustUnverifyError = exports.EditionNumberGreaterThanMaxSupplyError = exports.PrintEditionDoesNotMatchMasterEditionError = exports.ReservationListDeprecatedError = exports.InvalidEditionMarkerError = exports.InvalidPrintEditionError = exports.InvalidMasterEditionError = exports.NotAPrintEditionError = exports.AlreadyUnverifiedError = exports.AlreadyVerifiedError = exports.CollectionMasterEditionAccountInvalidError = exports.CannotUpdateVerifiedCollectionError = exports.BorshDeserializationErrorError = exports.MasterEditionHasPrintsError = exports.NotAMasterEditionError = exports.MissingEditionAccountError = exports.CouldNotDetermineTokenStandardError = exports.NotACollectionParentError = exports.NotVerifiedMemberOfCollectionError = exports.NotAMemberOfCollectionError = exports.MissingCollectionMetadataError = exports.SizedCollectionError = exports.UnsizedCollectionError = exports.TokenCloseFailedError = void 0;
exports.getMplTokenMetadataErrorFromCode = exports.MissingImmutableOwnerExtensionError = exports.InvalidTokenExtensionTypeError = exports.InvalidMetadataPointerError = exports.InvalidMintCloseAuthorityError = exports.InvalidMintExtensionTypeError = exports.CannotChangeUpdateAuthorityWithDelegateError = exports.InvalidMetadataFlagsError = exports.InvalidFeeAccountError = exports.MissingDelegateRecordError = exports.InvalidInstructionError = exports.InvalidCloseAuthorityError = exports.InvalidTokenRecordError = exports.MissingCollectionMasterEditionError = exports.MissingCollectionMintError = exports.InsufficientTokenBalanceError = exports.InvalidUpdateArgsError = exports.InvalidParentAccountsError = exports.InvalidInstructionsSysvarError = exports.InvalidAssociatedTokenAccountProgramError = exports.MissingEditionError = exports.CannotBurnWithDelegateError = exports.MissingEditionMarkerAccountError = exports.MissingMasterEditionTokenAccountError = exports.MissingMasterEditionMintAccountError = exports.InvalidAmountError = exports.CannotUpdateAssetWithDelegateError = exports.DataIncrementLimitExceededError = exports.InvalidLockedTransferAddressError = exports.MissingLockedTransferAddressError = exports.InvalidDelegateArgsError = exports.AmountMustBeGreaterThanZeroError = exports.MissingMasterEditionAccountError = exports.MissingPrintSupplyError = exports.InvalidDelegateRoleError = exports.IncorrectTokenStateError = exports.InvalidMasterEditionAccountLengthError = exports.MissingTokenOwnerAccountError = exports.DataIsEmptyOrZeroedError = exports.MintSupplyMustBeZeroError = exports.MissingTokenRecordError = exports.InvalidAuthorityTypeError = exports.MissingDelegateRoleError = exports.UnlockedTokenError = exports.LockedTokenError = exports.KeyMismatchError = exports.InstructionNotSupportedError = exports.InvalidTransferAuthorityError = exports.InvalidDelegateRoleForTransferError = exports.MissingAuthorizationRulesProgramError = void 0;
exports.getMplTokenMetadataErrorFromName = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** InstructionUnpackError */
class InstructionUnpackErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InstructionUnpackError';
        this.code = 0x0; // 0
    }
}
exports.InstructionUnpackErrorError = InstructionUnpackErrorError;
codeToErrorMap.set(0x0, InstructionUnpackErrorError);
nameToErrorMap.set('InstructionUnpackError', InstructionUnpackErrorError);
/** InstructionPackError */
class InstructionPackErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InstructionPackError';
        this.code = 0x1; // 1
    }
}
exports.InstructionPackErrorError = InstructionPackErrorError;
codeToErrorMap.set(0x1, InstructionPackErrorError);
nameToErrorMap.set('InstructionPackError', InstructionPackErrorError);
/** NotRentExempt: Lamport balance below rent-exempt threshold */
class NotRentExemptError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Lamport balance below rent-exempt threshold', program, cause);
        this.name = 'NotRentExempt';
        this.code = 0x2; // 2
    }
}
exports.NotRentExemptError = NotRentExemptError;
codeToErrorMap.set(0x2, NotRentExemptError);
nameToErrorMap.set('NotRentExempt', NotRentExemptError);
/** AlreadyInitialized: Already initialized */
class AlreadyInitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Already initialized', program, cause);
        this.name = 'AlreadyInitialized';
        this.code = 0x3; // 3
    }
}
exports.AlreadyInitializedError = AlreadyInitializedError;
codeToErrorMap.set(0x3, AlreadyInitializedError);
nameToErrorMap.set('AlreadyInitialized', AlreadyInitializedError);
/** Uninitialized: Uninitialized */
class UninitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Uninitialized', program, cause);
        this.name = 'Uninitialized';
        this.code = 0x4; // 4
    }
}
exports.UninitializedError = UninitializedError;
codeToErrorMap.set(0x4, UninitializedError);
nameToErrorMap.set('Uninitialized', UninitializedError);
/** InvalidMetadataKey:  Metadata's key must match seed of ['metadata', program id, mint] provided */
class InvalidMetadataKeyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super(" Metadata's key must match seed of ['metadata', program id, mint] provided", program, cause);
        this.name = 'InvalidMetadataKey';
        this.code = 0x5; // 5
    }
}
exports.InvalidMetadataKeyError = InvalidMetadataKeyError;
codeToErrorMap.set(0x5, InvalidMetadataKeyError);
nameToErrorMap.set('InvalidMetadataKey', InvalidMetadataKeyError);
/** InvalidEditionKey: Edition's key must match seed of ['metadata', program id, name, 'edition'] provided */
class InvalidEditionKeyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided", program, cause);
        this.name = 'InvalidEditionKey';
        this.code = 0x6; // 6
    }
}
exports.InvalidEditionKeyError = InvalidEditionKeyError;
codeToErrorMap.set(0x6, InvalidEditionKeyError);
nameToErrorMap.set('InvalidEditionKey', InvalidEditionKeyError);
/** UpdateAuthorityIncorrect: Update Authority given does not match */
class UpdateAuthorityIncorrectError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Update Authority given does not match', program, cause);
        this.name = 'UpdateAuthorityIncorrect';
        this.code = 0x7; // 7
    }
}
exports.UpdateAuthorityIncorrectError = UpdateAuthorityIncorrectError;
codeToErrorMap.set(0x7, UpdateAuthorityIncorrectError);
nameToErrorMap.set('UpdateAuthorityIncorrect', UpdateAuthorityIncorrectError);
/** UpdateAuthorityIsNotSigner: Update Authority needs to be signer to update metadata */
class UpdateAuthorityIsNotSignerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Update Authority needs to be signer to update metadata', program, cause);
        this.name = 'UpdateAuthorityIsNotSigner';
        this.code = 0x8; // 8
    }
}
exports.UpdateAuthorityIsNotSignerError = UpdateAuthorityIsNotSignerError;
codeToErrorMap.set(0x8, UpdateAuthorityIsNotSignerError);
nameToErrorMap.set('UpdateAuthorityIsNotSigner', UpdateAuthorityIsNotSignerError);
/** NotMintAuthority: You must be the mint authority and signer on this transaction */
class NotMintAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('You must be the mint authority and signer on this transaction', program, cause);
        this.name = 'NotMintAuthority';
        this.code = 0x9; // 9
    }
}
exports.NotMintAuthorityError = NotMintAuthorityError;
codeToErrorMap.set(0x9, NotMintAuthorityError);
nameToErrorMap.set('NotMintAuthority', NotMintAuthorityError);
/** InvalidMintAuthority: Mint authority provided does not match the authority on the mint */
class InvalidMintAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Mint authority provided does not match the authority on the mint', program, cause);
        this.name = 'InvalidMintAuthority';
        this.code = 0xa; // 10
    }
}
exports.InvalidMintAuthorityError = InvalidMintAuthorityError;
codeToErrorMap.set(0xa, InvalidMintAuthorityError);
nameToErrorMap.set('InvalidMintAuthority', InvalidMintAuthorityError);
/** NameTooLong: Name too long */
class NameTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Name too long', program, cause);
        this.name = 'NameTooLong';
        this.code = 0xb; // 11
    }
}
exports.NameTooLongError = NameTooLongError;
codeToErrorMap.set(0xb, NameTooLongError);
nameToErrorMap.set('NameTooLong', NameTooLongError);
/** SymbolTooLong: Symbol too long */
class SymbolTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Symbol too long', program, cause);
        this.name = 'SymbolTooLong';
        this.code = 0xc; // 12
    }
}
exports.SymbolTooLongError = SymbolTooLongError;
codeToErrorMap.set(0xc, SymbolTooLongError);
nameToErrorMap.set('SymbolTooLong', SymbolTooLongError);
/** UriTooLong: URI too long */
class UriTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('URI too long', program, cause);
        this.name = 'UriTooLong';
        this.code = 0xd; // 13
    }
}
exports.UriTooLongError = UriTooLongError;
codeToErrorMap.set(0xd, UriTooLongError);
nameToErrorMap.set('UriTooLong', UriTooLongError);
/** UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner */
class UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner';
        this.code = 0xe; // 14
    }
}
exports.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError;
codeToErrorMap.set(0xe, UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError);
nameToErrorMap.set('UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner', UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError);
/** MintMismatch: Mint given does not match mint on Metadata */
class MintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Mint given does not match mint on Metadata', program, cause);
        this.name = 'MintMismatch';
        this.code = 0xf; // 15
    }
}
exports.MintMismatchError = MintMismatchError;
codeToErrorMap.set(0xf, MintMismatchError);
nameToErrorMap.set('MintMismatch', MintMismatchError);
/** EditionsMustHaveExactlyOneToken: Editions must have exactly one token */
class EditionsMustHaveExactlyOneTokenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Editions must have exactly one token', program, cause);
        this.name = 'EditionsMustHaveExactlyOneToken';
        this.code = 0x10; // 16
    }
}
exports.EditionsMustHaveExactlyOneTokenError = EditionsMustHaveExactlyOneTokenError;
codeToErrorMap.set(0x10, EditionsMustHaveExactlyOneTokenError);
nameToErrorMap.set('EditionsMustHaveExactlyOneToken', EditionsMustHaveExactlyOneTokenError);
/** MaxEditionsMintedAlready */
class MaxEditionsMintedAlreadyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'MaxEditionsMintedAlready';
        this.code = 0x11; // 17
    }
}
exports.MaxEditionsMintedAlreadyError = MaxEditionsMintedAlreadyError;
codeToErrorMap.set(0x11, MaxEditionsMintedAlreadyError);
nameToErrorMap.set('MaxEditionsMintedAlready', MaxEditionsMintedAlreadyError);
/** TokenMintToFailed */
class TokenMintToFailedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'TokenMintToFailed';
        this.code = 0x12; // 18
    }
}
exports.TokenMintToFailedError = TokenMintToFailedError;
codeToErrorMap.set(0x12, TokenMintToFailedError);
nameToErrorMap.set('TokenMintToFailed', TokenMintToFailedError);
/** MasterRecordMismatch */
class MasterRecordMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'MasterRecordMismatch';
        this.code = 0x13; // 19
    }
}
exports.MasterRecordMismatchError = MasterRecordMismatchError;
codeToErrorMap.set(0x13, MasterRecordMismatchError);
nameToErrorMap.set('MasterRecordMismatch', MasterRecordMismatchError);
/** DestinationMintMismatch */
class DestinationMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'DestinationMintMismatch';
        this.code = 0x14; // 20
    }
}
exports.DestinationMintMismatchError = DestinationMintMismatchError;
codeToErrorMap.set(0x14, DestinationMintMismatchError);
nameToErrorMap.set('DestinationMintMismatch', DestinationMintMismatchError);
/** EditionAlreadyMinted */
class EditionAlreadyMintedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'EditionAlreadyMinted';
        this.code = 0x15; // 21
    }
}
exports.EditionAlreadyMintedError = EditionAlreadyMintedError;
codeToErrorMap.set(0x15, EditionAlreadyMintedError);
nameToErrorMap.set('EditionAlreadyMinted', EditionAlreadyMintedError);
/** PrintingMintDecimalsShouldBeZero */
class PrintingMintDecimalsShouldBeZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'PrintingMintDecimalsShouldBeZero';
        this.code = 0x16; // 22
    }
}
exports.PrintingMintDecimalsShouldBeZeroError = PrintingMintDecimalsShouldBeZeroError;
codeToErrorMap.set(0x16, PrintingMintDecimalsShouldBeZeroError);
nameToErrorMap.set('PrintingMintDecimalsShouldBeZero', PrintingMintDecimalsShouldBeZeroError);
/** OneTimePrintingAuthorizationMintDecimalsShouldBeZero */
class OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'OneTimePrintingAuthorizationMintDecimalsShouldBeZero';
        this.code = 0x17; // 23
    }
}
exports.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError;
codeToErrorMap.set(0x17, OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError);
nameToErrorMap.set('OneTimePrintingAuthorizationMintDecimalsShouldBeZero', OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError);
/** EditionMintDecimalsShouldBeZero: EditionMintDecimalsShouldBeZero */
class EditionMintDecimalsShouldBeZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('EditionMintDecimalsShouldBeZero', program, cause);
        this.name = 'EditionMintDecimalsShouldBeZero';
        this.code = 0x18; // 24
    }
}
exports.EditionMintDecimalsShouldBeZeroError = EditionMintDecimalsShouldBeZeroError;
codeToErrorMap.set(0x18, EditionMintDecimalsShouldBeZeroError);
nameToErrorMap.set('EditionMintDecimalsShouldBeZero', EditionMintDecimalsShouldBeZeroError);
/** TokenBurnFailed */
class TokenBurnFailedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'TokenBurnFailed';
        this.code = 0x19; // 25
    }
}
exports.TokenBurnFailedError = TokenBurnFailedError;
codeToErrorMap.set(0x19, TokenBurnFailedError);
nameToErrorMap.set('TokenBurnFailed', TokenBurnFailedError);
/** TokenAccountOneTimeAuthMintMismatch */
class TokenAccountOneTimeAuthMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'TokenAccountOneTimeAuthMintMismatch';
        this.code = 0x1a; // 26
    }
}
exports.TokenAccountOneTimeAuthMintMismatchError = TokenAccountOneTimeAuthMintMismatchError;
codeToErrorMap.set(0x1a, TokenAccountOneTimeAuthMintMismatchError);
nameToErrorMap.set('TokenAccountOneTimeAuthMintMismatch', TokenAccountOneTimeAuthMintMismatchError);
/** DerivedKeyInvalid: Derived key invalid */
class DerivedKeyInvalidError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Derived key invalid', program, cause);
        this.name = 'DerivedKeyInvalid';
        this.code = 0x1b; // 27
    }
}
exports.DerivedKeyInvalidError = DerivedKeyInvalidError;
codeToErrorMap.set(0x1b, DerivedKeyInvalidError);
nameToErrorMap.set('DerivedKeyInvalid', DerivedKeyInvalidError);
/** PrintingMintMismatch: The Printing mint does not match that on the master edition! */
class PrintingMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The Printing mint does not match that on the master edition!', program, cause);
        this.name = 'PrintingMintMismatch';
        this.code = 0x1c; // 28
    }
}
exports.PrintingMintMismatchError = PrintingMintMismatchError;
codeToErrorMap.set(0x1c, PrintingMintMismatchError);
nameToErrorMap.set('PrintingMintMismatch', PrintingMintMismatchError);
/** OneTimePrintingAuthMintMismatch: The One Time Printing Auth mint does not match that on the master edition! */
class OneTimePrintingAuthMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The One Time Printing Auth mint does not match that on the master edition!', program, cause);
        this.name = 'OneTimePrintingAuthMintMismatch';
        this.code = 0x1d; // 29
    }
}
exports.OneTimePrintingAuthMintMismatchError = OneTimePrintingAuthMintMismatchError;
codeToErrorMap.set(0x1d, OneTimePrintingAuthMintMismatchError);
nameToErrorMap.set('OneTimePrintingAuthMintMismatch', OneTimePrintingAuthMintMismatchError);
/** TokenAccountMintMismatch: The mint of the token account does not match the Printing mint! */
class TokenAccountMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The mint of the token account does not match the Printing mint!', program, cause);
        this.name = 'TokenAccountMintMismatch';
        this.code = 0x1e; // 30
    }
}
exports.TokenAccountMintMismatchError = TokenAccountMintMismatchError;
codeToErrorMap.set(0x1e, TokenAccountMintMismatchError);
nameToErrorMap.set('TokenAccountMintMismatch', TokenAccountMintMismatchError);
/** TokenAccountMintMismatchV2: The mint of the token account does not match the master metadata mint! */
class TokenAccountMintMismatchV2Error extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The mint of the token account does not match the master metadata mint!', program, cause);
        this.name = 'TokenAccountMintMismatchV2';
        this.code = 0x1f; // 31
    }
}
exports.TokenAccountMintMismatchV2Error = TokenAccountMintMismatchV2Error;
codeToErrorMap.set(0x1f, TokenAccountMintMismatchV2Error);
nameToErrorMap.set('TokenAccountMintMismatchV2', TokenAccountMintMismatchV2Error);
/** NotEnoughTokens: Not enough tokens to mint a limited edition */
class NotEnoughTokensError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not enough tokens to mint a limited edition', program, cause);
        this.name = 'NotEnoughTokens';
        this.code = 0x20; // 32
    }
}
exports.NotEnoughTokensError = NotEnoughTokensError;
codeToErrorMap.set(0x20, NotEnoughTokensError);
nameToErrorMap.set('NotEnoughTokens', NotEnoughTokensError);
/** PrintingMintAuthorizationAccountMismatch */
class PrintingMintAuthorizationAccountMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'PrintingMintAuthorizationAccountMismatch';
        this.code = 0x21; // 33
    }
}
exports.PrintingMintAuthorizationAccountMismatchError = PrintingMintAuthorizationAccountMismatchError;
codeToErrorMap.set(0x21, PrintingMintAuthorizationAccountMismatchError);
nameToErrorMap.set('PrintingMintAuthorizationAccountMismatch', PrintingMintAuthorizationAccountMismatchError);
/** AuthorizationTokenAccountOwnerMismatch */
class AuthorizationTokenAccountOwnerMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'AuthorizationTokenAccountOwnerMismatch';
        this.code = 0x22; // 34
    }
}
exports.AuthorizationTokenAccountOwnerMismatchError = AuthorizationTokenAccountOwnerMismatchError;
codeToErrorMap.set(0x22, AuthorizationTokenAccountOwnerMismatchError);
nameToErrorMap.set('AuthorizationTokenAccountOwnerMismatch', AuthorizationTokenAccountOwnerMismatchError);
/** Disabled */
class DisabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'Disabled';
        this.code = 0x23; // 35
    }
}
exports.DisabledError = DisabledError;
codeToErrorMap.set(0x23, DisabledError);
nameToErrorMap.set('Disabled', DisabledError);
/** CreatorsTooLong: Creators list too long */
class CreatorsTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creators list too long', program, cause);
        this.name = 'CreatorsTooLong';
        this.code = 0x24; // 36
    }
}
exports.CreatorsTooLongError = CreatorsTooLongError;
codeToErrorMap.set(0x24, CreatorsTooLongError);
nameToErrorMap.set('CreatorsTooLong', CreatorsTooLongError);
/** CreatorsMustBeAtleastOne: Creators must be at least one if set */
class CreatorsMustBeAtleastOneError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creators must be at least one if set', program, cause);
        this.name = 'CreatorsMustBeAtleastOne';
        this.code = 0x25; // 37
    }
}
exports.CreatorsMustBeAtleastOneError = CreatorsMustBeAtleastOneError;
codeToErrorMap.set(0x25, CreatorsMustBeAtleastOneError);
nameToErrorMap.set('CreatorsMustBeAtleastOne', CreatorsMustBeAtleastOneError);
/** MustBeOneOfCreators */
class MustBeOneOfCreatorsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'MustBeOneOfCreators';
        this.code = 0x26; // 38
    }
}
exports.MustBeOneOfCreatorsError = MustBeOneOfCreatorsError;
codeToErrorMap.set(0x26, MustBeOneOfCreatorsError);
nameToErrorMap.set('MustBeOneOfCreators', MustBeOneOfCreatorsError);
/** NoCreatorsPresentOnMetadata: This metadata does not have creators */
class NoCreatorsPresentOnMetadataError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This metadata does not have creators', program, cause);
        this.name = 'NoCreatorsPresentOnMetadata';
        this.code = 0x27; // 39
    }
}
exports.NoCreatorsPresentOnMetadataError = NoCreatorsPresentOnMetadataError;
codeToErrorMap.set(0x27, NoCreatorsPresentOnMetadataError);
nameToErrorMap.set('NoCreatorsPresentOnMetadata', NoCreatorsPresentOnMetadataError);
/** CreatorNotFound: This creator address was not found */
class CreatorNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This creator address was not found', program, cause);
        this.name = 'CreatorNotFound';
        this.code = 0x28; // 40
    }
}
exports.CreatorNotFoundError = CreatorNotFoundError;
codeToErrorMap.set(0x28, CreatorNotFoundError);
nameToErrorMap.set('CreatorNotFound', CreatorNotFoundError);
/** InvalidBasisPoints: Basis points cannot be more than 10000 */
class InvalidBasisPointsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Basis points cannot be more than 10000', program, cause);
        this.name = 'InvalidBasisPoints';
        this.code = 0x29; // 41
    }
}
exports.InvalidBasisPointsError = InvalidBasisPointsError;
codeToErrorMap.set(0x29, InvalidBasisPointsError);
nameToErrorMap.set('InvalidBasisPoints', InvalidBasisPointsError);
/** PrimarySaleCanOnlyBeFlippedToTrue: Primary sale can only be flipped to true and is immutable */
class PrimarySaleCanOnlyBeFlippedToTrueError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Primary sale can only be flipped to true and is immutable', program, cause);
        this.name = 'PrimarySaleCanOnlyBeFlippedToTrue';
        this.code = 0x2a; // 42
    }
}
exports.PrimarySaleCanOnlyBeFlippedToTrueError = PrimarySaleCanOnlyBeFlippedToTrueError;
codeToErrorMap.set(0x2a, PrimarySaleCanOnlyBeFlippedToTrueError);
nameToErrorMap.set('PrimarySaleCanOnlyBeFlippedToTrue', PrimarySaleCanOnlyBeFlippedToTrueError);
/** OwnerMismatch: Owner does not match that on the account given */
class OwnerMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Owner does not match that on the account given', program, cause);
        this.name = 'OwnerMismatch';
        this.code = 0x2b; // 43
    }
}
exports.OwnerMismatchError = OwnerMismatchError;
codeToErrorMap.set(0x2b, OwnerMismatchError);
nameToErrorMap.set('OwnerMismatch', OwnerMismatchError);
/** NoBalanceInAccountForAuthorization: This account has no tokens to be used for authorization */
class NoBalanceInAccountForAuthorizationError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This account has no tokens to be used for authorization', program, cause);
        this.name = 'NoBalanceInAccountForAuthorization';
        this.code = 0x2c; // 44
    }
}
exports.NoBalanceInAccountForAuthorizationError = NoBalanceInAccountForAuthorizationError;
codeToErrorMap.set(0x2c, NoBalanceInAccountForAuthorizationError);
nameToErrorMap.set('NoBalanceInAccountForAuthorization', NoBalanceInAccountForAuthorizationError);
/** ShareTotalMustBe100: Share total must equal 100 for creator array */
class ShareTotalMustBe100Error extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Share total must equal 100 for creator array', program, cause);
        this.name = 'ShareTotalMustBe100';
        this.code = 0x2d; // 45
    }
}
exports.ShareTotalMustBe100Error = ShareTotalMustBe100Error;
codeToErrorMap.set(0x2d, ShareTotalMustBe100Error);
nameToErrorMap.set('ShareTotalMustBe100', ShareTotalMustBe100Error);
/** ReservationExists */
class ReservationExistsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationExists';
        this.code = 0x2e; // 46
    }
}
exports.ReservationExistsError = ReservationExistsError;
codeToErrorMap.set(0x2e, ReservationExistsError);
nameToErrorMap.set('ReservationExists', ReservationExistsError);
/** ReservationDoesNotExist */
class ReservationDoesNotExistError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationDoesNotExist';
        this.code = 0x2f; // 47
    }
}
exports.ReservationDoesNotExistError = ReservationDoesNotExistError;
codeToErrorMap.set(0x2f, ReservationDoesNotExistError);
nameToErrorMap.set('ReservationDoesNotExist', ReservationDoesNotExistError);
/** ReservationNotSet */
class ReservationNotSetError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationNotSet';
        this.code = 0x30; // 48
    }
}
exports.ReservationNotSetError = ReservationNotSetError;
codeToErrorMap.set(0x30, ReservationNotSetError);
nameToErrorMap.set('ReservationNotSet', ReservationNotSetError);
/** ReservationAlreadyMade */
class ReservationAlreadyMadeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationAlreadyMade';
        this.code = 0x31; // 49
    }
}
exports.ReservationAlreadyMadeError = ReservationAlreadyMadeError;
codeToErrorMap.set(0x31, ReservationAlreadyMadeError);
nameToErrorMap.set('ReservationAlreadyMade', ReservationAlreadyMadeError);
/** BeyondMaxAddressSize */
class BeyondMaxAddressSizeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'BeyondMaxAddressSize';
        this.code = 0x32; // 50
    }
}
exports.BeyondMaxAddressSizeError = BeyondMaxAddressSizeError;
codeToErrorMap.set(0x32, BeyondMaxAddressSizeError);
nameToErrorMap.set('BeyondMaxAddressSize', BeyondMaxAddressSizeError);
/** NumericalOverflowError: NumericalOverflowError */
class NumericalOverflowErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('NumericalOverflowError', program, cause);
        this.name = 'NumericalOverflowError';
        this.code = 0x33; // 51
    }
}
exports.NumericalOverflowErrorError = NumericalOverflowErrorError;
codeToErrorMap.set(0x33, NumericalOverflowErrorError);
nameToErrorMap.set('NumericalOverflowError', NumericalOverflowErrorError);
/** ReservationBreachesMaximumSupply */
class ReservationBreachesMaximumSupplyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationBreachesMaximumSupply';
        this.code = 0x34; // 52
    }
}
exports.ReservationBreachesMaximumSupplyError = ReservationBreachesMaximumSupplyError;
codeToErrorMap.set(0x34, ReservationBreachesMaximumSupplyError);
nameToErrorMap.set('ReservationBreachesMaximumSupply', ReservationBreachesMaximumSupplyError);
/** AddressNotInReservation */
class AddressNotInReservationError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'AddressNotInReservation';
        this.code = 0x35; // 53
    }
}
exports.AddressNotInReservationError = AddressNotInReservationError;
codeToErrorMap.set(0x35, AddressNotInReservationError);
nameToErrorMap.set('AddressNotInReservation', AddressNotInReservationError);
/** CannotVerifyAnotherCreator: You cannot unilaterally verify another creator, they must sign */
class CannotVerifyAnotherCreatorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('You cannot unilaterally verify another creator, they must sign', program, cause);
        this.name = 'CannotVerifyAnotherCreator';
        this.code = 0x36; // 54
    }
}
exports.CannotVerifyAnotherCreatorError = CannotVerifyAnotherCreatorError;
codeToErrorMap.set(0x36, CannotVerifyAnotherCreatorError);
nameToErrorMap.set('CannotVerifyAnotherCreator', CannotVerifyAnotherCreatorError);
/** CannotUnverifyAnotherCreator: You cannot unilaterally unverify another creator */
class CannotUnverifyAnotherCreatorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('You cannot unilaterally unverify another creator', program, cause);
        this.name = 'CannotUnverifyAnotherCreator';
        this.code = 0x37; // 55
    }
}
exports.CannotUnverifyAnotherCreatorError = CannotUnverifyAnotherCreatorError;
codeToErrorMap.set(0x37, CannotUnverifyAnotherCreatorError);
nameToErrorMap.set('CannotUnverifyAnotherCreator', CannotUnverifyAnotherCreatorError);
/** SpotMismatch */
class SpotMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'SpotMismatch';
        this.code = 0x38; // 56
    }
}
exports.SpotMismatchError = SpotMismatchError;
codeToErrorMap.set(0x38, SpotMismatchError);
nameToErrorMap.set('SpotMismatch', SpotMismatchError);
/** IncorrectOwner: Incorrect account owner */
class IncorrectOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Incorrect account owner', program, cause);
        this.name = 'IncorrectOwner';
        this.code = 0x39; // 57
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
codeToErrorMap.set(0x39, IncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', IncorrectOwnerError);
/** PrintingWouldBreachMaximumSupply */
class PrintingWouldBreachMaximumSupplyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'PrintingWouldBreachMaximumSupply';
        this.code = 0x3a; // 58
    }
}
exports.PrintingWouldBreachMaximumSupplyError = PrintingWouldBreachMaximumSupplyError;
codeToErrorMap.set(0x3a, PrintingWouldBreachMaximumSupplyError);
nameToErrorMap.set('PrintingWouldBreachMaximumSupply', PrintingWouldBreachMaximumSupplyError);
/** DataIsImmutable: Data is immutable */
class DataIsImmutableError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Data is immutable', program, cause);
        this.name = 'DataIsImmutable';
        this.code = 0x3b; // 59
    }
}
exports.DataIsImmutableError = DataIsImmutableError;
codeToErrorMap.set(0x3b, DataIsImmutableError);
nameToErrorMap.set('DataIsImmutable', DataIsImmutableError);
/** DuplicateCreatorAddress: No duplicate creator addresses */
class DuplicateCreatorAddressError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('No duplicate creator addresses', program, cause);
        this.name = 'DuplicateCreatorAddress';
        this.code = 0x3c; // 60
    }
}
exports.DuplicateCreatorAddressError = DuplicateCreatorAddressError;
codeToErrorMap.set(0x3c, DuplicateCreatorAddressError);
nameToErrorMap.set('DuplicateCreatorAddress', DuplicateCreatorAddressError);
/** ReservationSpotsRemainingShouldMatchTotalSpotsAtStart */
class ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart';
        this.code = 0x3d; // 61
    }
}
exports.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError;
codeToErrorMap.set(0x3d, ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError);
nameToErrorMap.set('ReservationSpotsRemainingShouldMatchTotalSpotsAtStart', ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError);
/** InvalidTokenProgram: Invalid token program */
class InvalidTokenProgramError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid token program', program, cause);
        this.name = 'InvalidTokenProgram';
        this.code = 0x3e; // 62
    }
}
exports.InvalidTokenProgramError = InvalidTokenProgramError;
codeToErrorMap.set(0x3e, InvalidTokenProgramError);
nameToErrorMap.set('InvalidTokenProgram', InvalidTokenProgramError);
/** DataTypeMismatch: Data type mismatch */
class DataTypeMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Data type mismatch', program, cause);
        this.name = 'DataTypeMismatch';
        this.code = 0x3f; // 63
    }
}
exports.DataTypeMismatchError = DataTypeMismatchError;
codeToErrorMap.set(0x3f, DataTypeMismatchError);
nameToErrorMap.set('DataTypeMismatch', DataTypeMismatchError);
/** BeyondAlottedAddressSize */
class BeyondAlottedAddressSizeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'BeyondAlottedAddressSize';
        this.code = 0x40; // 64
    }
}
exports.BeyondAlottedAddressSizeError = BeyondAlottedAddressSizeError;
codeToErrorMap.set(0x40, BeyondAlottedAddressSizeError);
nameToErrorMap.set('BeyondAlottedAddressSize', BeyondAlottedAddressSizeError);
/** ReservationNotComplete */
class ReservationNotCompleteError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationNotComplete';
        this.code = 0x41; // 65
    }
}
exports.ReservationNotCompleteError = ReservationNotCompleteError;
codeToErrorMap.set(0x41, ReservationNotCompleteError);
nameToErrorMap.set('ReservationNotComplete', ReservationNotCompleteError);
/** TriedToReplaceAnExistingReservation */
class TriedToReplaceAnExistingReservationError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'TriedToReplaceAnExistingReservation';
        this.code = 0x42; // 66
    }
}
exports.TriedToReplaceAnExistingReservationError = TriedToReplaceAnExistingReservationError;
codeToErrorMap.set(0x42, TriedToReplaceAnExistingReservationError);
nameToErrorMap.set('TriedToReplaceAnExistingReservation', TriedToReplaceAnExistingReservationError);
/** InvalidOperation: Invalid operation */
class InvalidOperationError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid operation', program, cause);
        this.name = 'InvalidOperation';
        this.code = 0x43; // 67
    }
}
exports.InvalidOperationError = InvalidOperationError;
codeToErrorMap.set(0x43, InvalidOperationError);
nameToErrorMap.set('InvalidOperation', InvalidOperationError);
/** InvalidOwner: Invalid Owner */
class InvalidOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Owner', program, cause);
        this.name = 'InvalidOwner';
        this.code = 0x44; // 68
    }
}
exports.InvalidOwnerError = InvalidOwnerError;
codeToErrorMap.set(0x44, InvalidOwnerError);
nameToErrorMap.set('InvalidOwner', InvalidOwnerError);
/** PrintingMintSupplyMustBeZeroForConversion: Printing mint supply must be zero for conversion */
class PrintingMintSupplyMustBeZeroForConversionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Printing mint supply must be zero for conversion', program, cause);
        this.name = 'PrintingMintSupplyMustBeZeroForConversion';
        this.code = 0x45; // 69
    }
}
exports.PrintingMintSupplyMustBeZeroForConversionError = PrintingMintSupplyMustBeZeroForConversionError;
codeToErrorMap.set(0x45, PrintingMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set('PrintingMintSupplyMustBeZeroForConversion', PrintingMintSupplyMustBeZeroForConversionError);
/** OneTimeAuthMintSupplyMustBeZeroForConversion: One Time Auth mint supply must be zero for conversion */
class OneTimeAuthMintSupplyMustBeZeroForConversionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('One Time Auth mint supply must be zero for conversion', program, cause);
        this.name = 'OneTimeAuthMintSupplyMustBeZeroForConversion';
        this.code = 0x46; // 70
    }
}
exports.OneTimeAuthMintSupplyMustBeZeroForConversionError = OneTimeAuthMintSupplyMustBeZeroForConversionError;
codeToErrorMap.set(0x46, OneTimeAuthMintSupplyMustBeZeroForConversionError);
nameToErrorMap.set('OneTimeAuthMintSupplyMustBeZeroForConversion', OneTimeAuthMintSupplyMustBeZeroForConversionError);
/** InvalidEditionIndex: You tried to insert one edition too many into an edition mark pda */
class InvalidEditionIndexError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('You tried to insert one edition too many into an edition mark pda', program, cause);
        this.name = 'InvalidEditionIndex';
        this.code = 0x47; // 71
    }
}
exports.InvalidEditionIndexError = InvalidEditionIndexError;
codeToErrorMap.set(0x47, InvalidEditionIndexError);
nameToErrorMap.set('InvalidEditionIndex', InvalidEditionIndexError);
/** ReservationArrayShouldBeSizeOne */
class ReservationArrayShouldBeSizeOneError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'ReservationArrayShouldBeSizeOne';
        this.code = 0x48; // 72
    }
}
exports.ReservationArrayShouldBeSizeOneError = ReservationArrayShouldBeSizeOneError;
codeToErrorMap.set(0x48, ReservationArrayShouldBeSizeOneError);
nameToErrorMap.set('ReservationArrayShouldBeSizeOne', ReservationArrayShouldBeSizeOneError);
/** IsMutableCanOnlyBeFlippedToFalse: Is Mutable can only be flipped to false */
class IsMutableCanOnlyBeFlippedToFalseError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Is Mutable can only be flipped to false', program, cause);
        this.name = 'IsMutableCanOnlyBeFlippedToFalse';
        this.code = 0x49; // 73
    }
}
exports.IsMutableCanOnlyBeFlippedToFalseError = IsMutableCanOnlyBeFlippedToFalseError;
codeToErrorMap.set(0x49, IsMutableCanOnlyBeFlippedToFalseError);
nameToErrorMap.set('IsMutableCanOnlyBeFlippedToFalse', IsMutableCanOnlyBeFlippedToFalseError);
/** CollectionCannotBeVerifiedInThisInstruction: Collection cannot be verified in this instruction */
class CollectionCannotBeVerifiedInThisInstructionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection cannot be verified in this instruction', program, cause);
        this.name = 'CollectionCannotBeVerifiedInThisInstruction';
        this.code = 0x4a; // 74
    }
}
exports.CollectionCannotBeVerifiedInThisInstructionError = CollectionCannotBeVerifiedInThisInstructionError;
codeToErrorMap.set(0x4a, CollectionCannotBeVerifiedInThisInstructionError);
nameToErrorMap.set('CollectionCannotBeVerifiedInThisInstruction', CollectionCannotBeVerifiedInThisInstructionError);
/** Removed: This instruction was deprecated in a previous release and is now removed */
class RemovedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This instruction was deprecated in a previous release and is now removed', program, cause);
        this.name = 'Removed';
        this.code = 0x4b; // 75
    }
}
exports.RemovedError = RemovedError;
codeToErrorMap.set(0x4b, RemovedError);
nameToErrorMap.set('Removed', RemovedError);
/** MustBeBurned */
class MustBeBurnedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'MustBeBurned';
        this.code = 0x4c; // 76
    }
}
exports.MustBeBurnedError = MustBeBurnedError;
codeToErrorMap.set(0x4c, MustBeBurnedError);
nameToErrorMap.set('MustBeBurned', MustBeBurnedError);
/** InvalidUseMethod: This use method is invalid */
class InvalidUseMethodError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This use method is invalid', program, cause);
        this.name = 'InvalidUseMethod';
        this.code = 0x4d; // 77
    }
}
exports.InvalidUseMethodError = InvalidUseMethodError;
codeToErrorMap.set(0x4d, InvalidUseMethodError);
nameToErrorMap.set('InvalidUseMethod', InvalidUseMethodError);
/** CannotChangeUseMethodAfterFirstUse: Cannot Change Use Method after the first use */
class CannotChangeUseMethodAfterFirstUseError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot Change Use Method after the first use', program, cause);
        this.name = 'CannotChangeUseMethodAfterFirstUse';
        this.code = 0x4e; // 78
    }
}
exports.CannotChangeUseMethodAfterFirstUseError = CannotChangeUseMethodAfterFirstUseError;
codeToErrorMap.set(0x4e, CannotChangeUseMethodAfterFirstUseError);
nameToErrorMap.set('CannotChangeUseMethodAfterFirstUse', CannotChangeUseMethodAfterFirstUseError);
/** CannotChangeUsesAfterFirstUse: Cannot Change Remaining or Available uses after the first use */
class CannotChangeUsesAfterFirstUseError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot Change Remaining or Available uses after the first use', program, cause);
        this.name = 'CannotChangeUsesAfterFirstUse';
        this.code = 0x4f; // 79
    }
}
exports.CannotChangeUsesAfterFirstUseError = CannotChangeUsesAfterFirstUseError;
codeToErrorMap.set(0x4f, CannotChangeUsesAfterFirstUseError);
nameToErrorMap.set('CannotChangeUsesAfterFirstUse', CannotChangeUsesAfterFirstUseError);
/** CollectionNotFound: Collection Not Found on Metadata */
class CollectionNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection Not Found on Metadata', program, cause);
        this.name = 'CollectionNotFound';
        this.code = 0x50; // 80
    }
}
exports.CollectionNotFoundError = CollectionNotFoundError;
codeToErrorMap.set(0x50, CollectionNotFoundError);
nameToErrorMap.set('CollectionNotFound', CollectionNotFoundError);
/** InvalidCollectionUpdateAuthority: Collection Update Authority is invalid */
class InvalidCollectionUpdateAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection Update Authority is invalid', program, cause);
        this.name = 'InvalidCollectionUpdateAuthority';
        this.code = 0x51; // 81
    }
}
exports.InvalidCollectionUpdateAuthorityError = InvalidCollectionUpdateAuthorityError;
codeToErrorMap.set(0x51, InvalidCollectionUpdateAuthorityError);
nameToErrorMap.set('InvalidCollectionUpdateAuthority', InvalidCollectionUpdateAuthorityError);
/** CollectionMustBeAUniqueMasterEdition: Collection Must Be a Unique Master Edition v2 */
class CollectionMustBeAUniqueMasterEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection Must Be a Unique Master Edition v2', program, cause);
        this.name = 'CollectionMustBeAUniqueMasterEdition';
        this.code = 0x52; // 82
    }
}
exports.CollectionMustBeAUniqueMasterEditionError = CollectionMustBeAUniqueMasterEditionError;
codeToErrorMap.set(0x52, CollectionMustBeAUniqueMasterEditionError);
nameToErrorMap.set('CollectionMustBeAUniqueMasterEdition', CollectionMustBeAUniqueMasterEditionError);
/** UseAuthorityRecordAlreadyExists: The Use Authority Record Already Exists, to modify it Revoke, then Approve */
class UseAuthorityRecordAlreadyExistsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The Use Authority Record Already Exists, to modify it Revoke, then Approve', program, cause);
        this.name = 'UseAuthorityRecordAlreadyExists';
        this.code = 0x53; // 83
    }
}
exports.UseAuthorityRecordAlreadyExistsError = UseAuthorityRecordAlreadyExistsError;
codeToErrorMap.set(0x53, UseAuthorityRecordAlreadyExistsError);
nameToErrorMap.set('UseAuthorityRecordAlreadyExists', UseAuthorityRecordAlreadyExistsError);
/** UseAuthorityRecordAlreadyRevoked: The Use Authority Record is empty or already revoked */
class UseAuthorityRecordAlreadyRevokedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The Use Authority Record is empty or already revoked', program, cause);
        this.name = 'UseAuthorityRecordAlreadyRevoked';
        this.code = 0x54; // 84
    }
}
exports.UseAuthorityRecordAlreadyRevokedError = UseAuthorityRecordAlreadyRevokedError;
codeToErrorMap.set(0x54, UseAuthorityRecordAlreadyRevokedError);
nameToErrorMap.set('UseAuthorityRecordAlreadyRevoked', UseAuthorityRecordAlreadyRevokedError);
/** Unusable: This token has no uses */
class UnusableError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This token has no uses', program, cause);
        this.name = 'Unusable';
        this.code = 0x55; // 85
    }
}
exports.UnusableError = UnusableError;
codeToErrorMap.set(0x55, UnusableError);
nameToErrorMap.set('Unusable', UnusableError);
/** NotEnoughUses: There are not enough Uses left on this token. */
class NotEnoughUsesError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('There are not enough Uses left on this token.', program, cause);
        this.name = 'NotEnoughUses';
        this.code = 0x56; // 86
    }
}
exports.NotEnoughUsesError = NotEnoughUsesError;
codeToErrorMap.set(0x56, NotEnoughUsesError);
nameToErrorMap.set('NotEnoughUses', NotEnoughUsesError);
/** CollectionAuthorityRecordAlreadyExists: This Collection Authority Record Already Exists. */
class CollectionAuthorityRecordAlreadyExistsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This Collection Authority Record Already Exists.', program, cause);
        this.name = 'CollectionAuthorityRecordAlreadyExists';
        this.code = 0x57; // 87
    }
}
exports.CollectionAuthorityRecordAlreadyExistsError = CollectionAuthorityRecordAlreadyExistsError;
codeToErrorMap.set(0x57, CollectionAuthorityRecordAlreadyExistsError);
nameToErrorMap.set('CollectionAuthorityRecordAlreadyExists', CollectionAuthorityRecordAlreadyExistsError);
/** CollectionAuthorityDoesNotExist: This Collection Authority Record Does Not Exist. */
class CollectionAuthorityDoesNotExistError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This Collection Authority Record Does Not Exist.', program, cause);
        this.name = 'CollectionAuthorityDoesNotExist';
        this.code = 0x58; // 88
    }
}
exports.CollectionAuthorityDoesNotExistError = CollectionAuthorityDoesNotExistError;
codeToErrorMap.set(0x58, CollectionAuthorityDoesNotExistError);
nameToErrorMap.set('CollectionAuthorityDoesNotExist', CollectionAuthorityDoesNotExistError);
/** InvalidUseAuthorityRecord: This Use Authority Record is invalid. */
class InvalidUseAuthorityRecordError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This Use Authority Record is invalid.', program, cause);
        this.name = 'InvalidUseAuthorityRecord';
        this.code = 0x59; // 89
    }
}
exports.InvalidUseAuthorityRecordError = InvalidUseAuthorityRecordError;
codeToErrorMap.set(0x59, InvalidUseAuthorityRecordError);
nameToErrorMap.set('InvalidUseAuthorityRecord', InvalidUseAuthorityRecordError);
/** InvalidCollectionAuthorityRecord */
class InvalidCollectionAuthorityRecordError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InvalidCollectionAuthorityRecord';
        this.code = 0x5a; // 90
    }
}
exports.InvalidCollectionAuthorityRecordError = InvalidCollectionAuthorityRecordError;
codeToErrorMap.set(0x5a, InvalidCollectionAuthorityRecordError);
nameToErrorMap.set('InvalidCollectionAuthorityRecord', InvalidCollectionAuthorityRecordError);
/** InvalidFreezeAuthority: Metadata does not match the freeze authority on the mint */
class InvalidFreezeAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Metadata does not match the freeze authority on the mint', program, cause);
        this.name = 'InvalidFreezeAuthority';
        this.code = 0x5b; // 91
    }
}
exports.InvalidFreezeAuthorityError = InvalidFreezeAuthorityError;
codeToErrorMap.set(0x5b, InvalidFreezeAuthorityError);
nameToErrorMap.set('InvalidFreezeAuthority', InvalidFreezeAuthorityError);
/** InvalidDelegate: All tokens in this account have not been delegated to this user. */
class InvalidDelegateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('All tokens in this account have not been delegated to this user.', program, cause);
        this.name = 'InvalidDelegate';
        this.code = 0x5c; // 92
    }
}
exports.InvalidDelegateError = InvalidDelegateError;
codeToErrorMap.set(0x5c, InvalidDelegateError);
nameToErrorMap.set('InvalidDelegate', InvalidDelegateError);
/** CannotAdjustVerifiedCreator */
class CannotAdjustVerifiedCreatorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'CannotAdjustVerifiedCreator';
        this.code = 0x5d; // 93
    }
}
exports.CannotAdjustVerifiedCreatorError = CannotAdjustVerifiedCreatorError;
codeToErrorMap.set(0x5d, CannotAdjustVerifiedCreatorError);
nameToErrorMap.set('CannotAdjustVerifiedCreator', CannotAdjustVerifiedCreatorError);
/** CannotRemoveVerifiedCreator: Verified creators cannot be removed. */
class CannotRemoveVerifiedCreatorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Verified creators cannot be removed.', program, cause);
        this.name = 'CannotRemoveVerifiedCreator';
        this.code = 0x5e; // 94
    }
}
exports.CannotRemoveVerifiedCreatorError = CannotRemoveVerifiedCreatorError;
codeToErrorMap.set(0x5e, CannotRemoveVerifiedCreatorError);
nameToErrorMap.set('CannotRemoveVerifiedCreator', CannotRemoveVerifiedCreatorError);
/** CannotWipeVerifiedCreators */
class CannotWipeVerifiedCreatorsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'CannotWipeVerifiedCreators';
        this.code = 0x5f; // 95
    }
}
exports.CannotWipeVerifiedCreatorsError = CannotWipeVerifiedCreatorsError;
codeToErrorMap.set(0x5f, CannotWipeVerifiedCreatorsError);
nameToErrorMap.set('CannotWipeVerifiedCreators', CannotWipeVerifiedCreatorsError);
/** NotAllowedToChangeSellerFeeBasisPoints */
class NotAllowedToChangeSellerFeeBasisPointsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'NotAllowedToChangeSellerFeeBasisPoints';
        this.code = 0x60; // 96
    }
}
exports.NotAllowedToChangeSellerFeeBasisPointsError = NotAllowedToChangeSellerFeeBasisPointsError;
codeToErrorMap.set(0x60, NotAllowedToChangeSellerFeeBasisPointsError);
nameToErrorMap.set('NotAllowedToChangeSellerFeeBasisPoints', NotAllowedToChangeSellerFeeBasisPointsError);
/** EditionOverrideCannotBeZero: Edition override cannot be zero */
class EditionOverrideCannotBeZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Edition override cannot be zero', program, cause);
        this.name = 'EditionOverrideCannotBeZero';
        this.code = 0x61; // 97
    }
}
exports.EditionOverrideCannotBeZeroError = EditionOverrideCannotBeZeroError;
codeToErrorMap.set(0x61, EditionOverrideCannotBeZeroError);
nameToErrorMap.set('EditionOverrideCannotBeZero', EditionOverrideCannotBeZeroError);
/** InvalidUser: Invalid User */
class InvalidUserError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid User', program, cause);
        this.name = 'InvalidUser';
        this.code = 0x62; // 98
    }
}
exports.InvalidUserError = InvalidUserError;
codeToErrorMap.set(0x62, InvalidUserError);
nameToErrorMap.set('InvalidUser', InvalidUserError);
/** RevokeCollectionAuthoritySignerIncorrect: Revoke Collection Authority signer is incorrect */
class RevokeCollectionAuthoritySignerIncorrectError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Revoke Collection Authority signer is incorrect', program, cause);
        this.name = 'RevokeCollectionAuthoritySignerIncorrect';
        this.code = 0x63; // 99
    }
}
exports.RevokeCollectionAuthoritySignerIncorrectError = RevokeCollectionAuthoritySignerIncorrectError;
codeToErrorMap.set(0x63, RevokeCollectionAuthoritySignerIncorrectError);
nameToErrorMap.set('RevokeCollectionAuthoritySignerIncorrect', RevokeCollectionAuthoritySignerIncorrectError);
/** TokenCloseFailed */
class TokenCloseFailedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'TokenCloseFailed';
        this.code = 0x64; // 100
    }
}
exports.TokenCloseFailedError = TokenCloseFailedError;
codeToErrorMap.set(0x64, TokenCloseFailedError);
nameToErrorMap.set('TokenCloseFailed', TokenCloseFailedError);
/** UnsizedCollection: Can't use this function on unsized collection */
class UnsizedCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super("Can't use this function on unsized collection", program, cause);
        this.name = 'UnsizedCollection';
        this.code = 0x65; // 101
    }
}
exports.UnsizedCollectionError = UnsizedCollectionError;
codeToErrorMap.set(0x65, UnsizedCollectionError);
nameToErrorMap.set('UnsizedCollection', UnsizedCollectionError);
/** SizedCollection: Can't use this function on a sized collection */
class SizedCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super("Can't use this function on a sized collection", program, cause);
        this.name = 'SizedCollection';
        this.code = 0x66; // 102
    }
}
exports.SizedCollectionError = SizedCollectionError;
codeToErrorMap.set(0x66, SizedCollectionError);
nameToErrorMap.set('SizedCollection', SizedCollectionError);
/** MissingCollectionMetadata: Missing collection metadata account */
class MissingCollectionMetadataError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection metadata account', program, cause);
        this.name = 'MissingCollectionMetadata';
        this.code = 0x67; // 103
    }
}
exports.MissingCollectionMetadataError = MissingCollectionMetadataError;
codeToErrorMap.set(0x67, MissingCollectionMetadataError);
nameToErrorMap.set('MissingCollectionMetadata', MissingCollectionMetadataError);
/** NotAMemberOfCollection: This NFT is not a member of the specified collection. */
class NotAMemberOfCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This NFT is not a member of the specified collection.', program, cause);
        this.name = 'NotAMemberOfCollection';
        this.code = 0x68; // 104
    }
}
exports.NotAMemberOfCollectionError = NotAMemberOfCollectionError;
codeToErrorMap.set(0x68, NotAMemberOfCollectionError);
nameToErrorMap.set('NotAMemberOfCollection', NotAMemberOfCollectionError);
/** NotVerifiedMemberOfCollection: This NFT is not a verified member of the specified collection. */
class NotVerifiedMemberOfCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This NFT is not a verified member of the specified collection.', program, cause);
        this.name = 'NotVerifiedMemberOfCollection';
        this.code = 0x69; // 105
    }
}
exports.NotVerifiedMemberOfCollectionError = NotVerifiedMemberOfCollectionError;
codeToErrorMap.set(0x69, NotVerifiedMemberOfCollectionError);
nameToErrorMap.set('NotVerifiedMemberOfCollection', NotVerifiedMemberOfCollectionError);
/** NotACollectionParent: This NFT is not a collection parent NFT. */
class NotACollectionParentError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This NFT is not a collection parent NFT.', program, cause);
        this.name = 'NotACollectionParent';
        this.code = 0x6a; // 106
    }
}
exports.NotACollectionParentError = NotACollectionParentError;
codeToErrorMap.set(0x6a, NotACollectionParentError);
nameToErrorMap.set('NotACollectionParent', NotACollectionParentError);
/** CouldNotDetermineTokenStandard: Could not determine a TokenStandard type. */
class CouldNotDetermineTokenStandardError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Could not determine a TokenStandard type.', program, cause);
        this.name = 'CouldNotDetermineTokenStandard';
        this.code = 0x6b; // 107
    }
}
exports.CouldNotDetermineTokenStandardError = CouldNotDetermineTokenStandardError;
codeToErrorMap.set(0x6b, CouldNotDetermineTokenStandardError);
nameToErrorMap.set('CouldNotDetermineTokenStandard', CouldNotDetermineTokenStandardError);
/** MissingEditionAccount: This mint account has an edition but none was provided. */
class MissingEditionAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This mint account has an edition but none was provided.', program, cause);
        this.name = 'MissingEditionAccount';
        this.code = 0x6c; // 108
    }
}
exports.MissingEditionAccountError = MissingEditionAccountError;
codeToErrorMap.set(0x6c, MissingEditionAccountError);
nameToErrorMap.set('MissingEditionAccount', MissingEditionAccountError);
/** NotAMasterEdition: This edition is not a Master Edition */
class NotAMasterEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This edition is not a Master Edition', program, cause);
        this.name = 'NotAMasterEdition';
        this.code = 0x6d; // 109
    }
}
exports.NotAMasterEditionError = NotAMasterEditionError;
codeToErrorMap.set(0x6d, NotAMasterEditionError);
nameToErrorMap.set('NotAMasterEdition', NotAMasterEditionError);
/** MasterEditionHasPrints: This Master Edition has existing prints */
class MasterEditionHasPrintsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This Master Edition has existing prints', program, cause);
        this.name = 'MasterEditionHasPrints';
        this.code = 0x6e; // 110
    }
}
exports.MasterEditionHasPrintsError = MasterEditionHasPrintsError;
codeToErrorMap.set(0x6e, MasterEditionHasPrintsError);
nameToErrorMap.set('MasterEditionHasPrints', MasterEditionHasPrintsError);
/** BorshDeserializationError */
class BorshDeserializationErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'BorshDeserializationError';
        this.code = 0x6f; // 111
    }
}
exports.BorshDeserializationErrorError = BorshDeserializationErrorError;
codeToErrorMap.set(0x6f, BorshDeserializationErrorError);
nameToErrorMap.set('BorshDeserializationError', BorshDeserializationErrorError);
/** CannotUpdateVerifiedCollection: Cannot update a verified collection in this command */
class CannotUpdateVerifiedCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot update a verified collection in this command', program, cause);
        this.name = 'CannotUpdateVerifiedCollection';
        this.code = 0x70; // 112
    }
}
exports.CannotUpdateVerifiedCollectionError = CannotUpdateVerifiedCollectionError;
codeToErrorMap.set(0x70, CannotUpdateVerifiedCollectionError);
nameToErrorMap.set('CannotUpdateVerifiedCollection', CannotUpdateVerifiedCollectionError);
/** CollectionMasterEditionAccountInvalid: Edition account doesnt match collection  */
class CollectionMasterEditionAccountInvalidError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Edition account doesnt match collection ', program, cause);
        this.name = 'CollectionMasterEditionAccountInvalid';
        this.code = 0x71; // 113
    }
}
exports.CollectionMasterEditionAccountInvalidError = CollectionMasterEditionAccountInvalidError;
codeToErrorMap.set(0x71, CollectionMasterEditionAccountInvalidError);
nameToErrorMap.set('CollectionMasterEditionAccountInvalid', CollectionMasterEditionAccountInvalidError);
/** AlreadyVerified: Item is already verified. */
class AlreadyVerifiedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Item is already verified.', program, cause);
        this.name = 'AlreadyVerified';
        this.code = 0x72; // 114
    }
}
exports.AlreadyVerifiedError = AlreadyVerifiedError;
codeToErrorMap.set(0x72, AlreadyVerifiedError);
nameToErrorMap.set('AlreadyVerified', AlreadyVerifiedError);
/** AlreadyUnverified */
class AlreadyUnverifiedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'AlreadyUnverified';
        this.code = 0x73; // 115
    }
}
exports.AlreadyUnverifiedError = AlreadyUnverifiedError;
codeToErrorMap.set(0x73, AlreadyUnverifiedError);
nameToErrorMap.set('AlreadyUnverified', AlreadyUnverifiedError);
/** NotAPrintEdition: This edition is not a Print Edition */
class NotAPrintEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This edition is not a Print Edition', program, cause);
        this.name = 'NotAPrintEdition';
        this.code = 0x74; // 116
    }
}
exports.NotAPrintEditionError = NotAPrintEditionError;
codeToErrorMap.set(0x74, NotAPrintEditionError);
nameToErrorMap.set('NotAPrintEdition', NotAPrintEditionError);
/** InvalidMasterEdition: Invalid Master Edition */
class InvalidMasterEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Master Edition', program, cause);
        this.name = 'InvalidMasterEdition';
        this.code = 0x75; // 117
    }
}
exports.InvalidMasterEditionError = InvalidMasterEditionError;
codeToErrorMap.set(0x75, InvalidMasterEditionError);
nameToErrorMap.set('InvalidMasterEdition', InvalidMasterEditionError);
/** InvalidPrintEdition: Invalid Print Edition */
class InvalidPrintEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Print Edition', program, cause);
        this.name = 'InvalidPrintEdition';
        this.code = 0x76; // 118
    }
}
exports.InvalidPrintEditionError = InvalidPrintEditionError;
codeToErrorMap.set(0x76, InvalidPrintEditionError);
nameToErrorMap.set('InvalidPrintEdition', InvalidPrintEditionError);
/** InvalidEditionMarker: Invalid Edition Marker */
class InvalidEditionMarkerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Edition Marker', program, cause);
        this.name = 'InvalidEditionMarker';
        this.code = 0x77; // 119
    }
}
exports.InvalidEditionMarkerError = InvalidEditionMarkerError;
codeToErrorMap.set(0x77, InvalidEditionMarkerError);
nameToErrorMap.set('InvalidEditionMarker', InvalidEditionMarkerError);
/** ReservationListDeprecated: Reservation List is Deprecated */
class ReservationListDeprecatedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Reservation List is Deprecated', program, cause);
        this.name = 'ReservationListDeprecated';
        this.code = 0x78; // 120
    }
}
exports.ReservationListDeprecatedError = ReservationListDeprecatedError;
codeToErrorMap.set(0x78, ReservationListDeprecatedError);
nameToErrorMap.set('ReservationListDeprecated', ReservationListDeprecatedError);
/** PrintEditionDoesNotMatchMasterEdition: Print Edition does not match Master Edition */
class PrintEditionDoesNotMatchMasterEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Print Edition does not match Master Edition', program, cause);
        this.name = 'PrintEditionDoesNotMatchMasterEdition';
        this.code = 0x79; // 121
    }
}
exports.PrintEditionDoesNotMatchMasterEditionError = PrintEditionDoesNotMatchMasterEditionError;
codeToErrorMap.set(0x79, PrintEditionDoesNotMatchMasterEditionError);
nameToErrorMap.set('PrintEditionDoesNotMatchMasterEdition', PrintEditionDoesNotMatchMasterEditionError);
/** EditionNumberGreaterThanMaxSupply: Edition Number greater than max supply */
class EditionNumberGreaterThanMaxSupplyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Edition Number greater than max supply', program, cause);
        this.name = 'EditionNumberGreaterThanMaxSupply';
        this.code = 0x7a; // 122
    }
}
exports.EditionNumberGreaterThanMaxSupplyError = EditionNumberGreaterThanMaxSupplyError;
codeToErrorMap.set(0x7a, EditionNumberGreaterThanMaxSupplyError);
nameToErrorMap.set('EditionNumberGreaterThanMaxSupply', EditionNumberGreaterThanMaxSupplyError);
/** MustUnverify: Must unverify before migrating collections. */
class MustUnverifyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Must unverify before migrating collections.', program, cause);
        this.name = 'MustUnverify';
        this.code = 0x7b; // 123
    }
}
exports.MustUnverifyError = MustUnverifyError;
codeToErrorMap.set(0x7b, MustUnverifyError);
nameToErrorMap.set('MustUnverify', MustUnverifyError);
/** InvalidEscrowBumpSeed: Invalid Escrow Account Bump Seed */
class InvalidEscrowBumpSeedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Escrow Account Bump Seed', program, cause);
        this.name = 'InvalidEscrowBumpSeed';
        this.code = 0x7c; // 124
    }
}
exports.InvalidEscrowBumpSeedError = InvalidEscrowBumpSeedError;
codeToErrorMap.set(0x7c, InvalidEscrowBumpSeedError);
nameToErrorMap.set('InvalidEscrowBumpSeed', InvalidEscrowBumpSeedError);
/** MustBeEscrowAuthority: Must Escrow Authority */
class MustBeEscrowAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Must Escrow Authority', program, cause);
        this.name = 'MustBeEscrowAuthority';
        this.code = 0x7d; // 125
    }
}
exports.MustBeEscrowAuthorityError = MustBeEscrowAuthorityError;
codeToErrorMap.set(0x7d, MustBeEscrowAuthorityError);
nameToErrorMap.set('MustBeEscrowAuthority', MustBeEscrowAuthorityError);
/** InvalidSystemProgram: Invalid System Program */
class InvalidSystemProgramError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid System Program', program, cause);
        this.name = 'InvalidSystemProgram';
        this.code = 0x7e; // 126
    }
}
exports.InvalidSystemProgramError = InvalidSystemProgramError;
codeToErrorMap.set(0x7e, InvalidSystemProgramError);
nameToErrorMap.set('InvalidSystemProgram', InvalidSystemProgramError);
/** MustBeNonFungible: Must be a Non Fungible Token */
class MustBeNonFungibleError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Must be a Non Fungible Token', program, cause);
        this.name = 'MustBeNonFungible';
        this.code = 0x7f; // 127
    }
}
exports.MustBeNonFungibleError = MustBeNonFungibleError;
codeToErrorMap.set(0x7f, MustBeNonFungibleError);
nameToErrorMap.set('MustBeNonFungible', MustBeNonFungibleError);
/** InsufficientTokens: Insufficient tokens for transfer */
class InsufficientTokensError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Insufficient tokens for transfer', program, cause);
        this.name = 'InsufficientTokens';
        this.code = 0x80; // 128
    }
}
exports.InsufficientTokensError = InsufficientTokensError;
codeToErrorMap.set(0x80, InsufficientTokensError);
nameToErrorMap.set('InsufficientTokens', InsufficientTokensError);
/** BorshSerializationError: Borsh Serialization Error */
class BorshSerializationErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Borsh Serialization Error', program, cause);
        this.name = 'BorshSerializationError';
        this.code = 0x81; // 129
    }
}
exports.BorshSerializationErrorError = BorshSerializationErrorError;
codeToErrorMap.set(0x81, BorshSerializationErrorError);
nameToErrorMap.set('BorshSerializationError', BorshSerializationErrorError);
/** NoFreezeAuthoritySet: Cannot create NFT with no Freeze Authority. */
class NoFreezeAuthoritySetError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot create NFT with no Freeze Authority.', program, cause);
        this.name = 'NoFreezeAuthoritySet';
        this.code = 0x82; // 130
    }
}
exports.NoFreezeAuthoritySetError = NoFreezeAuthoritySetError;
codeToErrorMap.set(0x82, NoFreezeAuthoritySetError);
nameToErrorMap.set('NoFreezeAuthoritySet', NoFreezeAuthoritySetError);
/** InvalidCollectionSizeChange: Invalid collection size change */
class InvalidCollectionSizeChangeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid collection size change', program, cause);
        this.name = 'InvalidCollectionSizeChange';
        this.code = 0x83; // 131
    }
}
exports.InvalidCollectionSizeChangeError = InvalidCollectionSizeChangeError;
codeToErrorMap.set(0x83, InvalidCollectionSizeChangeError);
nameToErrorMap.set('InvalidCollectionSizeChange', InvalidCollectionSizeChangeError);
/** InvalidBubblegumSigner: Invalid bubblegum signer */
class InvalidBubblegumSignerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid bubblegum signer', program, cause);
        this.name = 'InvalidBubblegumSigner';
        this.code = 0x84; // 132
    }
}
exports.InvalidBubblegumSignerError = InvalidBubblegumSignerError;
codeToErrorMap.set(0x84, InvalidBubblegumSignerError);
nameToErrorMap.set('InvalidBubblegumSigner', InvalidBubblegumSignerError);
/** EscrowParentHasDelegate: Escrow parent cannot have a delegate */
class EscrowParentHasDelegateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Escrow parent cannot have a delegate', program, cause);
        this.name = 'EscrowParentHasDelegate';
        this.code = 0x85; // 133
    }
}
exports.EscrowParentHasDelegateError = EscrowParentHasDelegateError;
codeToErrorMap.set(0x85, EscrowParentHasDelegateError);
nameToErrorMap.set('EscrowParentHasDelegate', EscrowParentHasDelegateError);
/** MintIsNotSigner: Mint needs to be signer to initialize the account */
class MintIsNotSignerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Mint needs to be signer to initialize the account', program, cause);
        this.name = 'MintIsNotSigner';
        this.code = 0x86; // 134
    }
}
exports.MintIsNotSignerError = MintIsNotSignerError;
codeToErrorMap.set(0x86, MintIsNotSignerError);
nameToErrorMap.set('MintIsNotSigner', MintIsNotSignerError);
/** InvalidTokenStandard: Invalid token standard */
class InvalidTokenStandardError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid token standard', program, cause);
        this.name = 'InvalidTokenStandard';
        this.code = 0x87; // 135
    }
}
exports.InvalidTokenStandardError = InvalidTokenStandardError;
codeToErrorMap.set(0x87, InvalidTokenStandardError);
nameToErrorMap.set('InvalidTokenStandard', InvalidTokenStandardError);
/** InvalidMintForTokenStandard: Invalid mint account for specified token standard */
class InvalidMintForTokenStandardError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid mint account for specified token standard', program, cause);
        this.name = 'InvalidMintForTokenStandard';
        this.code = 0x88; // 136
    }
}
exports.InvalidMintForTokenStandardError = InvalidMintForTokenStandardError;
codeToErrorMap.set(0x88, InvalidMintForTokenStandardError);
nameToErrorMap.set('InvalidMintForTokenStandard', InvalidMintForTokenStandardError);
/** InvalidAuthorizationRules: Invalid authorization rules account */
class InvalidAuthorizationRulesError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid authorization rules account', program, cause);
        this.name = 'InvalidAuthorizationRules';
        this.code = 0x89; // 137
    }
}
exports.InvalidAuthorizationRulesError = InvalidAuthorizationRulesError;
codeToErrorMap.set(0x89, InvalidAuthorizationRulesError);
nameToErrorMap.set('InvalidAuthorizationRules', InvalidAuthorizationRulesError);
/** MissingAuthorizationRules: Missing authorization rules account */
class MissingAuthorizationRulesError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing authorization rules account', program, cause);
        this.name = 'MissingAuthorizationRules';
        this.code = 0x8a; // 138
    }
}
exports.MissingAuthorizationRulesError = MissingAuthorizationRulesError;
codeToErrorMap.set(0x8a, MissingAuthorizationRulesError);
nameToErrorMap.set('MissingAuthorizationRules', MissingAuthorizationRulesError);
/** MissingProgrammableConfig: Missing programmable configuration */
class MissingProgrammableConfigError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing programmable configuration', program, cause);
        this.name = 'MissingProgrammableConfig';
        this.code = 0x8b; // 139
    }
}
exports.MissingProgrammableConfigError = MissingProgrammableConfigError;
codeToErrorMap.set(0x8b, MissingProgrammableConfigError);
nameToErrorMap.set('MissingProgrammableConfig', MissingProgrammableConfigError);
/** InvalidProgrammableConfig: Invalid programmable configuration */
class InvalidProgrammableConfigError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid programmable configuration', program, cause);
        this.name = 'InvalidProgrammableConfig';
        this.code = 0x8c; // 140
    }
}
exports.InvalidProgrammableConfigError = InvalidProgrammableConfigError;
codeToErrorMap.set(0x8c, InvalidProgrammableConfigError);
nameToErrorMap.set('InvalidProgrammableConfig', InvalidProgrammableConfigError);
/** DelegateAlreadyExists: Delegate already exists */
class DelegateAlreadyExistsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Delegate already exists', program, cause);
        this.name = 'DelegateAlreadyExists';
        this.code = 0x8d; // 141
    }
}
exports.DelegateAlreadyExistsError = DelegateAlreadyExistsError;
codeToErrorMap.set(0x8d, DelegateAlreadyExistsError);
nameToErrorMap.set('DelegateAlreadyExists', DelegateAlreadyExistsError);
/** DelegateNotFound: Delegate not found */
class DelegateNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Delegate not found', program, cause);
        this.name = 'DelegateNotFound';
        this.code = 0x8e; // 142
    }
}
exports.DelegateNotFoundError = DelegateNotFoundError;
codeToErrorMap.set(0x8e, DelegateNotFoundError);
nameToErrorMap.set('DelegateNotFound', DelegateNotFoundError);
/** MissingAccountInBuilder: Required account not set in instruction builder */
class MissingAccountInBuilderError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Required account not set in instruction builder', program, cause);
        this.name = 'MissingAccountInBuilder';
        this.code = 0x8f; // 143
    }
}
exports.MissingAccountInBuilderError = MissingAccountInBuilderError;
codeToErrorMap.set(0x8f, MissingAccountInBuilderError);
nameToErrorMap.set('MissingAccountInBuilder', MissingAccountInBuilderError);
/** MissingArgumentInBuilder: Required argument not set in instruction builder */
class MissingArgumentInBuilderError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Required argument not set in instruction builder', program, cause);
        this.name = 'MissingArgumentInBuilder';
        this.code = 0x90; // 144
    }
}
exports.MissingArgumentInBuilderError = MissingArgumentInBuilderError;
codeToErrorMap.set(0x90, MissingArgumentInBuilderError);
nameToErrorMap.set('MissingArgumentInBuilder', MissingArgumentInBuilderError);
/** FeatureNotSupported: Feature not supported currently */
class FeatureNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Feature not supported currently', program, cause);
        this.name = 'FeatureNotSupported';
        this.code = 0x91; // 145
    }
}
exports.FeatureNotSupportedError = FeatureNotSupportedError;
codeToErrorMap.set(0x91, FeatureNotSupportedError);
nameToErrorMap.set('FeatureNotSupported', FeatureNotSupportedError);
/** InvalidSystemWallet: Invalid system wallet */
class InvalidSystemWalletError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid system wallet', program, cause);
        this.name = 'InvalidSystemWallet';
        this.code = 0x92; // 146
    }
}
exports.InvalidSystemWalletError = InvalidSystemWalletError;
codeToErrorMap.set(0x92, InvalidSystemWalletError);
nameToErrorMap.set('InvalidSystemWallet', InvalidSystemWalletError);
/** OnlySaleDelegateCanTransfer: Only the sale delegate can transfer while its set */
class OnlySaleDelegateCanTransferError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Only the sale delegate can transfer while its set', program, cause);
        this.name = 'OnlySaleDelegateCanTransfer';
        this.code = 0x93; // 147
    }
}
exports.OnlySaleDelegateCanTransferError = OnlySaleDelegateCanTransferError;
codeToErrorMap.set(0x93, OnlySaleDelegateCanTransferError);
nameToErrorMap.set('OnlySaleDelegateCanTransfer', OnlySaleDelegateCanTransferError);
/** MissingTokenAccount: Missing token account */
class MissingTokenAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing token account', program, cause);
        this.name = 'MissingTokenAccount';
        this.code = 0x94; // 148
    }
}
exports.MissingTokenAccountError = MissingTokenAccountError;
codeToErrorMap.set(0x94, MissingTokenAccountError);
nameToErrorMap.set('MissingTokenAccount', MissingTokenAccountError);
/** MissingSplTokenProgram: Missing SPL token program */
class MissingSplTokenProgramError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing SPL token program', program, cause);
        this.name = 'MissingSplTokenProgram';
        this.code = 0x95; // 149
    }
}
exports.MissingSplTokenProgramError = MissingSplTokenProgramError;
codeToErrorMap.set(0x95, MissingSplTokenProgramError);
nameToErrorMap.set('MissingSplTokenProgram', MissingSplTokenProgramError);
/** MissingAuthorizationRulesProgram: Missing authorization rules program */
class MissingAuthorizationRulesProgramError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing authorization rules program', program, cause);
        this.name = 'MissingAuthorizationRulesProgram';
        this.code = 0x96; // 150
    }
}
exports.MissingAuthorizationRulesProgramError = MissingAuthorizationRulesProgramError;
codeToErrorMap.set(0x96, MissingAuthorizationRulesProgramError);
nameToErrorMap.set('MissingAuthorizationRulesProgram', MissingAuthorizationRulesProgramError);
/** InvalidDelegateRoleForTransfer: Invalid delegate role for transfer */
class InvalidDelegateRoleForTransferError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid delegate role for transfer', program, cause);
        this.name = 'InvalidDelegateRoleForTransfer';
        this.code = 0x97; // 151
    }
}
exports.InvalidDelegateRoleForTransferError = InvalidDelegateRoleForTransferError;
codeToErrorMap.set(0x97, InvalidDelegateRoleForTransferError);
nameToErrorMap.set('InvalidDelegateRoleForTransfer', InvalidDelegateRoleForTransferError);
/** InvalidTransferAuthority: Invalid transfer authority */
class InvalidTransferAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid transfer authority', program, cause);
        this.name = 'InvalidTransferAuthority';
        this.code = 0x98; // 152
    }
}
exports.InvalidTransferAuthorityError = InvalidTransferAuthorityError;
codeToErrorMap.set(0x98, InvalidTransferAuthorityError);
nameToErrorMap.set('InvalidTransferAuthority', InvalidTransferAuthorityError);
/** InstructionNotSupported: Instruction not supported for ProgrammableNonFungible assets */
class InstructionNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Instruction not supported for ProgrammableNonFungible assets', program, cause);
        this.name = 'InstructionNotSupported';
        this.code = 0x99; // 153
    }
}
exports.InstructionNotSupportedError = InstructionNotSupportedError;
codeToErrorMap.set(0x99, InstructionNotSupportedError);
nameToErrorMap.set('InstructionNotSupported', InstructionNotSupportedError);
/** KeyMismatch: Public key does not match expected value */
class KeyMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Public key does not match expected value', program, cause);
        this.name = 'KeyMismatch';
        this.code = 0x9a; // 154
    }
}
exports.KeyMismatchError = KeyMismatchError;
codeToErrorMap.set(0x9a, KeyMismatchError);
nameToErrorMap.set('KeyMismatch', KeyMismatchError);
/** LockedToken: Token is locked */
class LockedTokenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token is locked', program, cause);
        this.name = 'LockedToken';
        this.code = 0x9b; // 155
    }
}
exports.LockedTokenError = LockedTokenError;
codeToErrorMap.set(0x9b, LockedTokenError);
nameToErrorMap.set('LockedToken', LockedTokenError);
/** UnlockedToken: Token is unlocked */
class UnlockedTokenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token is unlocked', program, cause);
        this.name = 'UnlockedToken';
        this.code = 0x9c; // 156
    }
}
exports.UnlockedTokenError = UnlockedTokenError;
codeToErrorMap.set(0x9c, UnlockedTokenError);
nameToErrorMap.set('UnlockedToken', UnlockedTokenError);
/** MissingDelegateRole: Missing delegate role */
class MissingDelegateRoleError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing delegate role', program, cause);
        this.name = 'MissingDelegateRole';
        this.code = 0x9d; // 157
    }
}
exports.MissingDelegateRoleError = MissingDelegateRoleError;
codeToErrorMap.set(0x9d, MissingDelegateRoleError);
nameToErrorMap.set('MissingDelegateRole', MissingDelegateRoleError);
/** InvalidAuthorityType: Invalid authority type */
class InvalidAuthorityTypeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid authority type', program, cause);
        this.name = 'InvalidAuthorityType';
        this.code = 0x9e; // 158
    }
}
exports.InvalidAuthorityTypeError = InvalidAuthorityTypeError;
codeToErrorMap.set(0x9e, InvalidAuthorityTypeError);
nameToErrorMap.set('InvalidAuthorityType', InvalidAuthorityTypeError);
/** MissingTokenRecord: Missing token record account */
class MissingTokenRecordError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing token record account', program, cause);
        this.name = 'MissingTokenRecord';
        this.code = 0x9f; // 159
    }
}
exports.MissingTokenRecordError = MissingTokenRecordError;
codeToErrorMap.set(0x9f, MissingTokenRecordError);
nameToErrorMap.set('MissingTokenRecord', MissingTokenRecordError);
/** MintSupplyMustBeZero: Mint supply must be zero for programmable assets */
class MintSupplyMustBeZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Mint supply must be zero for programmable assets', program, cause);
        this.name = 'MintSupplyMustBeZero';
        this.code = 0xa0; // 160
    }
}
exports.MintSupplyMustBeZeroError = MintSupplyMustBeZeroError;
codeToErrorMap.set(0xa0, MintSupplyMustBeZeroError);
nameToErrorMap.set('MintSupplyMustBeZero', MintSupplyMustBeZeroError);
/** DataIsEmptyOrZeroed: Data is empty or zeroed */
class DataIsEmptyOrZeroedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Data is empty or zeroed', program, cause);
        this.name = 'DataIsEmptyOrZeroed';
        this.code = 0xa1; // 161
    }
}
exports.DataIsEmptyOrZeroedError = DataIsEmptyOrZeroedError;
codeToErrorMap.set(0xa1, DataIsEmptyOrZeroedError);
nameToErrorMap.set('DataIsEmptyOrZeroed', DataIsEmptyOrZeroedError);
/** MissingTokenOwnerAccount: Missing token owner */
class MissingTokenOwnerAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing token owner', program, cause);
        this.name = 'MissingTokenOwnerAccount';
        this.code = 0xa2; // 162
    }
}
exports.MissingTokenOwnerAccountError = MissingTokenOwnerAccountError;
codeToErrorMap.set(0xa2, MissingTokenOwnerAccountError);
nameToErrorMap.set('MissingTokenOwnerAccount', MissingTokenOwnerAccountError);
/** InvalidMasterEditionAccountLength: Master edition account has an invalid length */
class InvalidMasterEditionAccountLengthError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Master edition account has an invalid length', program, cause);
        this.name = 'InvalidMasterEditionAccountLength';
        this.code = 0xa3; // 163
    }
}
exports.InvalidMasterEditionAccountLengthError = InvalidMasterEditionAccountLengthError;
codeToErrorMap.set(0xa3, InvalidMasterEditionAccountLengthError);
nameToErrorMap.set('InvalidMasterEditionAccountLength', InvalidMasterEditionAccountLengthError);
/** IncorrectTokenState: Incorrect token state */
class IncorrectTokenStateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Incorrect token state', program, cause);
        this.name = 'IncorrectTokenState';
        this.code = 0xa4; // 164
    }
}
exports.IncorrectTokenStateError = IncorrectTokenStateError;
codeToErrorMap.set(0xa4, IncorrectTokenStateError);
nameToErrorMap.set('IncorrectTokenState', IncorrectTokenStateError);
/** InvalidDelegateRole: Invalid delegate role */
class InvalidDelegateRoleError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid delegate role', program, cause);
        this.name = 'InvalidDelegateRole';
        this.code = 0xa5; // 165
    }
}
exports.InvalidDelegateRoleError = InvalidDelegateRoleError;
codeToErrorMap.set(0xa5, InvalidDelegateRoleError);
nameToErrorMap.set('InvalidDelegateRole', InvalidDelegateRoleError);
/** MissingPrintSupply: Print supply is required for non-fungibles */
class MissingPrintSupplyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Print supply is required for non-fungibles', program, cause);
        this.name = 'MissingPrintSupply';
        this.code = 0xa6; // 166
    }
}
exports.MissingPrintSupplyError = MissingPrintSupplyError;
codeToErrorMap.set(0xa6, MissingPrintSupplyError);
nameToErrorMap.set('MissingPrintSupply', MissingPrintSupplyError);
/** MissingMasterEditionAccount: Missing master edition account */
class MissingMasterEditionAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing master edition account', program, cause);
        this.name = 'MissingMasterEditionAccount';
        this.code = 0xa7; // 167
    }
}
exports.MissingMasterEditionAccountError = MissingMasterEditionAccountError;
codeToErrorMap.set(0xa7, MissingMasterEditionAccountError);
nameToErrorMap.set('MissingMasterEditionAccount', MissingMasterEditionAccountError);
/** AmountMustBeGreaterThanZero: Amount must be greater than zero */
class AmountMustBeGreaterThanZeroError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Amount must be greater than zero', program, cause);
        this.name = 'AmountMustBeGreaterThanZero';
        this.code = 0xa8; // 168
    }
}
exports.AmountMustBeGreaterThanZeroError = AmountMustBeGreaterThanZeroError;
codeToErrorMap.set(0xa8, AmountMustBeGreaterThanZeroError);
nameToErrorMap.set('AmountMustBeGreaterThanZero', AmountMustBeGreaterThanZeroError);
/** InvalidDelegateArgs: Invalid delegate args */
class InvalidDelegateArgsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid delegate args', program, cause);
        this.name = 'InvalidDelegateArgs';
        this.code = 0xa9; // 169
    }
}
exports.InvalidDelegateArgsError = InvalidDelegateArgsError;
codeToErrorMap.set(0xa9, InvalidDelegateArgsError);
nameToErrorMap.set('InvalidDelegateArgs', InvalidDelegateArgsError);
/** MissingLockedTransferAddress: Missing address for locked transfer */
class MissingLockedTransferAddressError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing address for locked transfer', program, cause);
        this.name = 'MissingLockedTransferAddress';
        this.code = 0xaa; // 170
    }
}
exports.MissingLockedTransferAddressError = MissingLockedTransferAddressError;
codeToErrorMap.set(0xaa, MissingLockedTransferAddressError);
nameToErrorMap.set('MissingLockedTransferAddress', MissingLockedTransferAddressError);
/** InvalidLockedTransferAddress: Invalid destination address for locked transfer */
class InvalidLockedTransferAddressError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid destination address for locked transfer', program, cause);
        this.name = 'InvalidLockedTransferAddress';
        this.code = 0xab; // 171
    }
}
exports.InvalidLockedTransferAddressError = InvalidLockedTransferAddressError;
codeToErrorMap.set(0xab, InvalidLockedTransferAddressError);
nameToErrorMap.set('InvalidLockedTransferAddress', InvalidLockedTransferAddressError);
/** DataIncrementLimitExceeded: Exceeded account realloc increase limit */
class DataIncrementLimitExceededError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Exceeded account realloc increase limit', program, cause);
        this.name = 'DataIncrementLimitExceeded';
        this.code = 0xac; // 172
    }
}
exports.DataIncrementLimitExceededError = DataIncrementLimitExceededError;
codeToErrorMap.set(0xac, DataIncrementLimitExceededError);
nameToErrorMap.set('DataIncrementLimitExceeded', DataIncrementLimitExceededError);
/** CannotUpdateAssetWithDelegate: Cannot update the rule set of a programmable asset that has a delegate */
class CannotUpdateAssetWithDelegateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot update the rule set of a programmable asset that has a delegate', program, cause);
        this.name = 'CannotUpdateAssetWithDelegate';
        this.code = 0xad; // 173
    }
}
exports.CannotUpdateAssetWithDelegateError = CannotUpdateAssetWithDelegateError;
codeToErrorMap.set(0xad, CannotUpdateAssetWithDelegateError);
nameToErrorMap.set('CannotUpdateAssetWithDelegate', CannotUpdateAssetWithDelegateError);
/** InvalidAmount: Invalid token amount for this operation or token standard */
class InvalidAmountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid token amount for this operation or token standard', program, cause);
        this.name = 'InvalidAmount';
        this.code = 0xae; // 174
    }
}
exports.InvalidAmountError = InvalidAmountError;
codeToErrorMap.set(0xae, InvalidAmountError);
nameToErrorMap.set('InvalidAmount', InvalidAmountError);
/** MissingMasterEditionMintAccount: Missing master edition mint account */
class MissingMasterEditionMintAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing master edition mint account', program, cause);
        this.name = 'MissingMasterEditionMintAccount';
        this.code = 0xaf; // 175
    }
}
exports.MissingMasterEditionMintAccountError = MissingMasterEditionMintAccountError;
codeToErrorMap.set(0xaf, MissingMasterEditionMintAccountError);
nameToErrorMap.set('MissingMasterEditionMintAccount', MissingMasterEditionMintAccountError);
/** MissingMasterEditionTokenAccount: Missing master edition token account */
class MissingMasterEditionTokenAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing master edition token account', program, cause);
        this.name = 'MissingMasterEditionTokenAccount';
        this.code = 0xb0; // 176
    }
}
exports.MissingMasterEditionTokenAccountError = MissingMasterEditionTokenAccountError;
codeToErrorMap.set(0xb0, MissingMasterEditionTokenAccountError);
nameToErrorMap.set('MissingMasterEditionTokenAccount', MissingMasterEditionTokenAccountError);
/** MissingEditionMarkerAccount: Missing edition marker account */
class MissingEditionMarkerAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing edition marker account', program, cause);
        this.name = 'MissingEditionMarkerAccount';
        this.code = 0xb1; // 177
    }
}
exports.MissingEditionMarkerAccountError = MissingEditionMarkerAccountError;
codeToErrorMap.set(0xb1, MissingEditionMarkerAccountError);
nameToErrorMap.set('MissingEditionMarkerAccount', MissingEditionMarkerAccountError);
/** CannotBurnWithDelegate: Cannot burn while persistent delegate is set */
class CannotBurnWithDelegateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot burn while persistent delegate is set', program, cause);
        this.name = 'CannotBurnWithDelegate';
        this.code = 0xb2; // 178
    }
}
exports.CannotBurnWithDelegateError = CannotBurnWithDelegateError;
codeToErrorMap.set(0xb2, CannotBurnWithDelegateError);
nameToErrorMap.set('CannotBurnWithDelegate', CannotBurnWithDelegateError);
/** MissingEdition: Missing edition account */
class MissingEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing edition account', program, cause);
        this.name = 'MissingEdition';
        this.code = 0xb3; // 179
    }
}
exports.MissingEditionError = MissingEditionError;
codeToErrorMap.set(0xb3, MissingEditionError);
nameToErrorMap.set('MissingEdition', MissingEditionError);
/** InvalidAssociatedTokenAccountProgram: Invalid Associated Token Account Program */
class InvalidAssociatedTokenAccountProgramError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Associated Token Account Program', program, cause);
        this.name = 'InvalidAssociatedTokenAccountProgram';
        this.code = 0xb4; // 180
    }
}
exports.InvalidAssociatedTokenAccountProgramError = InvalidAssociatedTokenAccountProgramError;
codeToErrorMap.set(0xb4, InvalidAssociatedTokenAccountProgramError);
nameToErrorMap.set('InvalidAssociatedTokenAccountProgram', InvalidAssociatedTokenAccountProgramError);
/** InvalidInstructionsSysvar: Invalid InstructionsSysvar */
class InvalidInstructionsSysvarError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid InstructionsSysvar', program, cause);
        this.name = 'InvalidInstructionsSysvar';
        this.code = 0xb5; // 181
    }
}
exports.InvalidInstructionsSysvarError = InvalidInstructionsSysvarError;
codeToErrorMap.set(0xb5, InvalidInstructionsSysvarError);
nameToErrorMap.set('InvalidInstructionsSysvar', InvalidInstructionsSysvarError);
/** InvalidParentAccounts: Invalid or Unneeded parent accounts */
class InvalidParentAccountsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid or Unneeded parent accounts', program, cause);
        this.name = 'InvalidParentAccounts';
        this.code = 0xb6; // 182
    }
}
exports.InvalidParentAccountsError = InvalidParentAccountsError;
codeToErrorMap.set(0xb6, InvalidParentAccountsError);
nameToErrorMap.set('InvalidParentAccounts', InvalidParentAccountsError);
/** InvalidUpdateArgs: Authority cannot apply all update args */
class InvalidUpdateArgsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Authority cannot apply all update args', program, cause);
        this.name = 'InvalidUpdateArgs';
        this.code = 0xb7; // 183
    }
}
exports.InvalidUpdateArgsError = InvalidUpdateArgsError;
codeToErrorMap.set(0xb7, InvalidUpdateArgsError);
nameToErrorMap.set('InvalidUpdateArgs', InvalidUpdateArgsError);
/** InsufficientTokenBalance: Token account does not have enough tokens */
class InsufficientTokenBalanceError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Token account does not have enough tokens', program, cause);
        this.name = 'InsufficientTokenBalance';
        this.code = 0xb8; // 184
    }
}
exports.InsufficientTokenBalanceError = InsufficientTokenBalanceError;
codeToErrorMap.set(0xb8, InsufficientTokenBalanceError);
nameToErrorMap.set('InsufficientTokenBalance', InsufficientTokenBalanceError);
/** MissingCollectionMint: Missing collection account */
class MissingCollectionMintError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection account', program, cause);
        this.name = 'MissingCollectionMint';
        this.code = 0xb9; // 185
    }
}
exports.MissingCollectionMintError = MissingCollectionMintError;
codeToErrorMap.set(0xb9, MissingCollectionMintError);
nameToErrorMap.set('MissingCollectionMint', MissingCollectionMintError);
/** MissingCollectionMasterEdition: Missing collection master edition account */
class MissingCollectionMasterEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection master edition account', program, cause);
        this.name = 'MissingCollectionMasterEdition';
        this.code = 0xba; // 186
    }
}
exports.MissingCollectionMasterEditionError = MissingCollectionMasterEditionError;
codeToErrorMap.set(0xba, MissingCollectionMasterEditionError);
nameToErrorMap.set('MissingCollectionMasterEdition', MissingCollectionMasterEditionError);
/** InvalidTokenRecord: Invalid token record account */
class InvalidTokenRecordError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid token record account', program, cause);
        this.name = 'InvalidTokenRecord';
        this.code = 0xbb; // 187
    }
}
exports.InvalidTokenRecordError = InvalidTokenRecordError;
codeToErrorMap.set(0xbb, InvalidTokenRecordError);
nameToErrorMap.set('InvalidTokenRecord', InvalidTokenRecordError);
/** InvalidCloseAuthority: The close authority needs to be revoked by the Utility Delegate */
class InvalidCloseAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The close authority needs to be revoked by the Utility Delegate', program, cause);
        this.name = 'InvalidCloseAuthority';
        this.code = 0xbc; // 188
    }
}
exports.InvalidCloseAuthorityError = InvalidCloseAuthorityError;
codeToErrorMap.set(0xbc, InvalidCloseAuthorityError);
nameToErrorMap.set('InvalidCloseAuthority', InvalidCloseAuthorityError);
/** InvalidInstruction: Invalid or removed instruction */
class InvalidInstructionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid or removed instruction', program, cause);
        this.name = 'InvalidInstruction';
        this.code = 0xbd; // 189
    }
}
exports.InvalidInstructionError = InvalidInstructionError;
codeToErrorMap.set(0xbd, InvalidInstructionError);
nameToErrorMap.set('InvalidInstruction', InvalidInstructionError);
/** MissingDelegateRecord: Missing delegate record */
class MissingDelegateRecordError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing delegate record', program, cause);
        this.name = 'MissingDelegateRecord';
        this.code = 0xbe; // 190
    }
}
exports.MissingDelegateRecordError = MissingDelegateRecordError;
codeToErrorMap.set(0xbe, MissingDelegateRecordError);
nameToErrorMap.set('MissingDelegateRecord', MissingDelegateRecordError);
/** InvalidFeeAccount */
class InvalidFeeAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InvalidFeeAccount';
        this.code = 0xbf; // 191
    }
}
exports.InvalidFeeAccountError = InvalidFeeAccountError;
codeToErrorMap.set(0xbf, InvalidFeeAccountError);
nameToErrorMap.set('InvalidFeeAccount', InvalidFeeAccountError);
/** InvalidMetadataFlags */
class InvalidMetadataFlagsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('', program, cause);
        this.name = 'InvalidMetadataFlags';
        this.code = 0xc0; // 192
    }
}
exports.InvalidMetadataFlagsError = InvalidMetadataFlagsError;
codeToErrorMap.set(0xc0, InvalidMetadataFlagsError);
nameToErrorMap.set('InvalidMetadataFlags', InvalidMetadataFlagsError);
/** CannotChangeUpdateAuthorityWithDelegate: Cannot change the update authority with a delegate */
class CannotChangeUpdateAuthorityWithDelegateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot change the update authority with a delegate', program, cause);
        this.name = 'CannotChangeUpdateAuthorityWithDelegate';
        this.code = 0xc1; // 193
    }
}
exports.CannotChangeUpdateAuthorityWithDelegateError = CannotChangeUpdateAuthorityWithDelegateError;
codeToErrorMap.set(0xc1, CannotChangeUpdateAuthorityWithDelegateError);
nameToErrorMap.set('CannotChangeUpdateAuthorityWithDelegate', CannotChangeUpdateAuthorityWithDelegateError);
/** InvalidMintExtensionType: Invalid mint extension type */
class InvalidMintExtensionTypeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid mint extension type', program, cause);
        this.name = 'InvalidMintExtensionType';
        this.code = 0xc2; // 194
    }
}
exports.InvalidMintExtensionTypeError = InvalidMintExtensionTypeError;
codeToErrorMap.set(0xc2, InvalidMintExtensionTypeError);
nameToErrorMap.set('InvalidMintExtensionType', InvalidMintExtensionTypeError);
/** InvalidMintCloseAuthority: Invalid mint close authority */
class InvalidMintCloseAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid mint close authority', program, cause);
        this.name = 'InvalidMintCloseAuthority';
        this.code = 0xc3; // 195
    }
}
exports.InvalidMintCloseAuthorityError = InvalidMintCloseAuthorityError;
codeToErrorMap.set(0xc3, InvalidMintCloseAuthorityError);
nameToErrorMap.set('InvalidMintCloseAuthority', InvalidMintCloseAuthorityError);
/** InvalidMetadataPointer: Invalid metadata pointer */
class InvalidMetadataPointerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid metadata pointer', program, cause);
        this.name = 'InvalidMetadataPointer';
        this.code = 0xc4; // 196
    }
}
exports.InvalidMetadataPointerError = InvalidMetadataPointerError;
codeToErrorMap.set(0xc4, InvalidMetadataPointerError);
nameToErrorMap.set('InvalidMetadataPointer', InvalidMetadataPointerError);
/** InvalidTokenExtensionType: Invalid token extension type */
class InvalidTokenExtensionTypeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid token extension type', program, cause);
        this.name = 'InvalidTokenExtensionType';
        this.code = 0xc5; // 197
    }
}
exports.InvalidTokenExtensionTypeError = InvalidTokenExtensionTypeError;
codeToErrorMap.set(0xc5, InvalidTokenExtensionTypeError);
nameToErrorMap.set('InvalidTokenExtensionType', InvalidTokenExtensionTypeError);
/** MissingImmutableOwnerExtension: Missing immutable owner extension */
class MissingImmutableOwnerExtensionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing immutable owner extension', program, cause);
        this.name = 'MissingImmutableOwnerExtension';
        this.code = 0xc6; // 198
    }
}
exports.MissingImmutableOwnerExtensionError = MissingImmutableOwnerExtensionError;
codeToErrorMap.set(0xc6, MissingImmutableOwnerExtensionError);
nameToErrorMap.set('MissingImmutableOwnerExtension', MissingImmutableOwnerExtensionError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getMplTokenMetadataErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplTokenMetadataErrorFromCode = getMplTokenMetadataErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getMplTokenMetadataErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplTokenMetadataErrorFromName = getMplTokenMetadataErrorFromName;
//# sourceMappingURL=mplTokenMetadata.js.map