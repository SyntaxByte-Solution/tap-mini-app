'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.cjs');
var SdkError = require('../../errors/SdkError.cjs');
var Disposable = require('../../utils/Disposable.cjs');

/**
 * @group Modules
 */
class OperationClient {
  /**
   * Maps the name of an operation with its operation handler.
   * Whilst the types on the Map are relatively loose, we ensure
   * operations match with their handlers when registering them.
   */

  constructor(metaplex) {
    _rollupPluginBabelHelpers.defineProperty(this, "operationHandlers", new Map());
    this.metaplex = metaplex;
  }
  register(operationConstructor, operationHandler) {
    this.operationHandlers.set(operationConstructor.key, operationHandler);
    return this;
  }
  get(operation) {
    const operationHandler = this.operationHandlers.get(operation.key);
    if (!operationHandler) {
      throw new SdkError.OperationHandlerMissingError(operation.key);
    }
    return operationHandler;
  }
  async execute(operation, options = {}) {
    const operationHandler = this.get(operation);
    const signal = options.signal ?? new AbortController().signal;
    return new Disposable.Disposable(signal).run(scope => operationHandler.handle(operation, this.metaplex, this.getOperationScope(options, scope)));
  }
  getOperationScope(options, scope) {
    if (!!options.commitment && !options.confirmOptions) {
      options.confirmOptions = {
        commitment: options.commitment
      };
    }
    const payer = options.payer ?? this.metaplex.rpc().getDefaultFeePayer();
    return {
      ...options,
      ...scope,
      payer
    };
  }
}

exports.OperationClient = OperationClient;
//# sourceMappingURL=OperationClient.cjs.map
