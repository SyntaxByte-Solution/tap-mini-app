"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumEthersV6 = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethereum_1 = __importDefault(require("../../tokens/ethereum"));
class EthereumEthersV6 extends ethereum_1.default {
    createTx(amount, to, _fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.w3signer;
            const tx = { to, from: this.address, value: amount.toString(), gasLimit: BigInt(0) };
            const estimatedGas = yield this.provider.estimateGas(tx);
            tx.gasLimit = estimatedGas;
            const txr = yield signer.populateTransaction(tx);
            return { tx: txr, txId: undefined };
        });
    }
    getTx(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.provider;
            const response = yield provider.getTransaction(txId);
            if (!response)
                throw new Error("Tx doesn't exist");
            if (!response.to)
                throw new Error(`Unable to resolve transactions ${txId} receiver`);
            return {
                from: response.from,
                to: response.to,
                blockHeight: response.blockNumber ? new bignumber_js_1.default(response.blockNumber) : undefined,
                amount: new bignumber_js_1.default(response.value.toString()),
                pending: response.blockNumber ? false : true,
                confirmed: (yield response.confirmations()) >= this.minConfirm,
            };
        });
    }
    ready() {
        const _super = Object.create(null, {
            ready: { get: () => super.ready }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.wallet;
            this.provider = provider;
            const signer = yield provider.getSigner();
            signer._signTypedData = (domain, types, value) => __awaiter(this, void 0, void 0, function* () { return signer.signTypedData(domain, types, value); });
            // @ts-expect-error fix
            provider.getSigner = () => signer;
            // @ts-expect-error fix
            this.wallet = provider;
            yield _super.ready.call(this);
        });
    }
}
exports.EthereumEthersV6 = EthereumEthersV6;
//# sourceMappingURL=ethersv6.js.map