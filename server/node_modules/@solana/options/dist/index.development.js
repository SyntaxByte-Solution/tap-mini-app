this.globalThis = this.globalThis || {};
this.globalThis.solanaWeb3 = (function (exports) {
  'use strict';

  // src/option.ts
  var some = (value) => ({ __option: "Some", value });
  var none = () => ({ __option: "None" });
  var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
  var isSome = (option) => option.__option === "Some";
  var isNone = (option) => option.__option === "None";

  // ../codecs-core/dist/index.browser.js
  function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
    if (bytes.length - offset <= 0) {
      throw new Error(`Codec [${codecDescription}] cannot decode empty byte arrays.`);
    }
  }
  function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
    const bytesLength = bytes.length - offset;
    if (bytesLength < expected) {
      throw new Error(`Codec [${codecDescription}] expected ${expected} bytes, got ${bytesLength}.`);
    }
  }
  function getEncodedSize(value, encoder) {
    return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
  }
  function createEncoder(encoder) {
    return Object.freeze({
      ...encoder,
      encode: (value) => {
        const bytes = new Uint8Array(getEncodedSize(value, encoder));
        encoder.write(value, bytes, 0);
        return bytes;
      }
    });
  }
  function createDecoder(decoder) {
    return Object.freeze({
      ...decoder,
      decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
    });
  }
  function isFixedSize(codec) {
    return "fixedSize" in codec && typeof codec.fixedSize === "number";
  }
  function assertIsFixedSize(codec, message) {
    if (!isFixedSize(codec)) {
      throw new Error(message != null ? message : "Expected a fixed-size codec, got a variable-size one.");
    }
  }
  function combineCodec(encoder, decoder) {
    if (isFixedSize(encoder) !== isFixedSize(decoder)) {
      throw new Error(`Encoder and decoder must either both be fixed-size or variable-size.`);
    }
    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
      throw new Error(
        `Encoder and decoder must have the same fixed size, got [${encoder.fixedSize}] and [${decoder.fixedSize}].`
      );
    }
    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
      throw new Error(
        `Encoder and decoder must have the same max size, got [${encoder.maxSize}] and [${decoder.maxSize}].`
      );
    }
    return {
      ...decoder,
      ...encoder,
      decode: decoder.decode,
      encode: encoder.encode,
      read: decoder.read,
      write: encoder.write
    };
  }

  // ../codecs-numbers/dist/index.browser.js
  function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
    if (value < min || value > max) {
      throw new Error(
        `Codec [${codecDescription}] expected number to be in the range [${min}, ${max}], got ${value}.`
      );
    }
  }
  function isLittleEndian(config) {
    return (config == null ? void 0 : config.endian) === 1 ? false : true;
  }
  function numberEncoderFactory(input) {
    return createEncoder({
      fixedSize: input.size,
      write(value, bytes, offset) {
        if (input.range) {
          assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
        }
        const arrayBuffer = new ArrayBuffer(input.size);
        input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
        bytes.set(new Uint8Array(arrayBuffer), offset);
        return offset + input.size;
      }
    });
  }
  function numberDecoderFactory(input) {
    return createDecoder({
      fixedSize: input.size,
      read(bytes, offset = 0) {
        assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
        assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
        const view = new DataView(toArrayBuffer(bytes, offset, input.size));
        return [input.get(view, isLittleEndian(input.config)), offset + input.size];
      }
    });
  }
  function toArrayBuffer(bytes, offset, length) {
    const bytesOffset = bytes.byteOffset + (offset != null ? offset : 0);
    const bytesLength = length != null ? length : bytes.byteLength;
    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
  }
  var getU8Encoder = () => numberEncoderFactory({
    name: "u8",
    range: [0, Number("0xff")],
    set: (view, value) => view.setUint8(0, value),
    size: 1
  });
  var getU8Decoder = () => numberDecoderFactory({
    get: (view) => view.getUint8(0),
    name: "u8",
    size: 1
  });

  // src/unwrap-option.ts
  function unwrapOption(option, fallback) {
    if (isSome(option))
      return option.value;
    return fallback ? fallback() : null;
  }
  var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();

  // src/option-codec.ts
  function getOptionEncoder(item, config = {}) {
    var _a, _b, _c;
    const prefix = (_a = config.prefix) != null ? _a : getU8Encoder();
    const fixed = (_b = config.fixed) != null ? _b : false;
    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;
    if (fixed || isZeroSizeItem) {
      assertIsFixedSize(item, "Fixed options can only be used with fixed-size codecs.");
      assertIsFixedSize(prefix, "Fixed options can only be used with fixed-size prefix.");
      const fixedSize = prefix.fixedSize + item.fixedSize;
      return createEncoder({
        fixedSize,
        write: (optionOrNullable, bytes, offset) => {
          const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);
          const prefixOffset = prefix.write(Number(isSome(option)), bytes, offset);
          if (isSome(option)) {
            item.write(option.value, bytes, prefixOffset);
          }
          return offset + fixedSize;
        }
      });
    }
    return createEncoder({
      getSizeFromValue: (optionOrNullable) => {
        const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);
        return getEncodedSize(Number(isSome(option)), prefix) + (isSome(option) ? getEncodedSize(option.value, item) : 0);
      },
      maxSize: (_c = sumCodecSizes([prefix, item].map(getMaxSize))) != null ? _c : void 0,
      write: (optionOrNullable, bytes, offset) => {
        const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);
        offset = prefix.write(Number(isSome(option)), bytes, offset);
        if (isSome(option)) {
          offset = item.write(option.value, bytes, offset);
        }
        return offset;
      }
    });
  }
  function getOptionDecoder(item, config = {}) {
    var _a, _b, _c;
    const prefix = (_a = config.prefix) != null ? _a : getU8Decoder();
    const fixed = (_b = config.fixed) != null ? _b : false;
    let fixedSize = null;
    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;
    if (fixed || isZeroSizeItem) {
      assertIsFixedSize(item, "Fixed options can only be used with fixed-size codecs.");
      assertIsFixedSize(prefix, "Fixed options can only be used with fixed-size prefix.");
      fixedSize = prefix.fixedSize + item.fixedSize;
    }
    return createDecoder({
      ...fixedSize === null ? { maxSize: (_c = sumCodecSizes([prefix, item].map(getMaxSize))) != null ? _c : void 0 } : { fixedSize },
      read: (bytes, offset) => {
        if (bytes.length - offset <= 0) {
          return [none(), offset];
        }
        const [isSome2, prefixOffset] = prefix.read(bytes, offset);
        if (isSome2 === 0) {
          return [none(), fixedSize !== null ? offset + fixedSize : prefixOffset];
        }
        const [value, newOffset] = item.read(bytes, prefixOffset);
        return [some(value), fixedSize !== null ? offset + fixedSize : newOffset];
      }
    });
  }
  function getOptionCodec(item, config = {}) {
    return combineCodec(getOptionEncoder(item, config), getOptionDecoder(item, config));
  }
  function sumCodecSizes(sizes) {
    return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
  }
  function getMaxSize(codec) {
    var _a;
    return isFixedSize(codec) ? codec.fixedSize : (_a = codec.maxSize) != null ? _a : null;
  }

  // src/unwrap-option-recursively.ts
  function unwrapOptionRecursively(input, fallback) {
    if (!input || ArrayBuffer.isView(input)) {
      return input;
    }
    const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
    if (isOption(input)) {
      if (isSome(input))
        return next(input.value);
      return fallback ? fallback() : null;
    }
    if (Array.isArray(input)) {
      return input.map(next);
    }
    if (typeof input === "object") {
      return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
    }
    return input;
  }

  exports.getOptionCodec = getOptionCodec;
  exports.getOptionDecoder = getOptionDecoder;
  exports.getOptionEncoder = getOptionEncoder;
  exports.isNone = isNone;
  exports.isOption = isOption;
  exports.isSome = isSome;
  exports.none = none;
  exports.some = some;
  exports.unwrapOption = unwrapOption;
  exports.unwrapOptionRecursively = unwrapOptionRecursively;
  exports.wrapNullable = wrapNullable;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.development.js.map