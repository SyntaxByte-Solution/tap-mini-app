"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenSize = exports.getTokenGpaBuilder = exports.safeFetchAllToken = exports.fetchAllToken = exports.safeFetchToken = exports.fetchToken = exports.deserializeToken = exports.getTokenAccountDataSerializer = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const types_1 = require("../types");
function getTokenAccountDataSerializer() {
    return (0, serializers_1.struct)([
        ['mint', (0, serializers_1.publicKey)()],
        ['owner', (0, serializers_1.publicKey)()],
        ['amount', (0, serializers_1.u64)()],
        [
            'delegate',
            (0, serializers_1.option)((0, serializers_1.publicKey)(), { prefix: (0, serializers_1.u32)(), fixed: true }),
        ],
        ['state', (0, types_1.getTokenStateSerializer)()],
        ['isNative', (0, serializers_1.option)((0, serializers_1.u64)(), { prefix: (0, serializers_1.u32)(), fixed: true })],
        ['delegatedAmount', (0, serializers_1.u64)()],
        [
            'closeAuthority',
            (0, serializers_1.option)((0, serializers_1.publicKey)(), { prefix: (0, serializers_1.u32)(), fixed: true }),
        ],
    ], { description: 'TokenAccountData' });
}
exports.getTokenAccountDataSerializer = getTokenAccountDataSerializer;
function deserializeToken(rawAccount) {
    return (0, umi_1.deserializeAccount)(rawAccount, getTokenAccountDataSerializer());
}
exports.deserializeToken = deserializeToken;
async function fetchToken(context, publicKey, options) {
    const maybeAccount = await context.rpc.getAccount((0, umi_1.publicKey)(publicKey, false), options);
    (0, umi_1.assertAccountExists)(maybeAccount, 'Token');
    return deserializeToken(maybeAccount);
}
exports.fetchToken = fetchToken;
async function safeFetchToken(context, publicKey, options) {
    const maybeAccount = await context.rpc.getAccount((0, umi_1.publicKey)(publicKey, false), options);
    return maybeAccount.exists ? deserializeToken(maybeAccount) : null;
}
exports.safeFetchToken = safeFetchToken;
async function fetchAllToken(context, publicKeys, options) {
    const maybeAccounts = await context.rpc.getAccounts(publicKeys.map((key) => (0, umi_1.publicKey)(key, false)), options);
    return maybeAccounts.map((maybeAccount) => {
        (0, umi_1.assertAccountExists)(maybeAccount, 'Token');
        return deserializeToken(maybeAccount);
    });
}
exports.fetchAllToken = fetchAllToken;
async function safeFetchAllToken(context, publicKeys, options) {
    const maybeAccounts = await context.rpc.getAccounts(publicKeys.map((key) => (0, umi_1.publicKey)(key, false)), options);
    return maybeAccounts
        .filter((maybeAccount) => maybeAccount.exists)
        .map((maybeAccount) => deserializeToken(maybeAccount));
}
exports.safeFetchAllToken = safeFetchAllToken;
function getTokenGpaBuilder(context) {
    const programId = context.programs.getPublicKey('splToken', 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    return (0, umi_1.gpaBuilder)(context, programId)
        .registerFields({
        mint: [0, (0, serializers_1.publicKey)()],
        owner: [32, (0, serializers_1.publicKey)()],
        amount: [64, (0, serializers_1.u64)()],
        delegate: [
            72,
            (0, serializers_1.option)((0, serializers_1.publicKey)(), { prefix: (0, serializers_1.u32)(), fixed: true }),
        ],
        state: [108, (0, types_1.getTokenStateSerializer)()],
        isNative: [109, (0, serializers_1.option)((0, serializers_1.u64)(), { prefix: (0, serializers_1.u32)(), fixed: true })],
        delegatedAmount: [121, (0, serializers_1.u64)()],
        closeAuthority: [
            129,
            (0, serializers_1.option)((0, serializers_1.publicKey)(), { prefix: (0, serializers_1.u32)(), fixed: true }),
        ],
    })
        .deserializeUsing((account) => deserializeToken(account))
        .whereSize(165);
}
exports.getTokenGpaBuilder = getTokenGpaBuilder;
function getTokenSize() {
    return 165;
}
exports.getTokenSize = getTokenSize;
//# sourceMappingURL=token.js.map