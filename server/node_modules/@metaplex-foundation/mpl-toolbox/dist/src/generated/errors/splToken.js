"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSplTokenErrorFromName = exports.getSplTokenErrorFromCode = exports.TokNonNativeNotSupportedError = exports.TokMintDecimalsMismatchError = exports.TokAccountFrozenError = exports.TokMintCannotFreezeError = exports.TokAuthorityTypeNotSupportedError = exports.TokOverflowError = exports.TokInvalidStateError = exports.TokInvalidInstructionError = exports.TokNonNativeHasBalanceError = exports.TokNativeNotSupportedError = exports.TokUninitializedStateError = exports.TokInvalidNumberOfRequiredSignersError = exports.TokInvalidNumberOfProvidedSignersError = exports.TokAlreadyInUseError = exports.TokFixedSupplyError = exports.TokOwnerMismatchError = exports.TokMintMismatchError = exports.TokInvalidMintError = exports.TokInsufficientFundsError = exports.TokNotRentExemptError = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** NotRentExempt: Lamport balance below rent-exempt threshold */
class TokNotRentExemptError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Lamport balance below rent-exempt threshold', program, cause);
        this.name = 'NotRentExempt';
        this.code = 0x0; // 0
    }
}
exports.TokNotRentExemptError = TokNotRentExemptError;
codeToErrorMap.set(0x0, TokNotRentExemptError);
nameToErrorMap.set('NotRentExempt', TokNotRentExemptError);
/** InsufficientFunds: Insufficient funds */
class TokInsufficientFundsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Insufficient funds', program, cause);
        this.name = 'InsufficientFunds';
        this.code = 0x1; // 1
    }
}
exports.TokInsufficientFundsError = TokInsufficientFundsError;
codeToErrorMap.set(0x1, TokInsufficientFundsError);
nameToErrorMap.set('InsufficientFunds', TokInsufficientFundsError);
/** InvalidMint: Invalid Mint */
class TokInvalidMintError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid Mint', program, cause);
        this.name = 'InvalidMint';
        this.code = 0x2; // 2
    }
}
exports.TokInvalidMintError = TokInvalidMintError;
codeToErrorMap.set(0x2, TokInvalidMintError);
nameToErrorMap.set('InvalidMint', TokInvalidMintError);
/** MintMismatch: Account not associated with this Mint */
class TokMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account not associated with this Mint', program, cause);
        this.name = 'MintMismatch';
        this.code = 0x3; // 3
    }
}
exports.TokMintMismatchError = TokMintMismatchError;
codeToErrorMap.set(0x3, TokMintMismatchError);
nameToErrorMap.set('MintMismatch', TokMintMismatchError);
/** OwnerMismatch: Owner does not match */
class TokOwnerMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Owner does not match', program, cause);
        this.name = 'OwnerMismatch';
        this.code = 0x4; // 4
    }
}
exports.TokOwnerMismatchError = TokOwnerMismatchError;
codeToErrorMap.set(0x4, TokOwnerMismatchError);
nameToErrorMap.set('OwnerMismatch', TokOwnerMismatchError);
/** FixedSupply: Fixed supply */
class TokFixedSupplyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Fixed supply', program, cause);
        this.name = 'FixedSupply';
        this.code = 0x5; // 5
    }
}
exports.TokFixedSupplyError = TokFixedSupplyError;
codeToErrorMap.set(0x5, TokFixedSupplyError);
nameToErrorMap.set('FixedSupply', TokFixedSupplyError);
/** AlreadyInUse: Already in use */
class TokAlreadyInUseError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Already in use', program, cause);
        this.name = 'AlreadyInUse';
        this.code = 0x6; // 6
    }
}
exports.TokAlreadyInUseError = TokAlreadyInUseError;
codeToErrorMap.set(0x6, TokAlreadyInUseError);
nameToErrorMap.set('AlreadyInUse', TokAlreadyInUseError);
/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */
class TokInvalidNumberOfProvidedSignersError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid number of provided signers', program, cause);
        this.name = 'InvalidNumberOfProvidedSigners';
        this.code = 0x7; // 7
    }
}
exports.TokInvalidNumberOfProvidedSignersError = TokInvalidNumberOfProvidedSignersError;
codeToErrorMap.set(0x7, TokInvalidNumberOfProvidedSignersError);
nameToErrorMap.set('InvalidNumberOfProvidedSigners', TokInvalidNumberOfProvidedSignersError);
/** InvalidNumberOfRequiredSigners: Invalid number of required signers */
class TokInvalidNumberOfRequiredSignersError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid number of required signers', program, cause);
        this.name = 'InvalidNumberOfRequiredSigners';
        this.code = 0x8; // 8
    }
}
exports.TokInvalidNumberOfRequiredSignersError = TokInvalidNumberOfRequiredSignersError;
codeToErrorMap.set(0x8, TokInvalidNumberOfRequiredSignersError);
nameToErrorMap.set('InvalidNumberOfRequiredSigners', TokInvalidNumberOfRequiredSignersError);
/** UninitializedState: State is unititialized */
class TokUninitializedStateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('State is unititialized', program, cause);
        this.name = 'UninitializedState';
        this.code = 0x9; // 9
    }
}
exports.TokUninitializedStateError = TokUninitializedStateError;
codeToErrorMap.set(0x9, TokUninitializedStateError);
nameToErrorMap.set('UninitializedState', TokUninitializedStateError);
/** NativeNotSupported: Instruction does not support native tokens */
class TokNativeNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Instruction does not support native tokens', program, cause);
        this.name = 'NativeNotSupported';
        this.code = 0xa; // 10
    }
}
exports.TokNativeNotSupportedError = TokNativeNotSupportedError;
codeToErrorMap.set(0xa, TokNativeNotSupportedError);
nameToErrorMap.set('NativeNotSupported', TokNativeNotSupportedError);
/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */
class TokNonNativeHasBalanceError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Non-native account can only be closed if its balance is zero', program, cause);
        this.name = 'NonNativeHasBalance';
        this.code = 0xb; // 11
    }
}
exports.TokNonNativeHasBalanceError = TokNonNativeHasBalanceError;
codeToErrorMap.set(0xb, TokNonNativeHasBalanceError);
nameToErrorMap.set('NonNativeHasBalance', TokNonNativeHasBalanceError);
/** InvalidInstruction: Invalid instruction */
class TokInvalidInstructionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid instruction', program, cause);
        this.name = 'InvalidInstruction';
        this.code = 0xc; // 12
    }
}
exports.TokInvalidInstructionError = TokInvalidInstructionError;
codeToErrorMap.set(0xc, TokInvalidInstructionError);
nameToErrorMap.set('InvalidInstruction', TokInvalidInstructionError);
/** InvalidState: State is invalid for requested operation */
class TokInvalidStateError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('State is invalid for requested operation', program, cause);
        this.name = 'InvalidState';
        this.code = 0xd; // 13
    }
}
exports.TokInvalidStateError = TokInvalidStateError;
codeToErrorMap.set(0xd, TokInvalidStateError);
nameToErrorMap.set('InvalidState', TokInvalidStateError);
/** Overflow: Operation overflowed */
class TokOverflowError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Operation overflowed', program, cause);
        this.name = 'Overflow';
        this.code = 0xe; // 14
    }
}
exports.TokOverflowError = TokOverflowError;
codeToErrorMap.set(0xe, TokOverflowError);
nameToErrorMap.set('Overflow', TokOverflowError);
/** AuthorityTypeNotSupported: Account does not support specified authority type */
class TokAuthorityTypeNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account does not support specified authority type', program, cause);
        this.name = 'AuthorityTypeNotSupported';
        this.code = 0xf; // 15
    }
}
exports.TokAuthorityTypeNotSupportedError = TokAuthorityTypeNotSupportedError;
codeToErrorMap.set(0xf, TokAuthorityTypeNotSupportedError);
nameToErrorMap.set('AuthorityTypeNotSupported', TokAuthorityTypeNotSupportedError);
/** MintCannotFreeze: This token mint cannot freeze accounts */
class TokMintCannotFreezeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This token mint cannot freeze accounts', program, cause);
        this.name = 'MintCannotFreeze';
        this.code = 0x10; // 16
    }
}
exports.TokMintCannotFreezeError = TokMintCannotFreezeError;
codeToErrorMap.set(0x10, TokMintCannotFreezeError);
nameToErrorMap.set('MintCannotFreeze', TokMintCannotFreezeError);
/** AccountFrozen: Account is frozen */
class TokAccountFrozenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account is frozen', program, cause);
        this.name = 'AccountFrozen';
        this.code = 0x11; // 17
    }
}
exports.TokAccountFrozenError = TokAccountFrozenError;
codeToErrorMap.set(0x11, TokAccountFrozenError);
nameToErrorMap.set('AccountFrozen', TokAccountFrozenError);
/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */
class TokMintDecimalsMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('The provided decimals value different from the Mint decimals', program, cause);
        this.name = 'MintDecimalsMismatch';
        this.code = 0x12; // 18
    }
}
exports.TokMintDecimalsMismatchError = TokMintDecimalsMismatchError;
codeToErrorMap.set(0x12, TokMintDecimalsMismatchError);
nameToErrorMap.set('MintDecimalsMismatch', TokMintDecimalsMismatchError);
/** NonNativeNotSupported: Instruction does not support non-native tokens */
class TokNonNativeNotSupportedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Instruction does not support non-native tokens', program, cause);
        this.name = 'NonNativeNotSupported';
        this.code = 0x13; // 19
    }
}
exports.TokNonNativeNotSupportedError = TokNonNativeNotSupportedError;
codeToErrorMap.set(0x13, TokNonNativeNotSupportedError);
nameToErrorMap.set('NonNativeNotSupported', TokNonNativeNotSupportedError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getSplTokenErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getSplTokenErrorFromCode = getSplTokenErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getSplTokenErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getSplTokenErrorFromName = getSplTokenErrorFromName;
//# sourceMappingURL=splToken.js.map