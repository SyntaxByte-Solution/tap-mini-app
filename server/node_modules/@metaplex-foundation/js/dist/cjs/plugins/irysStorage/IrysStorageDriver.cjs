'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.cjs');
var BigNumber = require('bignumber.js');
var web3_js = require('@solana/web3.js');
var MetaplexFile = require('../storageModule/MetaplexFile.cjs');
var IrysError = require('../../errors/IrysError.cjs');
var Signer = require('../../types/Signer.cjs');
var KeypairIdentityDriver = require('../keypairIdentity/KeypairIdentityDriver.cjs');
var exports$1 = require('../../utils/exports.cjs');
var Amount = require('../../types/Amount.cjs');
var BigNumber$1 = require('../../types/BigNumber.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var BigNumber__default = /*#__PURE__*/_interopDefaultLegacy(BigNumber);

/// Size of irys transaction header
const HEADER_SIZE = 2_000;

/// Minimum file size for cost calculation
const MINIMUM_SIZE = 80_000;
class IrysStorageDriver {
  constructor(metaplex, options = {}) {
    _rollupPluginBabelHelpers.defineProperty(this, "_irys", null);
    this._metaplex = metaplex;
    this._options = {
      providerUrl: metaplex.connection.rpcEndpoint,
      ...options
    };
  }
  async getUploadPrice(bytes) {
    const irys = await this.irys();
    const price = await irys.getPrice(bytes);
    return bigNumberToAmount(price.multipliedBy(this._options.priceMultiplier ?? 1.1));
  }
  async getUploadPriceForFiles(files) {
    const bytes = files.reduce((sum, file) => {
      return sum + HEADER_SIZE + Math.max(MINIMUM_SIZE, file.buffer.byteLength);
    }, 0);
    return this.getUploadPrice(bytes);
  }
  async upload(file) {
    const [uri] = await this.uploadAll([file]);
    return uri;
  }
  async uploadAll(files) {
    const irys = await this.irys();
    const amount = await this.getUploadPrice(MetaplexFile.getBytesFromMetaplexFiles(...files));
    await this.fund(amount);
    const promises = files.map(async file => {
      const irysTx = irys.createTransaction(file.buffer, {
        tags: getMetaplexFileTagsWithContentType(file)
      });
      await irysTx.sign();
      const {
        status,
        data
      } = await irys.uploader.uploadTransaction(irysTx);
      if (status >= 300) {
        throw new IrysError.AssetUploadFailedError(status);
      }
      return `https://arweave.net/${data.id}`;
    });
    return await Promise.all(promises);
  }
  async getBalance() {
    const irys = await this.irys();
    const balance = await irys.getLoadedBalance();
    return bigNumberToAmount(balance);
  }
  async fund(amount, skipBalanceCheck = false) {
    const irys = await this.irys();
    let toFund = amountToBigNumber(amount);
    if (!skipBalanceCheck) {
      const balance = await irys.getLoadedBalance();
      toFund = toFund.isGreaterThan(balance) ? toFund.minus(balance) : new BigNumber__default["default"](0);
    }
    if (toFund.isLessThanOrEqualTo(0)) {
      return;
    }

    // TODO: Catch errors and wrap in irysErrors.
    await irys.fund(toFund);
  }
  async withdrawAll() {
    // TODO(loris): Replace with "withdrawAll" when available on irys.
    const irys = await this.irys();
    const balance = await irys.getLoadedBalance();
    const minimumBalance = new BigNumber__default["default"](5000);
    if (balance.isLessThan(minimumBalance)) {
      return;
    }
    const balanceToWithdraw = balance.minus(minimumBalance);
    await this.withdraw(bigNumberToAmount(balanceToWithdraw));
  }
  async withdraw(amount) {
    const irys = await this.irys();
    try {
      await irys.withdrawBalance(amountToBigNumber(amount));
    } catch (e) {
      throw new IrysError.IrysWithdrawError(e instanceof Error ? e.message : e.toString());
    }
  }
  async irys() {
    if (this._irys) {
      return this._irys;
    }
    return this._irys = await this.initIrys();
  }
  async initIrys() {
    const currency = 'solana';
    const address = this._options?.address ?? 'https://node1.irys.xyz';
    const options = {
      timeout: this._options.timeout,
      providerUrl: this._options.providerUrl
    };
    const identity = this._options.identity ?? this._metaplex.identity();

    // if in node use node irys, else use web irys
    // see: https://github.com/metaplex-foundation/js/issues/202
    const isNode = typeof window === 'undefined' || window.process?.hasOwnProperty('type');
    let irys;
    if (isNode && Signer.isKeypairSigner(identity)) irys = await this.initNodeirys(address, currency, identity, options);else {
      let identitySigner;
      if (Signer.isIdentitySigner(identity)) identitySigner = identity;else identitySigner = new KeypairIdentityDriver.KeypairIdentityDriver(web3_js.Keypair.fromSecretKey(identity.secretKey));
      irys = await this.initWebirys(address, currency, identitySigner, options);
    }
    try {
      // Check for valid irys node.
      await irys.utils.getBundlerAddress(currency);
    } catch (error) {
      throw new IrysError.FailedToConnectToIrysAddressError(address, error);
    }
    return irys;
  }
  async initNodeirys(address, currency, keypair, options) {
    const bPackage = exports$1._removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/sdk')); }));
    return new bPackage.default({
      url: address,
      token: currency,
      key: keypair.secretKey,
      config: options
    });
  }
  async initWebirys(address, currency, identity, options) {
    const wallet = {
      publicKey: identity.publicKey,
      signMessage: message => identity.signMessage(message),
      signTransaction: transaction => identity.signTransaction(transaction),
      signAllTransactions: transactions => identity.signAllTransactions(transactions),
      sendTransaction: (transaction, connection, options = {}) => {
        const {
          signers = [],
          ...sendOptions
        } = options;
        return this._metaplex.rpc().sendTransaction(transaction, sendOptions, [identity, ...signers]);
      }
    };
    const bPackage = exports$1._removeDoubleDefault(await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@irys/sdk')); }));
    const irys = new bPackage.WebIrys({
      url: address,
      token: currency,
      wallet: {
        provider: wallet
      },
      config: options
    });
    try {
      // Try to initiate irys.
      await irys.ready();
    } catch (error) {
      throw new IrysError.FailedToInitializeIrysError(error);
    }
    return irys;
  }
}
const isirysStorageDriver = storageDriver => {
  return 'irys' in storageDriver && 'getBalance' in storageDriver && 'fund' in storageDriver && 'withdrawAll' in storageDriver;
};
const bigNumberToAmount = bigNumber => {
  return Amount.lamports(BigNumber$1.toBigNumber(bigNumber.decimalPlaces(0).toString()));
};
const amountToBigNumber = amount => {
  return new BigNumber__default["default"](amount.basisPoints.toString());
};
const getMetaplexFileTagsWithContentType = file => {
  if (!file.contentType) {
    return file.tags;
  }
  return [{
    name: 'Content-Type',
    value: file.contentType
  }, ...file.tags];
};

exports.IrysStorageDriver = IrysStorageDriver;
exports.isirysStorageDriver = isirysStorageDriver;
//# sourceMappingURL=IrysStorageDriver.cjs.map
