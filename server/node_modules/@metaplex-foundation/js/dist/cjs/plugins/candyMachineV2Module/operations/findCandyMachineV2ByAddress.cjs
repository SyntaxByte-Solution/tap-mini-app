'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var accounts = require('../accounts.cjs');
var pdas = require('../pdas.cjs');
var CandyMachineV2 = require('../models/CandyMachineV2.cjs');
var Operation = require('../../../types/Operation.cjs');
var Account = require('../../../types/Account.cjs');

// -----------------
// Operation
// -----------------

const Key = 'FindCandyMachineV2ByAddressOperation';

/**
 * Find an existing Candy Machine by its address.
 *
 * ```ts
 * const candyMachine = await metaplex.candyMachinesV2().findbyAddress({ address });
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const findCandyMachineV2ByAddressOperation = Operation.useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const findCandyMachineV2ByAddressOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const {
      commitment
    } = scope;
    const {
      address
    } = operation.input;
    const collectionPda = pdas.findCandyMachineV2CollectionPda(address);
    const accounts$1 = await metaplex.rpc().getMultipleAccounts([address, collectionPda], commitment);
    const unparsedAccount = accounts$1[0];
    Account.assertAccountExists(unparsedAccount);
    const account = accounts.toCandyMachineV2Account(unparsedAccount);
    const collectionAccount = accounts.parseCandyMachineV2CollectionAccount(accounts$1[1]);
    const mint = account.data.tokenMint ? await metaplex.tokens().findMintByAddress({
      address: account.data.tokenMint
    }, scope) : null;
    return CandyMachineV2.toCandyMachineV2(account, unparsedAccount, collectionAccount, mint);
  }
};

exports.findCandyMachineV2ByAddressOperation = findCandyMachineV2ByAddressOperation;
exports.findCandyMachineV2ByAddressOperationHandler = findCandyMachineV2ByAddressOperationHandler;
//# sourceMappingURL=findCandyMachineV2ByAddress.cjs.map
