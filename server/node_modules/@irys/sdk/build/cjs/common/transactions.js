"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
class Transaction {
    constructor(irys) {
        this.irys = irys;
    }
    getById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = (yield this.query({ ids: [id], limit: 1 })).at(0);
            if (!res)
                throw new Error(`Unable to locate tx with id ${id}`);
            return res;
        });
    }
    getByOwner(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = (yield this.query({ owners: [owner], limit: 1 })).at(0);
            if (!res)
                throw new Error(`Unable to locate tx with owner ${owner}`);
            return res;
        });
    }
    getByTag(name, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = (yield this.query({ tags: [{ name, values: [value] }], limit: 1 })).at(0);
            if (!res)
                throw new Error(`Unable to locate tx with tag ${name}:${value}`);
            return res;
        });
    }
    query(parameters) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // full bundler node GQL query
            const query = `
    query ($ids: [String!], $after: String, $currency: String, $owners: [String!], $limit: Int, $order: SortOrder, $hasTags: Boolean, $tags: [TagFilter!]) {
      transactions(ids: $ids, after: $after, currency: $currency, owners: $owners, limit: $limit, order: $order, hasTags: $hasTags, tags: $tags) {
        edges {
          cursor
          node {
            address
            currency
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            signature
            tags {
              name
              value
            }
            timestamp
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
    `;
            const txs = [];
            let endCursor = null;
            do {
                const gqlRes = yield this.irys.api.post("/graphql", {
                    query,
                    variables: Object.assign(Object.assign({}, parameters), { after: endCursor !== null && endCursor !== void 0 ? endCursor : parameters.after }),
                }, undefined);
                endCursor = ((_b = (_a = gqlRes.data.data.transactions) === null || _a === void 0 ? void 0 : _a.pageInfo) === null || _b === void 0 ? void 0 : _b.hasNextPage) ? gqlRes.data.data.transactions.pageInfo.endCursor : null;
                txs.push(...gqlRes.data.data.transactions.edges.map((t) => t.node));
            } while (endCursor);
            return txs;
        });
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transactions.js.map