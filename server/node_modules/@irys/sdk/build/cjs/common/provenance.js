"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Provenance = void 0;
class Provenance {
    constructor(irys) {
        this.irys = irys;
    }
    upload(data, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.irys.uploadWithReceipt(data, opts);
        });
    }
    uploadProof(proofFields) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.irys.uploadWithReceipt("", {
                tags: Object.entries(Object.assign({ dataProtocol: "Provenance-Confirmation" }, proofFields)).map(([k, v]) => ({ name: tagMap[k], value: v })),
            });
        });
    }
    getAllProofs(searchBy, opts) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const queryTags = Object.entries(searchBy).map(([k, v]) => ({ name: tagMap[k], values: [v] }));
            if (queryTags.length === 0)
                throw new Error(`Getting a provenance proof requires at least one query element`);
            const query = `
    query ($tags: [TagFilter!]) {
      transactions(tags: $tags) {
        edges {
          node {
            id
            receipt {
              deadlineHeight
              signature
              timestamp
              version
            }
            tags {
              name
              value
            }
          }
        }
      }
    }
    `;
            const txs = [];
            let endCursor = null;
            do {
                const gqlRes = yield this.irys.api.post("/graphql", {
                    query,
                    variables: { tags: queryTags, limit: (_a = opts === null || opts === void 0 ? void 0 : opts.limit) !== null && _a !== void 0 ? _a : null, after: endCursor },
                }, undefined);
                endCursor = ((_c = (_b = gqlRes.data.data.transactions) === null || _b === void 0 ? void 0 : _b.pageInfo) === null || _c === void 0 ? void 0 : _c.hasNextPage) ? gqlRes.data.data.transactions.pageInfo.endCursor : null;
                txs.push(...gqlRes.data.data.transactions.edges.map((t) => t.node));
            } while (endCursor);
            return txs;
        });
    }
    getProof(searchBy) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = (yield this.getAllProofs(searchBy, { limit: 1 })).at(0);
            if (!res)
                throw new Error(`Unable to locate proof with fields ${JSON.stringify(searchBy)}`);
            return res;
        });
    }
}
exports.Provenance = Provenance;
const tagMap = {
    dataProtocol: "Data-Protocol",
    hashingAlgo: "Hashing-Algo",
    dataHash: "Data-Hash",
    uploadedFor: "Uploaded-For",
    prompt: "Prompt",
    promptHash: "Prompt-Hash",
    model: "Model",
};
//# sourceMappingURL=provenance.js.map