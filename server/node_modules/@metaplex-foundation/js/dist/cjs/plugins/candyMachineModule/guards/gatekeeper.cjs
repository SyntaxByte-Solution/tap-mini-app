'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = require('buffer');
var mplCandyGuard = require('@metaplex-foundation/mpl-candy-guard');
var Serializer = require('../../../types/Serializer.cjs');
var Pda = require('../../../types/Pda.cjs');

/**
 * The gatekeeper guard checks whether the minting wallet
 * has a valid Gateway Token from a specified Gateway Network.
 *
 * In most cases, this token will be obtain after completing a
 * captcha challenge but any Gateway Network may be used.
 *
 * This object defines the settings that should be
 * provided when creating and/or updating a Candy
 * Machine if you wish to enable this guard.
 *
 * @see {@link GatekeeperGuardMintSettings} for more
 * information on the mint settings of this guard.
 */

/** @internal */
const gatekeeperGuardManifest = {
  name: 'gatekeeper',
  settingsBytes: 33,
  settingsSerializer: Serializer.mapSerializer(Serializer.createSerializerFromBeet(mplCandyGuard.gatekeeperBeet), settings => ({
    ...settings,
    network: settings.gatekeeperNetwork
  }), settings => ({
    ...settings,
    gatekeeperNetwork: settings.network
  })),
  mintSettingsParser: ({
    metaplex,
    settings,
    mintSettings,
    payer,
    programs
  }) => {
    const gatewayProgram = metaplex.programs().getGateway(programs);
    const tokenAccount = mintSettings?.tokenAccount ?? Pda.Pda.find(gatewayProgram.address, [payer.publicKey.toBuffer(), buffer.Buffer.from('gateway'), buffer.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]), settings.network.toBuffer()]);
    const remainingAccounts = [{
      isSigner: false,
      address: tokenAccount,
      isWritable: true
    }];
    if (settings.expireOnUse) {
      const expireAccount = Pda.Pda.find(gatewayProgram.address, [settings.network.toBuffer(), buffer.Buffer.from('expire')]);
      remainingAccounts.push({
        isSigner: false,
        address: gatewayProgram.address,
        isWritable: false
      });
      remainingAccounts.push({
        isSigner: false,
        address: expireAccount,
        isWritable: false
      });
    }
    return {
      arguments: buffer.Buffer.from([]),
      remainingAccounts
    };
  }
};

exports.gatekeeperGuardManifest = gatekeeperGuardManifest;
//# sourceMappingURL=gatekeeper.cjs.map
