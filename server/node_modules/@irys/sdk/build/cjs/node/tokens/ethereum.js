"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_1 = require("@ethersproject/bignumber");
const providers_1 = require("@ethersproject/providers");
const wallet_1 = require("@ethersproject/wallet");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const arbundles_1 = require("arbundles");
const token_1 = require("../token");
const ethereumSigner = arbundles_1.EthereumSigner;
class EthereumConfig extends token_1.BaseNodeToken {
    constructor(config) {
        super(config);
        this.base = ["wei", 1e18];
    }
    getProvider() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.providerInstance) {
                this.providerInstance = new providers_1.JsonRpcProvider(this.providerUrl);
                yield this.providerInstance.ready;
            }
            return this.providerInstance;
        });
    }
    getTx(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const response = yield provider.getTransaction(txId);
            if (!response)
                throw new Error("Tx doesn't exist");
            if (!response.to)
                throw new Error(`Unable to determine transaction ${txId} recepient`);
            // console.log(response.confirmations);
            return {
                from: response.from,
                to: response.to,
                blockHeight: response.blockNumber ? new bignumber_js_1.default(response.blockNumber) : undefined,
                amount: new bignumber_js_1.default(response.value.toHexString(), 16),
                pending: response.blockNumber ? false : true,
                confirmed: response.confirmations >= this.minConfirm,
            };
        });
    }
    ownerToAddress(owner) {
        return "0x" + (0, arbundles_1.keccak256)(owner.slice(1)).slice(-20).toString("hex");
    }
    sign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const signer = this.getSigner();
            return signer.sign(data);
        });
    }
    getSigner() {
        return new ethereumSigner(this.wallet);
    }
    verify(pub, data, signature) {
        return ethereumSigner.verify(pub, data, signature);
    }
    getCurrentHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (yield this.getProvider()).send("eth_blockNumber", []);
            return new bignumber_js_1.default(response, 16);
        });
    }
    getFee(amount, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const _amount = new bignumber_js_1.default(amount);
            const tx = {
                from: this.address,
                to,
                value: "0x" + _amount.toString(16),
            };
            const estimatedGas = yield provider.estimateGas(tx);
            const gasPrice = yield provider.getGasPrice();
            // const b = await provider.send("eth_maxPriorityFeePerGas", [])
            // console.log(b)
            return new bignumber_js_1.default(estimatedGas.mul(gasPrice).toString());
        });
    }
    sendTx(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (yield this.getProvider()).sendTransaction(data).catch((e) => {
                console.error(`Error occurred while sending a tx - ${e}`);
                throw e;
            });
        });
    }
    createTx(amount, to, fee) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const wallet = new wallet_1.Wallet(this.wallet, provider);
            const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
            let gasPrice = yield provider.getGasPrice();
            const gasEstimate = fee ? bignumber_1.BigNumber.from(new bignumber_js_1.default(fee).dividedToIntegerBy(gasPrice.toString()).toFixed()) : undefined;
            // const estimatedGas = await provider.estimateGas({ from: this.address, to, value: _amount });
            // console.log({ gasPrice, estimatedGas })
            // if (fee) {
            //     gasPrice = ethers.BigNumber.from(Math.ceil(+fee / estimatedGas.toNumber()))
            // }
            if (this.name === "matic") {
                gasPrice = bignumber_1.BigNumber.from(new bignumber_js_1.default(gasPrice.toString()).multipliedBy(10).decimalPlaces(0).toString());
            }
            const tx = yield wallet.populateTransaction({
                to,
                value: _amount,
                from: this.address,
                gasPrice,
                // gasLimit: estimatedGas,
                gasLimit: gasEstimate,
                // nonce: b // await provider.getTransactionCount(this.address),
                // chainId: await (await provider.getNetwork()).chainId
            });
            // tx.gasLimit = ethers.BigNumber.from(+(tx.gasLimit.toString()) * 4)
            const signedTx = yield wallet.signTransaction(tx);
            const txId = "0x" + (0, arbundles_1.keccak256)(Buffer.from(signedTx.slice(2), "hex")).toString("hex");
            // const c = await provider.call(tx);
            // console.log(c)
            return { txId, tx: signedTx };
        });
    }
    getPublicKey() {
        return this.getSigner().publicKey;
    }
}
exports.default = EthereumConfig;
//# sourceMappingURL=ethereum.js.map