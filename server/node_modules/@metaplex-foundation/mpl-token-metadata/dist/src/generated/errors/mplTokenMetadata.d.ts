/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
import { Program, ProgramError } from '@metaplex-foundation/umi';
/** InstructionUnpackError */
export declare class InstructionUnpackErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InstructionPackError */
export declare class InstructionPackErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotRentExempt: Lamport balance below rent-exempt threshold */
export declare class NotRentExemptError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyInitialized: Already initialized */
export declare class AlreadyInitializedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** Uninitialized: Uninitialized */
export declare class UninitializedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMetadataKey:  Metadata's key must match seed of ['metadata', program id, mint] provided */
export declare class InvalidMetadataKeyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidEditionKey: Edition's key must match seed of ['metadata', program id, name, 'edition'] provided */
export declare class InvalidEditionKeyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UpdateAuthorityIncorrect: Update Authority given does not match */
export declare class UpdateAuthorityIncorrectError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UpdateAuthorityIsNotSigner: Update Authority needs to be signer to update metadata */
export declare class UpdateAuthorityIsNotSignerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotMintAuthority: You must be the mint authority and signer on this transaction */
export declare class NotMintAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMintAuthority: Mint authority provided does not match the authority on the mint */
export declare class InvalidMintAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NameTooLong: Name too long */
export declare class NameTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** SymbolTooLong: Symbol too long */
export declare class SymbolTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UriTooLong: URI too long */
export declare class UriTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner */
export declare class UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MintMismatch: Mint given does not match mint on Metadata */
export declare class MintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** EditionsMustHaveExactlyOneToken: Editions must have exactly one token */
export declare class EditionsMustHaveExactlyOneTokenError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MaxEditionsMintedAlready */
export declare class MaxEditionsMintedAlreadyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TokenMintToFailed */
export declare class TokenMintToFailedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MasterRecordMismatch */
export declare class MasterRecordMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DestinationMintMismatch */
export declare class DestinationMintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** EditionAlreadyMinted */
export declare class EditionAlreadyMintedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrintingMintDecimalsShouldBeZero */
export declare class PrintingMintDecimalsShouldBeZeroError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** OneTimePrintingAuthorizationMintDecimalsShouldBeZero */
export declare class OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** EditionMintDecimalsShouldBeZero: EditionMintDecimalsShouldBeZero */
export declare class EditionMintDecimalsShouldBeZeroError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TokenBurnFailed */
export declare class TokenBurnFailedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TokenAccountOneTimeAuthMintMismatch */
export declare class TokenAccountOneTimeAuthMintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DerivedKeyInvalid: Derived key invalid */
export declare class DerivedKeyInvalidError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrintingMintMismatch: The Printing mint does not match that on the master edition! */
export declare class PrintingMintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** OneTimePrintingAuthMintMismatch: The One Time Printing Auth mint does not match that on the master edition! */
export declare class OneTimePrintingAuthMintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TokenAccountMintMismatch: The mint of the token account does not match the Printing mint! */
export declare class TokenAccountMintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TokenAccountMintMismatchV2: The mint of the token account does not match the master metadata mint! */
export declare class TokenAccountMintMismatchV2Error extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotEnoughTokens: Not enough tokens to mint a limited edition */
export declare class NotEnoughTokensError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrintingMintAuthorizationAccountMismatch */
export declare class PrintingMintAuthorizationAccountMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AuthorizationTokenAccountOwnerMismatch */
export declare class AuthorizationTokenAccountOwnerMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** Disabled */
export declare class DisabledError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorsTooLong: Creators list too long */
export declare class CreatorsTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorsMustBeAtleastOne: Creators must be at least one if set */
export declare class CreatorsMustBeAtleastOneError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MustBeOneOfCreators */
export declare class MustBeOneOfCreatorsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NoCreatorsPresentOnMetadata: This metadata does not have creators */
export declare class NoCreatorsPresentOnMetadataError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorNotFound: This creator address was not found */
export declare class CreatorNotFoundError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidBasisPoints: Basis points cannot be more than 10000 */
export declare class InvalidBasisPointsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrimarySaleCanOnlyBeFlippedToTrue: Primary sale can only be flipped to true and is immutable */
export declare class PrimarySaleCanOnlyBeFlippedToTrueError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** OwnerMismatch: Owner does not match that on the account given */
export declare class OwnerMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NoBalanceInAccountForAuthorization: This account has no tokens to be used for authorization */
export declare class NoBalanceInAccountForAuthorizationError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ShareTotalMustBe100: Share total must equal 100 for creator array */
export declare class ShareTotalMustBe100Error extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationExists */
export declare class ReservationExistsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationDoesNotExist */
export declare class ReservationDoesNotExistError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationNotSet */
export declare class ReservationNotSetError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationAlreadyMade */
export declare class ReservationAlreadyMadeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** BeyondMaxAddressSize */
export declare class BeyondMaxAddressSizeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NumericalOverflowError: NumericalOverflowError */
export declare class NumericalOverflowErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationBreachesMaximumSupply */
export declare class ReservationBreachesMaximumSupplyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AddressNotInReservation */
export declare class AddressNotInReservationError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotVerifyAnotherCreator: You cannot unilaterally verify another creator, they must sign */
export declare class CannotVerifyAnotherCreatorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotUnverifyAnotherCreator: You cannot unilaterally unverify another creator */
export declare class CannotUnverifyAnotherCreatorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** SpotMismatch */
export declare class SpotMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** IncorrectOwner: Incorrect account owner */
export declare class IncorrectOwnerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrintingWouldBreachMaximumSupply */
export declare class PrintingWouldBreachMaximumSupplyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DataIsImmutable: Data is immutable */
export declare class DataIsImmutableError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DuplicateCreatorAddress: No duplicate creator addresses */
export declare class DuplicateCreatorAddressError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationSpotsRemainingShouldMatchTotalSpotsAtStart */
export declare class ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidTokenProgram: Invalid token program */
export declare class InvalidTokenProgramError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DataTypeMismatch: Data type mismatch */
export declare class DataTypeMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** BeyondAlottedAddressSize */
export declare class BeyondAlottedAddressSizeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationNotComplete */
export declare class ReservationNotCompleteError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TriedToReplaceAnExistingReservation */
export declare class TriedToReplaceAnExistingReservationError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidOperation: Invalid operation */
export declare class InvalidOperationError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidOwner: Invalid Owner */
export declare class InvalidOwnerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrintingMintSupplyMustBeZeroForConversion: Printing mint supply must be zero for conversion */
export declare class PrintingMintSupplyMustBeZeroForConversionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** OneTimeAuthMintSupplyMustBeZeroForConversion: One Time Auth mint supply must be zero for conversion */
export declare class OneTimeAuthMintSupplyMustBeZeroForConversionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidEditionIndex: You tried to insert one edition too many into an edition mark pda */
export declare class InvalidEditionIndexError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationArrayShouldBeSizeOne */
export declare class ReservationArrayShouldBeSizeOneError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** IsMutableCanOnlyBeFlippedToFalse: Is Mutable can only be flipped to false */
export declare class IsMutableCanOnlyBeFlippedToFalseError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionCannotBeVerifiedInThisInstruction: Collection cannot be verified in this instruction */
export declare class CollectionCannotBeVerifiedInThisInstructionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** Removed: This instruction was deprecated in a previous release and is now removed */
export declare class RemovedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MustBeBurned */
export declare class MustBeBurnedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidUseMethod: This use method is invalid */
export declare class InvalidUseMethodError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotChangeUseMethodAfterFirstUse: Cannot Change Use Method after the first use */
export declare class CannotChangeUseMethodAfterFirstUseError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotChangeUsesAfterFirstUse: Cannot Change Remaining or Available uses after the first use */
export declare class CannotChangeUsesAfterFirstUseError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionNotFound: Collection Not Found on Metadata */
export declare class CollectionNotFoundError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCollectionUpdateAuthority: Collection Update Authority is invalid */
export declare class InvalidCollectionUpdateAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMustBeAUniqueMasterEdition: Collection Must Be a Unique Master Edition v2 */
export declare class CollectionMustBeAUniqueMasterEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UseAuthorityRecordAlreadyExists: The Use Authority Record Already Exists, to modify it Revoke, then Approve */
export declare class UseAuthorityRecordAlreadyExistsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UseAuthorityRecordAlreadyRevoked: The Use Authority Record is empty or already revoked */
export declare class UseAuthorityRecordAlreadyRevokedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** Unusable: This token has no uses */
export declare class UnusableError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotEnoughUses: There are not enough Uses left on this token. */
export declare class NotEnoughUsesError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionAuthorityRecordAlreadyExists: This Collection Authority Record Already Exists. */
export declare class CollectionAuthorityRecordAlreadyExistsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionAuthorityDoesNotExist: This Collection Authority Record Does Not Exist. */
export declare class CollectionAuthorityDoesNotExistError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidUseAuthorityRecord: This Use Authority Record is invalid. */
export declare class InvalidUseAuthorityRecordError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCollectionAuthorityRecord */
export declare class InvalidCollectionAuthorityRecordError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidFreezeAuthority: Metadata does not match the freeze authority on the mint */
export declare class InvalidFreezeAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidDelegate: All tokens in this account have not been delegated to this user. */
export declare class InvalidDelegateError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotAdjustVerifiedCreator */
export declare class CannotAdjustVerifiedCreatorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotRemoveVerifiedCreator: Verified creators cannot be removed. */
export declare class CannotRemoveVerifiedCreatorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotWipeVerifiedCreators */
export declare class CannotWipeVerifiedCreatorsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotAllowedToChangeSellerFeeBasisPoints */
export declare class NotAllowedToChangeSellerFeeBasisPointsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** EditionOverrideCannotBeZero: Edition override cannot be zero */
export declare class EditionOverrideCannotBeZeroError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidUser: Invalid User */
export declare class InvalidUserError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** RevokeCollectionAuthoritySignerIncorrect: Revoke Collection Authority signer is incorrect */
export declare class RevokeCollectionAuthoritySignerIncorrectError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TokenCloseFailed */
export declare class TokenCloseFailedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UnsizedCollection: Can't use this function on unsized collection */
export declare class UnsizedCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** SizedCollection: Can't use this function on a sized collection */
export declare class SizedCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingCollectionMetadata: Missing collection metadata account */
export declare class MissingCollectionMetadataError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotAMemberOfCollection: This NFT is not a member of the specified collection. */
export declare class NotAMemberOfCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotVerifiedMemberOfCollection: This NFT is not a verified member of the specified collection. */
export declare class NotVerifiedMemberOfCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotACollectionParent: This NFT is not a collection parent NFT. */
export declare class NotACollectionParentError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CouldNotDetermineTokenStandard: Could not determine a TokenStandard type. */
export declare class CouldNotDetermineTokenStandardError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingEditionAccount: This mint account has an edition but none was provided. */
export declare class MissingEditionAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotAMasterEdition: This edition is not a Master Edition */
export declare class NotAMasterEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MasterEditionHasPrints: This Master Edition has existing prints */
export declare class MasterEditionHasPrintsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** BorshDeserializationError */
export declare class BorshDeserializationErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotUpdateVerifiedCollection: Cannot update a verified collection in this command */
export declare class CannotUpdateVerifiedCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMasterEditionAccountInvalid: Edition account doesnt match collection  */
export declare class CollectionMasterEditionAccountInvalidError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyVerified: Item is already verified. */
export declare class AlreadyVerifiedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyUnverified */
export declare class AlreadyUnverifiedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotAPrintEdition: This edition is not a Print Edition */
export declare class NotAPrintEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMasterEdition: Invalid Master Edition */
export declare class InvalidMasterEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidPrintEdition: Invalid Print Edition */
export declare class InvalidPrintEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidEditionMarker: Invalid Edition Marker */
export declare class InvalidEditionMarkerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** ReservationListDeprecated: Reservation List is Deprecated */
export declare class ReservationListDeprecatedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrintEditionDoesNotMatchMasterEdition: Print Edition does not match Master Edition */
export declare class PrintEditionDoesNotMatchMasterEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** EditionNumberGreaterThanMaxSupply: Edition Number greater than max supply */
export declare class EditionNumberGreaterThanMaxSupplyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MustUnverify: Must unverify before migrating collections. */
export declare class MustUnverifyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidEscrowBumpSeed: Invalid Escrow Account Bump Seed */
export declare class InvalidEscrowBumpSeedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MustBeEscrowAuthority: Must Escrow Authority */
export declare class MustBeEscrowAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidSystemProgram: Invalid System Program */
export declare class InvalidSystemProgramError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MustBeNonFungible: Must be a Non Fungible Token */
export declare class MustBeNonFungibleError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InsufficientTokens: Insufficient tokens for transfer */
export declare class InsufficientTokensError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** BorshSerializationError: Borsh Serialization Error */
export declare class BorshSerializationErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NoFreezeAuthoritySet: Cannot create NFT with no Freeze Authority. */
export declare class NoFreezeAuthoritySetError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCollectionSizeChange: Invalid collection size change */
export declare class InvalidCollectionSizeChangeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidBubblegumSigner: Invalid bubblegum signer */
export declare class InvalidBubblegumSignerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** EscrowParentHasDelegate: Escrow parent cannot have a delegate */
export declare class EscrowParentHasDelegateError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MintIsNotSigner: Mint needs to be signer to initialize the account */
export declare class MintIsNotSignerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidTokenStandard: Invalid token standard */
export declare class InvalidTokenStandardError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMintForTokenStandard: Invalid mint account for specified token standard */
export declare class InvalidMintForTokenStandardError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidAuthorizationRules: Invalid authorization rules account */
export declare class InvalidAuthorizationRulesError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingAuthorizationRules: Missing authorization rules account */
export declare class MissingAuthorizationRulesError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingProgrammableConfig: Missing programmable configuration */
export declare class MissingProgrammableConfigError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidProgrammableConfig: Invalid programmable configuration */
export declare class InvalidProgrammableConfigError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DelegateAlreadyExists: Delegate already exists */
export declare class DelegateAlreadyExistsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DelegateNotFound: Delegate not found */
export declare class DelegateNotFoundError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingAccountInBuilder: Required account not set in instruction builder */
export declare class MissingAccountInBuilderError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingArgumentInBuilder: Required argument not set in instruction builder */
export declare class MissingArgumentInBuilderError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** FeatureNotSupported: Feature not supported currently */
export declare class FeatureNotSupportedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidSystemWallet: Invalid system wallet */
export declare class InvalidSystemWalletError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** OnlySaleDelegateCanTransfer: Only the sale delegate can transfer while its set */
export declare class OnlySaleDelegateCanTransferError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingTokenAccount: Missing token account */
export declare class MissingTokenAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingSplTokenProgram: Missing SPL token program */
export declare class MissingSplTokenProgramError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingAuthorizationRulesProgram: Missing authorization rules program */
export declare class MissingAuthorizationRulesProgramError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidDelegateRoleForTransfer: Invalid delegate role for transfer */
export declare class InvalidDelegateRoleForTransferError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidTransferAuthority: Invalid transfer authority */
export declare class InvalidTransferAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InstructionNotSupported: Instruction not supported for ProgrammableNonFungible assets */
export declare class InstructionNotSupportedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** KeyMismatch: Public key does not match expected value */
export declare class KeyMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** LockedToken: Token is locked */
export declare class LockedTokenError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UnlockedToken: Token is unlocked */
export declare class UnlockedTokenError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingDelegateRole: Missing delegate role */
export declare class MissingDelegateRoleError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidAuthorityType: Invalid authority type */
export declare class InvalidAuthorityTypeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingTokenRecord: Missing token record account */
export declare class MissingTokenRecordError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MintSupplyMustBeZero: Mint supply must be zero for programmable assets */
export declare class MintSupplyMustBeZeroError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DataIsEmptyOrZeroed: Data is empty or zeroed */
export declare class DataIsEmptyOrZeroedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingTokenOwnerAccount: Missing token owner */
export declare class MissingTokenOwnerAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMasterEditionAccountLength: Master edition account has an invalid length */
export declare class InvalidMasterEditionAccountLengthError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** IncorrectTokenState: Incorrect token state */
export declare class IncorrectTokenStateError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidDelegateRole: Invalid delegate role */
export declare class InvalidDelegateRoleError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingPrintSupply: Print supply is required for non-fungibles */
export declare class MissingPrintSupplyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingMasterEditionAccount: Missing master edition account */
export declare class MissingMasterEditionAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AmountMustBeGreaterThanZero: Amount must be greater than zero */
export declare class AmountMustBeGreaterThanZeroError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidDelegateArgs: Invalid delegate args */
export declare class InvalidDelegateArgsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingLockedTransferAddress: Missing address for locked transfer */
export declare class MissingLockedTransferAddressError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidLockedTransferAddress: Invalid destination address for locked transfer */
export declare class InvalidLockedTransferAddressError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DataIncrementLimitExceeded: Exceeded account realloc increase limit */
export declare class DataIncrementLimitExceededError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotUpdateAssetWithDelegate: Cannot update the rule set of a programmable asset that has a delegate */
export declare class CannotUpdateAssetWithDelegateError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidAmount: Invalid token amount for this operation or token standard */
export declare class InvalidAmountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingMasterEditionMintAccount: Missing master edition mint account */
export declare class MissingMasterEditionMintAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingMasterEditionTokenAccount: Missing master edition token account */
export declare class MissingMasterEditionTokenAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingEditionMarkerAccount: Missing edition marker account */
export declare class MissingEditionMarkerAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotBurnWithDelegate: Cannot burn while persistent delegate is set */
export declare class CannotBurnWithDelegateError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingEdition: Missing edition account */
export declare class MissingEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidAssociatedTokenAccountProgram: Invalid Associated Token Account Program */
export declare class InvalidAssociatedTokenAccountProgramError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidInstructionsSysvar: Invalid InstructionsSysvar */
export declare class InvalidInstructionsSysvarError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidParentAccounts: Invalid or Unneeded parent accounts */
export declare class InvalidParentAccountsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidUpdateArgs: Authority cannot apply all update args */
export declare class InvalidUpdateArgsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InsufficientTokenBalance: Token account does not have enough tokens */
export declare class InsufficientTokenBalanceError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingCollectionMint: Missing collection account */
export declare class MissingCollectionMintError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingCollectionMasterEdition: Missing collection master edition account */
export declare class MissingCollectionMasterEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidTokenRecord: Invalid token record account */
export declare class InvalidTokenRecordError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCloseAuthority: The close authority needs to be revoked by the Utility Delegate */
export declare class InvalidCloseAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidInstruction: Invalid or removed instruction */
export declare class InvalidInstructionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingDelegateRecord: Missing delegate record */
export declare class MissingDelegateRecordError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidFeeAccount */
export declare class InvalidFeeAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMetadataFlags */
export declare class InvalidMetadataFlagsError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CannotChangeUpdateAuthorityWithDelegate: Cannot change the update authority with a delegate */
export declare class CannotChangeUpdateAuthorityWithDelegateError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMintExtensionType: Invalid mint extension type */
export declare class InvalidMintExtensionTypeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMintCloseAuthority: Invalid mint close authority */
export declare class InvalidMintCloseAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidMetadataPointer: Invalid metadata pointer */
export declare class InvalidMetadataPointerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidTokenExtensionType: Invalid token extension type */
export declare class InvalidTokenExtensionTypeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingImmutableOwnerExtension: Missing immutable owner extension */
export declare class MissingImmutableOwnerExtensionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export declare function getMplTokenMetadataErrorFromCode(code: number, program: Program, cause?: Error): ProgramError | null;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export declare function getMplTokenMetadataErrorFromName(name: string, program: Program, cause?: Error): ProgramError | null;
