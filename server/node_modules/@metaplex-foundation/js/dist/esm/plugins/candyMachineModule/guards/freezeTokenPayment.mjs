import { Buffer } from 'buffer';
import * as beet from '@metaplex-foundation/beet';
import { freezeTokenPaymentBeet, FreezeInstruction } from '@metaplex-foundation/mpl-candy-guard';
import { MintOwnerMustBeMintPayerError, UnrecognizePathForRouteInstructionError } from '../errors.mjs';
import assert from '../../../utils/assert.mjs';
import { mapSerializer, createSerializerFromBeet } from '../../../types/Serializer.mjs';
import { token } from '../../../types/Amount.mjs';

/**
 * The freezeTokenPayment guard allows minting frozen NFTs by charging
 * the payer a specific amount of tokens from a certain mint acount.
 * Frozen NFTs cannot be transferred or listed on any marketplaces until thawed.
 *
 * The funds are transferred to a freeze escrow until all NFTs are thaw,
 * at which point, they can be transferred (unlocked) to the configured
 * destination account.
 *
 * This object defines the settings that should be
 * provided when creating and/or updating a Candy
 * Machine if you wish to enable this guard.
 *
 * @see {@link FreezeTokenPaymentGuardRouteSettings} to learn more about
 * the instructions that can be executed against this guard.
 */

/** @internal */
const freezeTokenPaymentGuardManifest = {
  name: 'freezeTokenPayment',
  settingsBytes: 72,
  settingsSerializer: mapSerializer(createSerializerFromBeet(freezeTokenPaymentBeet), settings => ({
    mint: settings.mint,
    amount: token(settings.amount),
    destinationAta: settings.destinationAta
  }), settings => ({
    mint: settings.mint,
    amount: settings.amount.basisPoints,
    destinationAta: settings.destinationAta
  })),
  mintSettingsParser: ({
    metaplex,
    settings,
    owner,
    payer,
    mint: nftMint,
    candyMachine,
    candyGuard,
    programs
  }) => {
    if (!owner.equals(payer.publicKey)) {
      throw new MintOwnerMustBeMintPayerError('freezeTokenPayment');
    }
    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
      destination: settings.destinationAta,
      candyMachine,
      candyGuard,
      programs
    });
    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({
      mint: nftMint.publicKey,
      owner: payer.publicKey
    });
    const tokenAddress = metaplex.tokens().pdas().associatedTokenAccount({
      mint: settings.mint,
      owner: payer.publicKey,
      programs
    });
    const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({
      mint: settings.mint,
      owner: freezeEscrow,
      programs
    });
    return {
      arguments: Buffer.from([]),
      remainingAccounts: [{
        isSigner: false,
        address: freezeEscrow,
        isWritable: true
      }, {
        isSigner: false,
        address: nftAta,
        isWritable: false
      }, {
        isSigner: false,
        address: tokenAddress,
        isWritable: true
      }, {
        isSigner: false,
        address: freezeAta,
        isWritable: true
      }]
    };
  },
  routeSettingsParser: input => {
    switch (input.routeSettings.path) {
      case 'initialize':
        return initializeRouteInstruction(input);
      case 'thaw':
        return thawRouteInstruction(input);
      case 'unlockFunds':
        return unlockFundsRouteInstruction(input);
      default:
        throw new UnrecognizePathForRouteInstructionError('freezeTokenPayment',
        // @ts-ignore
        input.routeSettings.path);
    }
  }
};
function initializeRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert(routeSettings.path === 'initialize');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destinationAta,
    candyMachine,
    candyGuard,
    programs
  });
  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: settings.mint,
    owner: freezeEscrow,
    programs
  });
  const systemProgram = metaplex.programs().getSystem(programs);
  const tokenProgram = metaplex.programs().getToken(programs);
  const associatedTokenProgram = metaplex.programs().getAssociatedToken(programs);
  const args = Buffer.alloc(9);
  beet.u8.write(args, 0, FreezeInstruction.Initialize);
  beet.u64.write(args, 1, routeSettings.period);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: true,
      address: routeSettings.candyGuardAuthority,
      isWritable: false
    }, {
      isSigner: false,
      address: systemProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: freezeAta,
      isWritable: true
    }, {
      isSigner: false,
      address: settings.mint,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: associatedTokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: settings.destinationAta,
      isWritable: true
    }]
  };
}
function thawRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert(routeSettings.path === 'thaw');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destinationAta,
    candyMachine,
    candyGuard,
    programs
  });
  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: routeSettings.nftMint,
    owner: routeSettings.nftOwner,
    programs
  });
  const nftEdition = metaplex.nfts().pdas().masterEdition({
    mint: routeSettings.nftMint,
    programs
  });
  const tokenProgram = metaplex.programs().getToken(programs);
  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);
  const args = Buffer.alloc(1);
  beet.u8.write(args, 0, FreezeInstruction.Thaw);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: false,
      address: routeSettings.nftMint,
      isWritable: false
    }, {
      isSigner: false,
      address: routeSettings.nftOwner,
      isWritable: false
    }, {
      isSigner: false,
      address: nftAta,
      isWritable: true
    }, {
      isSigner: false,
      address: nftEdition,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenMetadataProgram.address,
      isWritable: false
    }]
  };
}
function unlockFundsRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert(routeSettings.path === 'unlockFunds');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destinationAta,
    candyMachine,
    candyGuard,
    programs
  });
  const freezeAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: settings.mint,
    owner: freezeEscrow,
    programs
  });
  const systemProgram = metaplex.programs().getSystem(programs);
  const tokenProgram = metaplex.programs().getToken(programs);
  const args = Buffer.alloc(1);
  beet.u8.write(args, 0, FreezeInstruction.UnlockFunds);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: true,
      address: routeSettings.candyGuardAuthority,
      isWritable: false
    }, {
      isSigner: false,
      address: freezeAta,
      isWritable: true
    }, {
      isSigner: false,
      address: settings.destinationAta,
      isWritable: true
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: systemProgram.address,
      isWritable: false
    }]
  };
}

export { freezeTokenPaymentGuardManifest };
//# sourceMappingURL=freezeTokenPayment.mjs.map
