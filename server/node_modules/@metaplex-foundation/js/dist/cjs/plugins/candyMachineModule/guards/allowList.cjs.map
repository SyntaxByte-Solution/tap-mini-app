{"version":3,"file":"allowList.cjs","sources":["../../../../../src/plugins/candyMachineModule/guards/allowList.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport * as beet from '@metaplex-foundation/beet';\nimport { AllowList, allowListBeet } from '@metaplex-foundation/mpl-candy-guard';\nimport { CandyGuardManifest } from './core';\nimport { createSerializerFromBeet, mapSerializer } from '@/types';\n\n/**\n * The allowList guard validates the minting wallet against\n * a predefined list of wallets.\n *\n * Instead of passing the entire list of wallets as settings,\n * this guard accepts the Root of a Merkle Tree created from\n * this allow list. The program can then validate that the minting\n * wallet is part of the allow list by requiring a Merkle Proof.\n * Minting will fail if either the minting address is not part of\n * the merkle tree or if no Merkle Proof is specified.\n *\n * You may use the `getMerkleRoot` and `getMerkleProof` helper\n * functions provided by the SDK to help you set up this guard.\n * Here is an example.\n *\n * ```ts\n * import { getMerkleProof, getMerkleRoot } from '@metaplex-foundation/js';\n * const allowList = [\n *   'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB',\n *   'GjwcWFQYzemBtpUoN5fMAP2FZviTtMRWCmrppGuTthJS',\n *   'AT8nPwujHAD14cLojTcB1qdBzA1VXnT6LVGuUd6Y73Cy',\n * ];\n * const merkleRoot = getMerkleRoot(allowList);\n * const validMerkleProof = getMerkleProof(allowList, 'Ur1CbWSGsXCdedknRbJsEk7urwAvu1uddmQv51nAnXB');\n * const invalidMerkleProof = getMerkleProof(allowList, 'invalid-address');\n * ```\n *\n * Note that you will need to provide the Merkle Proof for the\n * minting wallet before calling the mint instruction via the\n * special \"route\" instruction of the guard.\n * See {@link AllowListGuardRouteSettings} for more information.\n *\n * This object defines the settings that should be\n * provided when creating and/or updating a Candy\n * Machine if you wish to enable this guard.\n *\n * @see {@link AllowListGuardRouteSettings} to learn more about\n * the instructions that can be executed against this guard.\n */\nexport type AllowListGuardSettings = {\n  /**\n   * The Root of the Merkle Tree representing the allow list.\n   * You may use the `getMerkleRoot` helper function to generate this.\n   */\n  merkleRoot: Uint8Array;\n};\n\n/**\n * The settings for the allowList guard that should be provided\n * when accessing the guard's special \"route\" instruction.\n *\n * ## Proof\n * The `proof` path allows you to provide a Merkle Proof\n * for a specific wallet in order to allow minting for that wallet.\n * This will create a small PDA account on the Program as a proof\n * that the wallet has been allowed to mint.\n *\n * ```ts\n * await metaplex.candyMachines().callGuardRoute({\n *   candyMachine,\n *   guard: 'allowList',\n *   settings: {\n *     path: 'proof',\n *     merkleProof: getMerkleProof(allowedWallets, metaplex.identity().publicKey.toBase58()),\n *   },\n * });\n *\n * // You are now allows to mint with this wallet.\n * ```\n *\n * @see {@link AllowListGuardSettings} for more\n * information on the allowList guard itself.\n */\nexport type AllowListGuardRouteSettings = {\n  /** Selects the path to execute in the route instruction. */\n  path: 'proof';\n\n  /**\n   * The Proof that the minting wallet is part of the\n   * Merkle Tree-based allow list. You may use the\n   * `getMerkleProof` helper function to generate this.\n   */\n  merkleProof: Uint8Array[];\n};\n\n/** @internal */\nexport const allowListGuardManifest: CandyGuardManifest<\n  AllowListGuardSettings,\n  {},\n  AllowListGuardRouteSettings\n> = {\n  name: 'allowList',\n  settingsBytes: 32,\n  settingsSerializer: mapSerializer<AllowList, AllowListGuardSettings>(\n    createSerializerFromBeet(allowListBeet),\n    (settings) => ({ merkleRoot: new Uint8Array(settings.merkleRoot) }),\n    (settings) => ({ merkleRoot: Array.from(settings.merkleRoot) })\n  ),\n  mintSettingsParser: ({\n    metaplex,\n    settings,\n    payer,\n    candyMachine,\n    candyGuard,\n  }) => {\n    return {\n      arguments: Buffer.from([]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          isWritable: false,\n          address: metaplex.candyMachines().pdas().merkleProof({\n            merkleRoot: settings.merkleRoot,\n            user: payer.publicKey,\n            candyMachine,\n            candyGuard,\n          }),\n        },\n      ],\n    };\n  },\n  routeSettingsParser: ({\n    metaplex,\n    settings,\n    routeSettings,\n    programs,\n    candyMachine,\n    candyGuard,\n    payer,\n  }) => {\n    const proof = routeSettings.merkleProof;\n    const vectorSize = Buffer.alloc(4);\n    beet.u32.write(vectorSize, 0, proof.length);\n\n    return {\n      arguments: Buffer.concat([vectorSize, ...proof]),\n      remainingAccounts: [\n        {\n          isSigner: false,\n          isWritable: true,\n          address: metaplex.candyMachines().pdas().merkleProof({\n            merkleRoot: settings.merkleRoot,\n            user: payer.publicKey,\n            candyMachine,\n            candyGuard,\n          }),\n        },\n        {\n          isSigner: false,\n          isWritable: false,\n          address: metaplex.programs().getSystem(programs).address,\n        },\n      ],\n    };\n  },\n};\n"],"names":["allowListGuardManifest","name","settingsBytes","settingsSerializer","mapSerializer","createSerializerFromBeet","allowListBeet","settings","merkleRoot","Uint8Array","Array","from","mintSettingsParser","metaplex","payer","candyMachine","candyGuard","arguments","Buffer","remainingAccounts","isSigner","isWritable","address","candyMachines","pdas","merkleProof","user","publicKey","routeSettingsParser","routeSettings","programs","proof","vectorSize","alloc","beet","u32","write","length","concat","getSystem"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA+CA;AACO,MAAMA,sBAIZ,GAAG;AACFC,EAAAA,IAAI,EAAE,WAAW;AACjBC,EAAAA,aAAa,EAAE,EAAE;EACjBC,kBAAkB,EAAEC,wBAAa,CAC/BC,mCAAwB,CAACC,2BAAa,CAAC,EACtCC,QAAQ,KAAM;AAAEC,IAAAA,UAAU,EAAE,IAAIC,UAAU,CAACF,QAAQ,CAACC,UAAU,CAAA;GAAG,CAAC,EAClED,QAAQ,KAAM;AAAEC,IAAAA,UAAU,EAAEE,KAAK,CAACC,IAAI,CAACJ,QAAQ,CAACC,UAAU,CAAA;AAAE,GAAC,CAAC,CAChE;AACDI,EAAAA,kBAAkB,EAAE,CAAC;IACnBC,QAAQ;IACRN,QAAQ;IACRO,KAAK;IACLC,YAAY;AACZC,IAAAA,UAAAA;AACF,GAAC,KAAK;IACJ,OAAO;AACLC,MAAAA,SAAS,EAAEC,aAAM,CAACP,IAAI,CAAC,EAAE,CAAC;AAC1BQ,MAAAA,iBAAiB,EAAE,CACjB;AACEC,QAAAA,QAAQ,EAAE,KAAK;AACfC,QAAAA,UAAU,EAAE,KAAK;QACjBC,OAAO,EAAET,QAAQ,CAACU,aAAa,EAAE,CAACC,IAAI,EAAE,CAACC,WAAW,CAAC;UACnDjB,UAAU,EAAED,QAAQ,CAACC,UAAU;UAC/BkB,IAAI,EAAEZ,KAAK,CAACa,SAAS;UACrBZ,YAAY;AACZC,UAAAA,UAAAA;SACD,CAAA;OACF,CAAA;KAEJ,CAAA;GACF;AACDY,EAAAA,mBAAmB,EAAE,CAAC;IACpBf,QAAQ;IACRN,QAAQ;IACRsB,aAAa;IACbC,QAAQ;IACRf,YAAY;IACZC,UAAU;AACVF,IAAAA,KAAAA;AACF,GAAC,KAAK;AACJ,IAAA,MAAMiB,KAAK,GAAGF,aAAa,CAACJ,WAAW,CAAA;AACvC,IAAA,MAAMO,UAAU,GAAGd,aAAM,CAACe,KAAK,CAAC,CAAC,CAAC,CAAA;AAClCC,IAAAA,eAAI,CAACC,GAAG,CAACC,KAAK,CAACJ,UAAU,EAAE,CAAC,EAAED,KAAK,CAACM,MAAM,CAAC,CAAA;IAE3C,OAAO;MACLpB,SAAS,EAAEC,aAAM,CAACoB,MAAM,CAAC,CAACN,UAAU,EAAE,GAAGD,KAAK,CAAC,CAAC;AAChDZ,MAAAA,iBAAiB,EAAE,CACjB;AACEC,QAAAA,QAAQ,EAAE,KAAK;AACfC,QAAAA,UAAU,EAAE,IAAI;QAChBC,OAAO,EAAET,QAAQ,CAACU,aAAa,EAAE,CAACC,IAAI,EAAE,CAACC,WAAW,CAAC;UACnDjB,UAAU,EAAED,QAAQ,CAACC,UAAU;UAC/BkB,IAAI,EAAEZ,KAAK,CAACa,SAAS;UACrBZ,YAAY;AACZC,UAAAA,UAAAA;SACD,CAAA;AACH,OAAC,EACD;AACEI,QAAAA,QAAQ,EAAE,KAAK;AACfC,QAAAA,UAAU,EAAE,KAAK;QACjBC,OAAO,EAAET,QAAQ,CAACiB,QAAQ,EAAE,CAACS,SAAS,CAACT,QAAQ,CAAC,CAACR,OAAAA;OAClD,CAAA;KAEJ,CAAA;AACH,GAAA;AACF;;;;"}