{"version":3,"file":"createSft.cjs","sources":["../../../../../src/plugins/nftModule/operations/createSft.ts"],"sourcesContent":["import {\n  createCreateInstruction,\n  PrintSupply,\n  TokenStandard,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport {\n  Keypair,\n  PublicKey,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n} from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertSft, isNonFungible, Sft, SftWithToken } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  Creator,\n  CreatorInput,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateSftOperation' as const;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const { sft } = await metaplex\n *   .nfts()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createSftOperation = useOperation<CreateSftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateSftOperation = Operation<\n  typeof Key,\n  CreateSftInput,\n  CreateSftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateSftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority allowed to mint new tokens for the mint account\n   * that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the SFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an SFT. The account at this address should have the right\n   * requirements to become an SFT, e.g. it shouldn't already have\n   * a metadata account associated with it.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * An explicit token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account.\n   *\n   * When provided, the token account will be created if and only\n   * if no account exists at the given address. When that's the case,\n   * the `tokenAddress` must be provided as a Signer as we're creating\n   * and initializing the account at this address.\n   *\n   * You may alternatively pass the `tokenOwner` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /**\n   * The amount of tokens to mint to the token account initially\n   * if a token account is created.\n   *\n   * This is only relevant if either the `tokenOwner` or `tokenAddress`\n   * is provided.\n   *\n   * @defaultValue Defaults to not minting any tokens.\n   */\n  tokenAmount?: SplTokenAmount;\n\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /**\n   * Describes the asset class of the token.\n   * It can be one of the following:\n   * - `TokenStandard.NonFungible`: A traditional NFT (master edition).\n   * - `TokenStandard.FungibleAsset`: A fungible token with metadata that can also have attrributes.\n   * - `TokenStandard.Fungible`: A fungible token with simple metadata.\n   * - `TokenStandard.NonFungibleEdition`: A limited edition NFT \"printed\" from a master edition.\n   * - `TokenStandard.ProgrammableNonFungible`: A master edition NFT with programmable configuration.\n   *\n   * @defaultValue `TokenStandard.FungibleAsset`\n   */\n  tokenStandard?: TokenStandard;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * The maximum supply of printed editions for NFTs.\n   * When this is `null`, an unlimited amount of editions\n   * can be printed from the original edition.\n   *\n   * @defaultValue `toBigNumber(0)`\n   */\n  maxSupply?: Option<BigNumber>;\n\n  /**\n   * Whether or not selling this asset is considered a primary sale.\n   * Once flipped from `false` to `true`, this field is immutable and\n   * all subsequent sales of this asset will be considered secondary.\n   *\n   * @defaultValue `false`\n   */\n  primarySaleHappened?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created SFT is a Collection SFT.\n   * When set to `true`, the SFT will be created as a\n   * Sized Collection SFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n\n  /**\n   * The ruleset account that should be used to configure the\n   * programmable NFT.\n   *\n   * This is only relevant for programmable NFTs, i.e. if the\n   * `tokenStandard` is set to `TokenStandard.ProgrammableNonFungible`.\n   *\n   * @defaultValue `null`\n   */\n  ruleSet?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateSftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created SFT and, potentially, its associated token. */\n  sft: Sft | SftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the token account if any. */\n  tokenAddress: PublicKey | null;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createSftOperationHandler: OperationHandler<CreateSftOperation> = {\n  handle: async (\n    operation: CreateSftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const associatedTokenAddress = tokenOwner\n      ? metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        })\n      : null;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : associatedTokenAddress;\n\n    let tokenExists: boolean;\n    if (!!useExistingMint && !!tokenAddress) {\n      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n      tokenExists = tokenAccount.exists;\n    } else {\n      tokenExists = false;\n    }\n\n    const builder = await createSftBuilder(\n      metaplex,\n      { ...operation.input, useNewMint, tokenExists },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const sft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress ?? undefined,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertSft(sft);\n    return { ...output, sft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateSftBuilderParams = Omit<CreateSftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateSftBuilderContext = Omit<CreateSftOutput, 'response' | 'sft'>;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateSftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n    tokenStandard = params.tokenStandard ?? TokenStandard.FungibleAsset,\n  } = params;\n\n  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;\n  const associatedTokenAddress = params.tokenOwner\n    ? metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        programs,\n      })\n    : null;\n  const tokenAddress = params.tokenAddress\n    ? toPublicKey(params.tokenAddress)\n    : associatedTokenAddress;\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadataPda = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const masterEditionPda = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  let printSupply: Option<PrintSupply> = null;\n  if (isNonFungible({ tokenStandard })) {\n    if (params.maxSupply === undefined) {\n      printSupply = { __kind: 'Zero' };\n    } else if (params.maxSupply === null) {\n      printSupply = { __kind: 'Unlimited' };\n    } else {\n      printSupply = { __kind: 'Limited', fields: [params.maxSupply] };\n    }\n  }\n\n  const createInstruction = createCreateInstruction(\n    {\n      metadata: metadataPda,\n      masterEdition: isNonFungible({ tokenStandard })\n        ? masterEditionPda\n        : undefined,\n      mint: mintAddress,\n      authority: mintAuthority.publicKey,\n      payer: payer.publicKey,\n      updateAuthority: updateAuthority.publicKey,\n      systemProgram: systemProgram.address,\n      sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n      splTokenProgram: tokenProgram.address,\n    },\n    {\n      createArgs: {\n        __kind: 'V1' as const,\n        assetData: {\n          name: params.name,\n          symbol: params.symbol ?? '',\n          uri: params.uri,\n          sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n          creators,\n          primarySaleHappened: params.primarySaleHappened ?? false,\n          isMutable: params.isMutable ?? true,\n          tokenStandard,\n          collection: params.collection\n            ? { key: params.collection, verified: false }\n            : null,\n          uses: params.uses ?? null,\n          collectionDetails: params.isCollection\n            ? { __kind: 'V1' as const, size: 0 } // Size ignored by program.\n            : null,\n          ruleSet: params.ruleSet ?? null,\n        },\n        decimals: params.decimals ?? 0,\n        printSupply,\n      },\n    },\n    tokenMetadataProgram.address\n  );\n\n  const createSigners = [payer, mintAuthority, updateAuthority];\n  if (!params.useExistingMint) {\n    createSigners.push(useNewMint);\n    createInstruction.keys[2].isSigner = true;\n  }\n\n  // When the payer is different than the update authority, the latter will\n  // not be marked as a signer and therefore signing as a creator will fail.\n  createInstruction.keys[5].isSigner = true;\n\n  let createNonAtaInstruction: TransactionBuilder | null = null;\n  // Create the token account if it doesn't exist.\n  if (\n    !params.tokenExists &&\n    !!params.tokenAddress &&\n    isSigner(params.tokenAddress)\n  ) {\n    createNonAtaInstruction = await metaplex.tokens().builders().createToken(\n      {\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        token: params.tokenAddress,\n        createAccountInstructionKey: params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n      },\n      { programs, payer }\n    );\n  }\n\n  // Mint provided amount to the token account.\n  let mintInstruction: TransactionBuilder | null = null;\n  if (tokenAddress && params.tokenAmount) {\n    mintInstruction = metaplex\n      .nfts()\n      .builders()\n      .mint(\n        {\n          nftOrSft: {\n            address: mintAddress,\n            tokenStandard,\n          },\n          authority: isNonFungible({ tokenStandard })\n            ? updateAuthority\n            : mintAuthority,\n          toOwner: params.tokenOwner,\n          toToken: tokenAddress,\n          amount: params.tokenAmount,\n        },\n        { programs, payer }\n      );\n  }\n\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      return (\n        !!creator.authority &&\n        !creator.address.equals(updateAuthority.publicKey)\n      );\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress,\n          creator: creator.authority,\n        },\n        { programs, payer }\n      );\n    });\n\n  return (\n    TransactionBuilder.make<CreateSftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress: metadataPda,\n        tokenAddress,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      // .add(mintAndTokenBuilder)\n\n      // Create metadata/edition accounts.\n      .add({\n        instruction: createInstruction,\n        signers: createSigners,\n        key: params.createInstructionKey ?? 'createMetadata',\n      })\n\n      // Create the non-associated token account if needed.\n      .add(...(createNonAtaInstruction ? [createNonAtaInstruction] : []))\n\n      // Mint provided amount to the token account, if any.\n      .add(...(mintInstruction ? [mintInstruction] : []))\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { payer, programs }\n            )\n        )\n      )\n  );\n};\n"],"names":["Key","createSftOperation","useOperation","createSftOperationHandler","handle","operation","metaplex","scope","useNewMint","Keypair","generate","useExistingMint","tokenOwner","tokenAddress","tokenSigner","input","mintAddress","publicKey","associatedTokenAddress","tokens","pdas","associatedTokenAccount","mint","owner","programs","toPublicKey","tokenExists","tokenAccount","rpc","getAccount","exists","builder","createSftBuilder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","sft","nfts","findByMint","undefined","assertSft","params","options","payer","getDefaultFeePayer","updateAuthority","identity","mintAuthority","tokenStandard","TokenStandard","FungibleAsset","systemProgram","getSystem","tokenProgram","getToken","tokenMetadataProgram","getTokenMetadata","metadataPda","metadata","masterEditionPda","masterEdition","creatorsInput","creators","address","authority","share","length","map","creator","verified","equals","printSupply","isNonFungible","maxSupply","__kind","fields","createInstruction","createCreateInstruction","sysvarInstructions","SYSVAR_INSTRUCTIONS_PUBKEY","splTokenProgram","createArgs","assetData","name","symbol","uri","sellerFeeBasisPoints","primarySaleHappened","isMutable","collection","key","uses","collectionDetails","isCollection","size","ruleSet","decimals","createSigners","push","keys","isSigner","createNonAtaInstruction","builders","createToken","token","createAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","mintInstruction","tokenAmount","nftOrSft","toOwner","toToken","amount","verifyAdditionalCreatorInstructions","filter","verifyCreator","TransactionBuilder","make","setFeePayer","setContext","metadataAddress","add","instruction","signers","createInstructionKey","when","collectionAuthority","verifyCollection","collectionMintAddress","isDelegated","collectionAuthorityIsDelegated","isSizedCollection","collectionIsSized"],"mappings":"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"}