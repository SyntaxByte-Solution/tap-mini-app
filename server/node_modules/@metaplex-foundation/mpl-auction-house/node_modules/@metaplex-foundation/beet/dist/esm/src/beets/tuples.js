import { BEET_PACKAGE, } from '../types';
import { strict as assert } from 'assert';
import { fixBeetFromData, fixBeetFromValue } from '../beet.fixable';
// Tuples are a special kind of composite which can be understood as
// fixed length arrays where each tuple element can have a different data type.
// Since the Tuple type itself dictates the length, and buffer layout, no extra
// information is included in the serialized data.
/**
 * De/Serializes a tuple with all fixed size tuple elements .
 * Since each tuple element can be of a different type not much type safety can
 * be provided here.
 *
 * @param elements the De/Serializer for each tuple element type
 *
 * @category beet/composite
 */
export function fixedSizeTuple(elements) {
    const len = elements.length;
    const elDescs = elements.map((x) => x.description);
    const byteSizes = elements.map((x) => x.byteSize);
    const byteSize = byteSizes.reduce((acc, x) => acc + x, 0);
    return {
        write: function (buf, offset, value) {
            assert.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);
            let cursor = offset;
            for (let i = 0; i < len; i++) {
                const v = value[i];
                const beetEl = elements[i];
                beetEl.write(buf, cursor, v);
                cursor += beetEl.byteSize;
            }
        },
        read: function (buf, offset) {
            const els = [];
            let cursor = offset;
            for (let i = 0; i < len; i++) {
                const elBeet = elements[i];
                els[i] = elBeet.read(buf, cursor);
                cursor += elBeet.byteSize;
            }
            return els;
        },
        byteSize,
        length: len,
        description: `FixedSizeTuple<${elDescs.join(',')}>[ ${byteSizes.join(', ')} ]`,
    };
}
/**
 * De/Serializes a tuple which contains some non-fixed size tuple elements.
 *
 * Since each tuple element can be of a different type not much type safety can
 * be provided here.
 *
 * @param elements the De/Serializer for each tuple element type
 * @category beet/composite
 */
export function tuple(elements) {
    const len = elements.length;
    const elDescs = elements.map((x) => x.description);
    return {
        toFixedFromData(buf, offset) {
            let cursor = offset;
            const fixedElements = new Array(len);
            for (let i = 0; i < len; i++) {
                const fixedElement = fixBeetFromData(elements[i], buf, cursor);
                fixedElements[i] = fixedElement;
                cursor += fixedElement.byteSize;
            }
            return fixedSizeTuple(fixedElements);
        },
        toFixedFromValue(vals) {
            assert(Array.isArray(vals), `${vals} should be an array of tuple values`);
            assert.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);
            const fixedElements = new Array(len);
            for (let i = 0; i < vals.length; i++) {
                const fixedElement = fixBeetFromValue(elements[i], vals[i]);
                fixedElements[i] = fixedElement;
            }
            return fixedSizeTuple(fixedElements);
        },
        description: `Tuple<${elDescs.join(',')}>`,
    };
}
/**
 * Maps tuples beet exports to metadata which describes in which package it
 * is defined as well as which TypeScript type is used to represent the
 * deserialized value in JavaScript.
 *
 * @category TypeDefinition
 */
export const tuplesTypeMap = {
    Tuple: {
        beet: 'tuple',
        isFixable: true,
        sourcePack: BEET_PACKAGE,
        ts: '[__tuple_elements__]',
    },
    FixedSizeTuple: {
        beet: 'fixedSizeTuple',
        isFixable: false,
        sourcePack: BEET_PACKAGE,
        ts: '[__tuple_elements__]',
    },
};
//# sourceMappingURL=tuples.js.map