"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = void 0;
const base64url_1 = __importDefault(require("base64url"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const async_retry_1 = __importDefault(require("async-retry"));
bignumber_js_1.default.set({ DECIMAL_PLACES: 50 });
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
exports.sleep = sleep;
class Utils {
    constructor(api, token, tokenConfig) {
        this.api = api;
        this.token = token;
        this.tokenConfig = tokenConfig;
        this.arbundles = this.tokenConfig.irys.arbundles;
    }
    /**
     * Throws an error if the provided axios reponse has a status code != 200
     * @param res an axios response
     * @returns nothing if the status code is 200
     */
    static checkAndThrow(res, context, exceptions) {
        if ((res === null || res === void 0 ? void 0 : res.status) && !(exceptions !== null && exceptions !== void 0 ? exceptions : []).includes(res.status) && res.status != 200) {
            throw new Error(`HTTP Error: ${context}: ${res.status} ${typeof res.data !== "string" ? res.statusText : res.data}`);
        }
        return;
    }
    /**
     * Gets the nonce used for withdrawal request validation from the bundler
     * @returns nonce for the current user
     */
    getNonce() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.api.get(`/account/withdrawals/${this.tokenConfig.name}?address=${this.tokenConfig.address}`);
            Utils.checkAndThrow(res, "Getting withdrawal nonce");
            return res.data;
        });
    }
    /**
     * Gets the balance on the current bundler for the specified user
     * @param address the user's address to query
     * @returns the balance in winston
     */
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.api.get(`/account/balance/${this.tokenConfig.name}?address=${address}`);
            Utils.checkAndThrow(res, "Getting balance");
            return new bignumber_js_1.default(res.data.balance);
        });
    }
    /**
     * Queries the bundler to get it's address for a specific token
     * @returns the bundler's address
     */
    getBundlerAddress(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.api.get("/info");
            Utils.checkAndThrow(res, "Getting Bundler address");
            const address = res.data.addresses[token];
            if (!address) {
                throw new Error(`Specified bundler does not support token ${token}`);
            }
            return address;
        });
    }
    /**
     * Calculates the price for [bytes] bytes paid for with [token] for the loaded Irys node.
     * @param token
     * @param bytes
     * @returns
     */
    getPrice(token, bytes) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.api.get(`/price/${token}/${bytes}`);
            Utils.checkAndThrow(res, "Getting storage cost");
            return new bignumber_js_1.default(res.data);
        });
    }
    /**
     * This function *estimates* the cost in atomic units for uploading a given set of files
     * note: this function becomes less accurate the smaller your transactions, unless you provide it with an accurate headerSizeAvg
     * @param folderInfo either an array of file sizes in bytes, or an object containing the total number of files and the sum total size of the files in bytes
     * note: for a more precise estimate, you can create an empty (dataless) transaction (make sure you still set tags and other metadata!) and then pass `tx.size` as `headerSizeAvg`
     */
    estimateFolderPrice(folderInfo) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(folderInfo)) {
                folderInfo = {
                    fileCount: folderInfo.length,
                    totalBytes: folderInfo.reduce((acc, v) => acc + v, 0),
                };
            }
            // create a 0 data byte tx to estimate the per tx header overhead
            const headerSizeAvg = (_a = folderInfo.headerSizeAvg) !== null && _a !== void 0 ? _a : this.arbundles.createData("", this.tokenConfig.getSigner()).getRaw().length;
            const pricePerTxBase = yield this.getPrice(this.tokenConfig.name, headerSizeAvg);
            const basePriceForTxs = pricePerTxBase.multipliedBy(folderInfo.fileCount);
            const priceForData = (yield this.getPrice(this.tokenConfig.name, folderInfo.totalBytes)).plus(basePriceForTxs).decimalPlaces(0);
            return priceForData;
        });
    }
    /**
     * Returns the decimal values' equivalent in atomic units
     * @example
     * 0.1 ETH -> 100,000,000,000,000,000 wei
     * ```
     * toAtomic(100_000_000_000_000_000) -> 0.1
     * ```
     * @param decimalAmount - amount in decimal
     * @returns amount in atomic units
     */
    toAtomic(decimalAmount) {
        return new bignumber_js_1.default(decimalAmount).multipliedBy(this.tokenConfig.base[1]);
    }
    /**
     * Returns the atomic amounts' equivalent in decimal units
     * @example
     * 100,000,000,000,000,000 wei -> 0.1 ETH
     * ```
     * fromAtomic(0.1) -> 100_000_000_000_000_000
     * ```
     * @param atomicAmount
     * @returns
     */
    fromAtomic(atomicAmount) {
        return new bignumber_js_1.default(atomicAmount).dividedBy(this.tokenConfig.base[1]);
    }
    /**
     * Polls for transaction confirmation (or at least pending status) - used for fast currencies (i.e not arweave)
     * before posting the fund request to the server (so the server doesn't have to poll)
     * @param txid
     * @returns
     */
    confirmationPoll(txid, seconds = 30) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenConfig.isSlow)
                return;
            if (seconds < 0)
                seconds = 0;
            let lastError;
            let timedout;
            const internalPoll = () => __awaiter(this, void 0, void 0, function* () {
                while (!timedout) {
                    const getRes = yield this.tokenConfig
                        .getTx(txid)
                        .then((v) => v === null || v === void 0 ? void 0 : v.confirmed)
                        .catch((err) => {
                        lastError = err;
                        return false;
                    });
                    if (getRes)
                        return true;
                    yield (0, exports.sleep)(1000);
                }
                return false;
            });
            const racer = () => __awaiter(this, void 0, void 0, function* () {
                yield (0, exports.sleep)(seconds * 1000);
                timedout = true;
                return "RACE";
            });
            const r = yield Promise.race([racer(), internalPoll()]);
            if (r === "RACE") {
                console.warn(`Tx ${txid} didn't finalize after ${seconds} seconds ${lastError ? ` - ${lastError}` : ""}`);
                return lastError;
            }
            return r;
        });
    }
    /**
     * @deprecated this method is deprecated in favour of fromAtomic - removal slated for 0.12.0
     */
    unitConverter(baseUnits) {
        return new bignumber_js_1.default(baseUnits).dividedBy(this.tokenConfig.base[1]);
    }
    verifyReceipt(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            return Utils.verifyReceipt(this.arbundles, receipt);
        });
    }
    static verifyReceipt(dependencies, receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, deadlineHeight, timestamp, public: pubKey, signature, version } = receipt;
            const dh = yield dependencies.deepHash([
                dependencies.stringToBuffer("Bundlr"),
                dependencies.stringToBuffer(version),
                dependencies.stringToBuffer(id),
                dependencies.stringToBuffer(deadlineHeight.toString()),
                dependencies.stringToBuffer(timestamp.toString()),
            ]);
            return yield dependencies.getCryptoDriver().verify(pubKey, dh, base64url_1.default.toBuffer(signature));
        });
    }
    getReceipt(txId) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            // get receipt information from GQL
            const query = `query {
      transactions(ids: ["${txId}"]) {
        edges {
          node {
            receipt {
              signature
              timestamp
              version
              deadlineHeight
            }
          }
        }
      }
    }`;
            const queryRes = yield (0, async_retry_1.default)(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.api.post("/graphql", { query }, {
                    headers: { "content-type": "application/json" },
                    validateStatus: (s) => s === 200,
                });
            }));
            const receiptData = (_f = (_e = (_d = (_c = (_b = (_a = queryRes === null || queryRes === void 0 ? void 0 : queryRes.data) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.transactions) === null || _c === void 0 ? void 0 : _c.edges) === null || _d === void 0 ? void 0 : _d.at(0)) === null || _e === void 0 ? void 0 : _e.node) === null || _f === void 0 ? void 0 : _f.receipt;
            if (!receiptData)
                throw new Error(`Missing required receipt data from node for tx: ${txId}`);
            // get public key from node
            const pubKey = (yield this.api.get("/public")).data;
            const receipt = {
                public: pubKey,
                version: receiptData.version,
                id: txId,
                timestamp: receiptData.timestamp,
                validatorSignatures: [],
                signature: receiptData.signature,
                deadlineHeight: receiptData.deadlineHeight,
                // use stub to conform to type
                verify: () => __awaiter(this, void 0, void 0, function* () {
                    return false;
                }),
            };
            // inject method
            receipt.verify = () => __awaiter(this, void 0, void 0, function* () { return this.verifyReceipt(receipt); });
            return receipt;
        });
    }
}
exports.default = Utils;
//# sourceMappingURL=utils.js.map