'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var merkletreejs = require('merkletreejs');
var sha3 = require('@noble/hashes/sha3');

/**
 * Describes the required data input for
 * handling Merkle Tree operations.
 */

/**
 * Creates a Merkle Tree from the provided data.
 */
const getMerkleTree = data => {
  return new merkletreejs.MerkleTree(data.map(sha3.keccak_256), sha3.keccak_256, {
    sortPairs: true
  });
};

/**
 * Creates a Merkle Root from the provided data.
 *
 * This root provides a short identifier for the
 * provided data that is unique and deterministic.
 * This means, we can use this root to verify that
 * a given data is part of the original data set.
 */
const getMerkleRoot = data => {
  return getMerkleTree(data).getRoot();
};

/**
 * Creates a Merkle Proof for a given data item.
 *
 * This proof can be used to verify that the given
 * data item is part of the original data set.
 */
const getMerkleProof = (data, leaf, index) => {
  return getMerkleTree(data).getProof(Buffer.from(sha3.keccak_256(leaf)), index).map(proofItem => proofItem.data);
};

/**
 * Creates a Merkle Proof for a data item at a given index.
 *
 * This proof can be used to verify that the data item at
 * the given index is part of the original data set.
 */
const getMerkleProofAtIndex = (data, index) => {
  return getMerkleProof(data, data[index], index);
};

exports.getMerkleProof = getMerkleProof;
exports.getMerkleProofAtIndex = getMerkleProofAtIndex;
exports.getMerkleRoot = getMerkleRoot;
exports.getMerkleTree = getMerkleTree;
//# sourceMappingURL=merkle.cjs.map
