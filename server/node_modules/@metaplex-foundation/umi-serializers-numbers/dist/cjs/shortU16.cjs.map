{"version":3,"file":"shortU16.cjs","sources":["../../src/shortU16.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport {\n  BaseSerializerOptions,\n  Serializer,\n} from '@metaplex-foundation/umi-serializers-core';\nimport { assertRange } from './utils';\n\n/**\n * Defines the options for the shortU16 serializer.\n * @category Serializers\n */\nexport type ShortU16SerializerOptions = BaseSerializerOptions;\n\n/**\n * Same as u16, but serialized with 1 to 3 bytes.\n *\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n *\n * @category Serializers\n */\nexport const shortU16 = (\n  options: ShortU16SerializerOptions = {}\n): Serializer<number> => ({\n  description: options.description ?? 'shortU16',\n  fixedSize: null,\n  maxSize: 3,\n  serialize: (value: number): Uint8Array => {\n    assertRange('shortU16', 0, 65535, value);\n    const bytes = [0];\n    for (let ii = 0; ; ii += 1) {\n      // Shift the bits of the value over such that the next 7 bits are at the right edge.\n      const alignedValue = value >> (ii * 7);\n      if (alignedValue === 0) {\n        // No more bits to consume.\n        break;\n      }\n      // Extract those 7 bits using a mask.\n      const nextSevenBits = 0b1111111 & alignedValue;\n      bytes[ii] = nextSevenBits;\n      if (ii > 0) {\n        // Set the continuation bit of the previous slice.\n        bytes[ii - 1] |= 0b10000000;\n      }\n    }\n    return new Uint8Array(bytes);\n  },\n  deserialize: (bytes: Uint8Array, offset = 0): [number, number] => {\n    let value = 0;\n    let byteCount = 0;\n    while (\n      ++byteCount // eslint-disable-line no-plusplus\n    ) {\n      const byteIndex = byteCount - 1;\n      const currentByte = bytes[offset + byteIndex];\n      const nextSevenBits = 0b1111111 & currentByte;\n      // Insert the next group of seven bits into the correct slot of the output value.\n      value |= nextSevenBits << (byteIndex * 7);\n      if ((currentByte & 0b10000000) === 0) {\n        // This byte does not have its continuation bit set. We're done.\n        break;\n      }\n    }\n    return [value, offset + byteCount];\n  },\n});\n"],"names":["shortU16","options","description","fixedSize","maxSize","serialize","value","assertRange","bytes","ii","alignedValue","nextSevenBits","Uint8Array","deserialize","offset","byteCount","byteIndex","currentByte"],"mappings":";;;;;;AAAA;;AAOA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,QAAQ,GAAG,CACtBC,OAAkC,GAAG,EAAE,MACf;AACxBC,EAAAA,WAAW,EAAED,OAAO,CAACC,WAAW,IAAI,UAAU;AAC9CC,EAAAA,SAAS,EAAE,IAAI;AACfC,EAAAA,OAAO,EAAE,CAAC;EACVC,SAAS,EAAGC,KAAa,IAAiB;IACxCC,iBAAW,CAAC,UAAU,EAAE,CAAC,EAAE,KAAK,EAAED,KAAK,CAAC,CAAA;AACxC,IAAA,MAAME,KAAK,GAAG,CAAC,CAAC,CAAC,CAAA;IACjB,KAAK,IAAIC,EAAE,GAAG,CAAC,GAAIA,EAAE,IAAI,CAAC,EAAE;AAC1B;AACA,MAAA,MAAMC,YAAY,GAAGJ,KAAK,IAAKG,EAAE,GAAG,CAAE,CAAA;MACtC,IAAIC,YAAY,KAAK,CAAC,EAAE;AACtB;AACA,QAAA,MAAA;AACF,OAAA;AACA;AACA,MAAA,MAAMC,aAAa,GAAG,SAAS,GAAGD,YAAY,CAAA;AAC9CF,MAAAA,KAAK,CAACC,EAAE,CAAC,GAAGE,aAAa,CAAA;MACzB,IAAIF,EAAE,GAAG,CAAC,EAAE;AACV;AACAD,QAAAA,KAAK,CAACC,EAAE,GAAG,CAAC,CAAC,IAAI,UAAU,CAAA;AAC7B,OAAA;AACF,KAAA;AACA,IAAA,OAAO,IAAIG,UAAU,CAACJ,KAAK,CAAC,CAAA;GAC7B;AACDK,EAAAA,WAAW,EAAE,CAACL,KAAiB,EAAEM,MAAM,GAAG,CAAC,KAAuB;IAChE,IAAIR,KAAK,GAAG,CAAC,CAAA;IACb,IAAIS,SAAS,GAAG,CAAC,CAAA;IACjB,OACE,EAAEA,SAAS;MACX;AACA,MAAA,MAAMC,SAAS,GAAGD,SAAS,GAAG,CAAC,CAAA;AAC/B,MAAA,MAAME,WAAW,GAAGT,KAAK,CAACM,MAAM,GAAGE,SAAS,CAAC,CAAA;AAC7C,MAAA,MAAML,aAAa,GAAG,SAAS,GAAGM,WAAW,CAAA;AAC7C;AACAX,MAAAA,KAAK,IAAIK,aAAa,IAAKK,SAAS,GAAG,CAAE,CAAA;AACzC,MAAA,IAAI,CAACC,WAAW,GAAG,UAAU,MAAM,CAAC,EAAE;AACpC;AACA,QAAA,MAAA;AACF,OAAA;AACF,KAAA;AACA,IAAA,OAAO,CAACX,KAAK,EAAEQ,MAAM,GAAGC,SAAS,CAAC,CAAA;AACpC,GAAA;AACF,CAAC;;;;"}