import { defineProperty as _defineProperty } from '../../_virtual/_rollupPluginBabelHelpers.mjs';
import { OperationHandlerMissingError } from '../../errors/SdkError.mjs';
import { Disposable } from '../../utils/Disposable.mjs';

/**
 * @group Modules
 */
class OperationClient {
  /**
   * Maps the name of an operation with its operation handler.
   * Whilst the types on the Map are relatively loose, we ensure
   * operations match with their handlers when registering them.
   */

  constructor(metaplex) {
    _defineProperty(this, "operationHandlers", new Map());
    this.metaplex = metaplex;
  }
  register(operationConstructor, operationHandler) {
    this.operationHandlers.set(operationConstructor.key, operationHandler);
    return this;
  }
  get(operation) {
    const operationHandler = this.operationHandlers.get(operation.key);
    if (!operationHandler) {
      throw new OperationHandlerMissingError(operation.key);
    }
    return operationHandler;
  }
  async execute(operation, options = {}) {
    const operationHandler = this.get(operation);
    const signal = options.signal ?? new AbortController().signal;
    return new Disposable(signal).run(scope => operationHandler.handle(operation, this.metaplex, this.getOperationScope(options, scope)));
  }
  getOperationScope(options, scope) {
    if (!!options.commitment && !options.confirmOptions) {
      options.confirmOptions = {
        commitment: options.commitment
      };
    }
    const payer = options.payer ?? this.metaplex.rpc().getDefaultFeePayer();
    return {
      ...options,
      ...scope,
      payer
    };
  }
}

export { OperationClient };
//# sourceMappingURL=OperationClient.mjs.map
