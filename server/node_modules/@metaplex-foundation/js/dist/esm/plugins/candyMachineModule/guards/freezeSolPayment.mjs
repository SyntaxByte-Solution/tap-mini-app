import { Buffer } from 'buffer';
import * as beet from '@metaplex-foundation/beet';
import { freezeSolPaymentBeet, FreezeInstruction } from '@metaplex-foundation/mpl-candy-guard';
import { MintOwnerMustBeMintPayerError, UnrecognizePathForRouteInstructionError } from '../errors.mjs';
import assert from '../../../utils/assert.mjs';
import { mapSerializer, createSerializerFromBeet } from '../../../types/Serializer.mjs';
import { lamports } from '../../../types/Amount.mjs';

/**
 * The freezeSolPayment guard allows minting frozen NFTs by charging
 * the payer an amount in SOL. Frozen NFTs cannot be transferred
 * or listed on any marketplaces until thawed.
 *
 * The funds are transferred to a freeze escrow until all NFTs are thaw,
 * at which point, they can be transferred (unlocked) to the configured
 * destination account.
 *
 * This object defines the settings that should be
 * provided when creating and/or updating a Candy
 * Machine if you wish to enable this guard.
 *
 * @see {@link FreezeSolPaymentGuardRouteSettings} to learn more about
 * the instructions that can be executed against this guard.
 */

/** @internal */
const freezeSolPaymentGuardManifest = {
  name: 'freezeSolPayment',
  settingsBytes: 40,
  settingsSerializer: mapSerializer(createSerializerFromBeet(freezeSolPaymentBeet), settings => ({
    amount: lamports(settings.lamports),
    destination: settings.destination
  }), settings => ({
    lamports: settings.amount.basisPoints,
    destination: settings.destination
  })),
  mintSettingsParser: ({
    metaplex,
    settings,
    owner,
    payer,
    mint,
    candyMachine,
    candyGuard,
    programs
  }) => {
    if (!owner.equals(payer.publicKey)) {
      throw new MintOwnerMustBeMintPayerError('freezeSolPayment');
    }
    const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
      destination: settings.destination,
      candyMachine,
      candyGuard,
      programs
    });
    const nftAta = metaplex.tokens().pdas().associatedTokenAccount({
      mint: mint.publicKey,
      owner: payer.publicKey,
      programs
    });
    return {
      arguments: Buffer.from([]),
      remainingAccounts: [{
        isSigner: false,
        address: freezeEscrow,
        isWritable: true
      }, {
        isSigner: false,
        address: nftAta,
        isWritable: false
      }]
    };
  },
  routeSettingsParser: input => {
    switch (input.routeSettings.path) {
      case 'initialize':
        return initializeRouteInstruction(input);
      case 'thaw':
        return thawRouteInstruction(input);
      case 'unlockFunds':
        return unlockFundsRouteInstruction(input);
      default:
        throw new UnrecognizePathForRouteInstructionError('freezeSolPayment',
        // @ts-ignore
        input.routeSettings.path);
    }
  }
};
function initializeRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert(routeSettings.path === 'initialize');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destination,
    candyMachine,
    candyGuard,
    programs
  });
  const systemProgram = metaplex.programs().getSystem(programs);
  const args = Buffer.alloc(9);
  beet.u8.write(args, 0, FreezeInstruction.Initialize);
  beet.u64.write(args, 1, routeSettings.period);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: true,
      address: routeSettings.candyGuardAuthority,
      isWritable: false
    }, {
      isSigner: false,
      address: systemProgram.address,
      isWritable: false
    }]
  };
}
function thawRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert(routeSettings.path === 'thaw');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destination,
    candyMachine,
    candyGuard,
    programs
  });
  const nftAta = metaplex.tokens().pdas().associatedTokenAccount({
    mint: routeSettings.nftMint,
    owner: routeSettings.nftOwner,
    programs
  });
  const nftEdition = metaplex.nfts().pdas().masterEdition({
    mint: routeSettings.nftMint,
    programs
  });
  const tokenProgram = metaplex.programs().getToken(programs);
  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);
  const args = Buffer.alloc(1);
  beet.u8.write(args, 0, FreezeInstruction.Thaw);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: false,
      address: routeSettings.nftMint,
      isWritable: false
    }, {
      isSigner: false,
      address: routeSettings.nftOwner,
      isWritable: false
    }, {
      isSigner: false,
      address: nftAta,
      isWritable: true
    }, {
      isSigner: false,
      address: nftEdition,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenProgram.address,
      isWritable: false
    }, {
      isSigner: false,
      address: tokenMetadataProgram.address,
      isWritable: false
    }]
  };
}
function unlockFundsRouteInstruction({
  metaplex,
  settings,
  routeSettings,
  candyMachine,
  candyGuard,
  programs
}) {
  assert(routeSettings.path === 'unlockFunds');
  const freezeEscrow = metaplex.candyMachines().pdas().freezeEscrow({
    destination: settings.destination,
    candyMachine,
    candyGuard,
    programs
  });
  const systemProgram = metaplex.programs().getSystem(programs);
  const args = Buffer.alloc(1);
  beet.u8.write(args, 0, FreezeInstruction.UnlockFunds);
  return {
    arguments: args,
    remainingAccounts: [{
      isSigner: false,
      address: freezeEscrow,
      isWritable: true
    }, {
      isSigner: true,
      address: routeSettings.candyGuardAuthority,
      isWritable: false
    }, {
      isSigner: false,
      address: settings.destination,
      isWritable: true
    }, {
      isSigner: false,
      address: systemProgram.address,
      isWritable: false
    }]
  };
}

export { freezeSolPaymentGuardManifest };
//# sourceMappingURL=freezeSolPayment.mjs.map
