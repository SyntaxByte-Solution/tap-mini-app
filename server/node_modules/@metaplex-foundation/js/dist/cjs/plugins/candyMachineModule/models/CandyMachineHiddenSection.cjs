'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var beet = require('@metaplex-foundation/beet');
var FeatureFlags = require('../../../types/FeatureFlags.cjs');
var common = require('../../../utils/common.cjs');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var beet__namespace = /*#__PURE__*/_interopNamespace(beet);

/** @internal */

/** @internal */
const deserializeCandyMachineHiddenSection = (buffer, itemsAvailable, itemsRemaining, configLineSettings, offset = 0) => {
  // Items loaded.
  const itemsLoaded = beet__namespace.u32.read(buffer, offset);
  offset += 4;

  // Raw config lines.
  const {
    nameLength
  } = configLineSettings;
  const {
    uriLength
  } = configLineSettings;
  const configLineSize = nameLength + uriLength;
  const configLinesSize = configLineSize * itemsAvailable;
  const rawConfigLines = buffer.slice(offset, offset + configLinesSize);
  offset += configLinesSize;

  // Items loaded map.
  const itemsLoadedBuffer = buffer.slice(offset, offset + itemsAvailable);
  const itemsLoadedMap = FeatureFlags.deserializeFeatureFlags(itemsLoadedBuffer, itemsAvailable);
  const itemsLoadedMapSize = Math.floor(itemsAvailable / 8) + 1;
  offset += itemsLoadedMapSize;

  // Items left to mint for random order only.
  const itemsLeftToMint = beet__namespace.uniformFixedSizeArray(beet__namespace.u32, itemsAvailable).read(buffer, offset).slice(0, itemsRemaining);

  // Helper function to figure out if an item has been minted.
  const itemsMinted = itemsAvailable - itemsRemaining;
  const isMinted = index => configLineSettings.isSequential ? index < itemsMinted : !itemsLeftToMint.includes(index);

  // Parse config lines.
  const items = [];
  itemsLoadedMap.forEach((loaded, index) => {
    if (!loaded) return;
    const namePosition = index * configLineSize;
    const uriPosition = namePosition + nameLength;
    const name = rawConfigLines.slice(namePosition, namePosition + nameLength).toString('utf8');
    const uri = rawConfigLines.slice(uriPosition, uriPosition + uriLength).toString('utf8');
    const prefixName = replaceCandyMachineItemPattern(configLineSettings.prefixName, index);
    const prefixUri = replaceCandyMachineItemPattern(configLineSettings.prefixUri, index);
    items.push({
      index,
      minted: isMinted(index),
      name: prefixName + common.removeEmptyChars(name),
      uri: prefixUri + common.removeEmptyChars(uri)
    });
  });
  return {
    itemsLoaded,
    items,
    itemsLoadedMap,
    itemsLeftToMint
  };
};

/** @internal */
const replaceCandyMachineItemPattern = (value, index) => {
  return value.replace('$ID+1$', `${index + 1}`).replace('$ID$', `${index}`);
};

exports.deserializeCandyMachineHiddenSection = deserializeCandyMachineHiddenSection;
exports.replaceCandyMachineItemPattern = replaceCandyMachineItemPattern;
//# sourceMappingURL=CandyMachineHiddenSection.cjs.map
