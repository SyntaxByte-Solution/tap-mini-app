'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mplAuctionHouse = require('@metaplex-foundation/mpl-auction-house');
var constants$1 = require('../constants.cjs');
var constants = require('../../tokenModule/constants.cjs');
var Operation = require('../../../types/Operation.cjs');
var Signer = require('../../../types/Signer.cjs');
var SdkError = require('../../../errors/SdkError.cjs');
var PublicKey = require('../../../types/PublicKey.cjs');
var TransactionBuilder = require('../../../utils/TransactionBuilder.cjs');

// -----------------
// Operation
// -----------------

const Key = 'CreateAuctionHouseOperation';

/**
 * Creates an Auction House.
 *
 * ```ts
 * await metaplex
 *   .auctionHouse()
 *   .create({ sellerFeeBasisPoints: 500 }); // 5% fee
 * ```
 *
 * Provide `auctioneerAuthority` in case you want to enable Auctioneer.
 *
 * ```ts
 * await metaplex
 *   .auctionHouse()
 *   .create({ sellerFeeBasisPoints: 500, auctioneerAuthority: mx.identity().publicKey };
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const createAuctionHouseOperation = Operation.useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const createAuctionHouseOperationHandler = {
  async handle(operation, metaplex, scope) {
    const builder = createAuctionHouseBuilder(metaplex, operation.input, scope);
    const confirmOptions = Operation.makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);
    const output = await builder.sendAndConfirm(metaplex, confirmOptions);
    scope.throwIfCanceled();
    const auctionHouse = await metaplex.auctionHouse().findByAddress({
      address: output.auctionHouseAddress,
      auctioneerAuthority: operation.input.auctioneerAuthority
    }, scope);
    return {
      ...output,
      auctionHouse
    };
  }
};

// -----------------
// Builder
// -----------------

/**
 * @group Transaction Builders
 * @category Inputs
 */

/**
 * Creates an Auction House.
 *
 * ```ts
 * const transactionBuilder = metaplex
 *   .auctionHouse()
 *   .builders()
 *   .createAuctionHouse({ sellerFeeBasisPoints: 500 }) // 5% fee
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */
const createAuctionHouseBuilder = (metaplex, params, options = {}) => {
  // Data.
  const {
    programs,
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const canChangeSalePrice = params.canChangeSalePrice ?? false;
  const requiresSignOff = params.requiresSignOff ?? canChangeSalePrice;

  // Accounts.
  const authority = params.authority ?? metaplex.identity();
  const treasuryMint = params.treasuryMint ?? constants.WRAPPED_SOL_MINT;
  const treasuryWithdrawalDestinationOwner = params.treasuryWithdrawalDestinationOwner ?? metaplex.identity().publicKey;
  const feeWithdrawalDestination = params.feeWithdrawalDestination ?? metaplex.identity().publicKey;

  // Auctioneer delegate instruction needs to be signed by authority
  if (params.auctioneerAuthority && !Signer.isSigner(authority)) {
    throw new SdkError.ExpectedSignerError('authority', 'PublicKey', 'You are trying to delegate to an Auctioneer authority which ' + 'requires the Auction House authority to sign a transaction. ' + 'But you provided the Auction House authority as a Public Key.');
  }

  // PDAs.
  const auctionHouse = metaplex.auctionHouse().pdas().auctionHouse({
    creator: PublicKey.toPublicKey(authority),
    treasuryMint,
    programs
  });
  const auctionHouseFeeAccount = metaplex.auctionHouse().pdas().fee({
    auctionHouse,
    programs
  });
  const auctionHouseTreasury = metaplex.auctionHouse().pdas().treasury({
    auctionHouse,
    programs
  });
  const treasuryWithdrawalDestination = treasuryMint.equals(constants.WRAPPED_SOL_MINT) ? treasuryWithdrawalDestinationOwner : metaplex.tokens().pdas().associatedTokenAccount({
    mint: treasuryMint,
    owner: treasuryWithdrawalDestinationOwner,
    programs
  });
  return TransactionBuilder.TransactionBuilder.make().setFeePayer(payer).setContext({
    auctionHouseAddress: auctionHouse,
    auctionHouseFeeAccountAddress: auctionHouseFeeAccount,
    auctionHouseTreasuryAddress: auctionHouseTreasury,
    treasuryWithdrawalDestinationAddress: treasuryWithdrawalDestination
  })

  // Create and initialize the Auction House account.
  .add({
    instruction: mplAuctionHouse.createCreateAuctionHouseInstruction({
      treasuryMint,
      payer: payer.publicKey,
      authority: PublicKey.toPublicKey(authority),
      feeWithdrawalDestination,
      treasuryWithdrawalDestination,
      treasuryWithdrawalDestinationOwner,
      auctionHouse,
      auctionHouseFeeAccount,
      auctionHouseTreasury
    }, {
      bump: auctionHouse.bump,
      feePayerBump: auctionHouseFeeAccount.bump,
      treasuryBump: auctionHouseTreasury.bump,
      sellerFeeBasisPoints: params.sellerFeeBasisPoints,
      requiresSignOff,
      canChangeSalePrice
    }),
    signers: [payer],
    key: params.instructionKey ?? 'createAuctionHouse'
  })

  // Delegate to the Auctioneer authority when provided.
  .when(Boolean(params.auctioneerAuthority), builder => {
    const auctioneerAuthority = params.auctioneerAuthority;
    return builder.add({
      instruction: mplAuctionHouse.createDelegateAuctioneerInstruction({
        auctionHouse,
        authority: PublicKey.toPublicKey(authority),
        auctioneerAuthority,
        ahAuctioneerPda: metaplex.auctionHouse().pdas().auctioneer({
          auctionHouse,
          auctioneerAuthority,
          programs
        })
      }, {
        scopes: params.auctioneerScopes ?? constants$1.AUCTIONEER_ALL_SCOPES
      }),
      signers: [authority],
      key: params.delegateAuctioneerInstructionKey ?? 'delegateAuctioneer'
    });
  });
};

exports.createAuctionHouseBuilder = createAuctionHouseBuilder;
exports.createAuctionHouseOperation = createAuctionHouseOperation;
exports.createAuctionHouseOperationHandler = createAuctionHouseOperationHandler;
//# sourceMappingURL=createAuctionHouse.cjs.map
