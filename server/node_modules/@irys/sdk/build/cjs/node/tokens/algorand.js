"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const arbundles_1 = require("arbundles");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const token_1 = require("../token");
const axios_1 = __importDefault(require("axios"));
const algosdk_1 = require("algosdk");
class AlgorandConfig extends token_1.BaseNodeToken {
    constructor(config) {
        super(config);
        this.base = ["microAlgos", 1e6];
        this.keyPair = (0, algosdk_1.mnemonicToSecretKey)(this.wallet);
        this.apiURL = config.providerUrl;
        if (!config.opts.indexerUrl)
            throw new Error(`Algorand: required client constructor option 'opts.indexerUrl' is undefined`);
        this.indexerURL = config.opts.indexerUrl;
    }
    getTx(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `${this.indexerURL}/v2/transactions/${txId}`;
            const response = yield axios_1.default.get(endpoint);
            const latestBlockHeight = new bignumber_js_1.default(yield this.getCurrentHeight()).toNumber();
            const txBlockHeight = new bignumber_js_1.default(response.data.transaction["confirmed-round"]);
            const tx = {
                from: response.data.transaction.sender,
                to: response.data.transaction["payment-transaction"].receiver,
                amount: new bignumber_js_1.default(response.data.transaction["payment-transaction"].amount),
                blockHeight: txBlockHeight,
                pending: false,
                confirmed: latestBlockHeight - txBlockHeight.toNumber() >= this.minConfirm,
            };
            return tx;
        });
    }
    ownerToAddress(owner) {
        return (0, algosdk_1.encodeAddress)(owner);
    }
    sign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getSigner().sign(data);
        });
    }
    getSigner() {
        return new arbundles_1.AlgorandSigner(this.keyPair.sk, this.getPublicKey());
    }
    verify(pub, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return arbundles_1.AlgorandSigner.verify(pub, data, signature);
        });
    }
    getCurrentHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            //  "last-round" = blockheight
            const endpoint = `${this.apiURL}/v2/transactions/params`;
            const response = yield axios_1.default.get(endpoint);
            return new bignumber_js_1.default(yield response.data["last-round"]);
        });
    }
    getFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `${this.apiURL}/v2/transactions/params`;
            const response = yield axios_1.default.get(endpoint);
            return new bignumber_js_1.default(response.data["min-fee"]);
        });
    }
    sendTx(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `${this.apiURL}/v2/transactions`;
            const response = yield axios_1.default.post(endpoint, data);
            return response.data.txId;
        });
    }
    createTx(amount, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `${this.apiURL}/v2/transactions/params`;
            const response = yield axios_1.default.get(endpoint);
            const params = yield response.data;
            const unsigned = (0, algosdk_1.makePaymentTxnWithSuggestedParamsFromObject)({
                from: this.keyPair.addr,
                to: to,
                amount: new bignumber_js_1.default(amount).toNumber(),
                note: undefined,
                suggestedParams: {
                    fee: params.fee,
                    firstRound: params["last-round"],
                    flatFee: false,
                    genesisHash: params["genesis-hash"],
                    genesisID: params["genesis-id"],
                    lastRound: params["last-round"] + 1000,
                },
            });
            const signed = (0, algosdk_1.signTransaction)(unsigned, this.keyPair.sk);
            return { tx: signed.blob, txId: signed.txID };
        });
    }
    getPublicKey() {
        this.keyPair = (0, algosdk_1.mnemonicToSecretKey)(this.wallet);
        const pub = (0, algosdk_1.decodeAddress)(this.keyPair.addr).publicKey;
        return Buffer.from(pub);
    }
}
exports.default = AlgorandConfig;
//# sourceMappingURL=algorand.js.map