import { AuthorityType } from '@metaplex-foundation/mpl-token-metadata';
import { parseTokenMetadataDelegateInput } from './DelegateInput.mjs';
import { UnreachableCaseError } from '../../errors/SdkError.mjs';

/**
 * Defines an authority that can handle a digital asset (NFT, SFT, etc.).
 *
 * An authority can be one of the following:
 * - Metadata: the update authority of the metadata account.
 * - Holder: the owner of the token account, i.e. the owner of the asset.
 * - Metadata Delegate: an approved delegate authority of the metadata account for a given action.
 * - Token Delegate: an approved delegate authority of the token account for a given action.
 */

const parseTokenMetadataAuthorization = (metaplex, input) => {
  const auth = {
    accounts: {
      authorizationRules: input.authorizationDetails?.rules ?? null
    },
    signers: [],
    data: {
      authorizationData: input.authorizationDetails?.data ?? null
    }
  };
  if (input.authority.__kind === 'metadata') {
    auth.accounts.authority = input.authority.updateAuthority.publicKey;
    auth.accounts.token = input.authority.token;
    auth.signers.push(input.authority.updateAuthority);
    auth.data.authorityType = AuthorityType.Metadata;
  } else if (input.authority.__kind === 'metadataDelegate') {
    const {
      delegateRecord,
      approver
    } = parseTokenMetadataDelegateInput(metaplex, input.mint, input.authority, input.programs);
    auth.accounts.authority = input.authority.delegate.publicKey;
    auth.accounts.delegateRecord = delegateRecord;
    auth.accounts.approver = approver;
    auth.signers.push(input.authority.delegate);
    auth.data.authorityType = AuthorityType.MetadataDelegate;
  } else if (input.authority.__kind === 'tokenDelegate') {
    const {
      delegateRecord,
      approver,
      tokenAccount
    } = parseTokenMetadataDelegateInput(metaplex, input.mint, input.authority, input.programs);
    auth.accounts.authority = input.authority.delegate.publicKey;
    auth.accounts.token = tokenAccount;
    auth.accounts.delegateRecord = delegateRecord;
    auth.accounts.approver = approver;
    auth.signers.push(input.authority.delegate);
    auth.data.authorityType = AuthorityType.TokenDelegate;
  } else if (input.authority.__kind === 'holder') {
    auth.accounts.authority = input.authority.owner.publicKey;
    auth.accounts.token = input.authority.token;
    auth.signers.push(input.authority.owner);
    auth.data.authorityType = AuthorityType.Holder;
  } else {
    throw new UnreachableCaseError(input.authority.__kind);
  }
  return auth;
};
const getSignerFromTokenMetadataAuthority = authority => {
  if (!('__kind' in authority)) {
    return authority;
  }
  switch (authority.__kind) {
    case 'metadata':
      return authority.updateAuthority;
    case 'metadataDelegate':
    case 'tokenDelegate':
      return authority.delegate;
    case 'holder':
      return authority.owner;
    default:
      throw new UnreachableCaseError(authority.__kind);
  }
};

export { getSignerFromTokenMetadataAuthority, parseTokenMetadataAuthorization };
//# sourceMappingURL=Authorization.mjs.map
