#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportForTesting = exports.program = void 0;
// Note: DO NOT REMOVE/ALTER THE ABOVE LINE - it is called a 'shebang' and is vital for CLI execution.
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const commander_1 = require("commander");
const fs_1 = require("fs");
const inquirer_1 = __importDefault(require("inquirer"));
const irys_1 = __importDefault(require("./irys"));
const upload_1 = require("./upload");
exports.program = new commander_1.Command();
let balpad, walpad; // padding state variables
// Define the CLI flags for the program
exports.program
    .option("-h, --host <string>", "Irys node hostname/URL (eg http://node1.irys.network)")
    .option("-w, --wallet <string>", "Path to keyfile or the private key itself", "default")
    .option("-t, --token <string>", "The token to use")
    .option("-c --currency <string>", "DEPRECATED: the currency to use (same as token)")
    .option("--timeout <number>", "The timeout (in ms) for API HTTP requests - increase if you get timeouts for upload")
    .option("--no-confirmation", "Disable confirmations for certain actions")
    .option("--tags [value...]", "Tags to include, format <name> <value>")
    .option("--multiplier <number>", "Adjust the multiplier used for tx rewards - the higher the faster the network will process the transaction.", "1.00")
    .option("--batch-size <number>", "Adjust the upload-dir batch size (process more items at once - uses more resources (network, memory, cpu) accordingly!)", "5")
    .option("--debug, -d", "Increases verbosity of errors and logs additional debug information. Used for troubleshooting.", false)
    .option("--index-file <string>", "Name of the file to use as an index for upload-dir manifests (relative to the path provided to upload-dir).")
    .option("--provider-url <string>", "Override the provider URL")
    .option("--contract-address <string>", "Override the contract address")
    .option("--content-type <string>", "Override the content type for *ALL* files uploaded")
    .option("--remove-deleted", "Removes previously uploaded (but now deleted) items from the manifest")
    .option("--force-chunking", "Forces usage of chunking for all files regardless of size")
    .option("--provenance", "Upload a file/folder with strong provenance");
// Define commands
// uses NPM view to query the package's version.
exports.program.version(irys_1.default.VERSION, "-v, --version", "Gets the current package version of the Irys client");
// Balance command - gets the provided address' balance on the specified bundler
exports.program
    .command("balance")
    .description("Gets the specified user's balance for the current Irys node")
    .argument("<address>", "address")
    .action((address) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        options.address = balpad ? address.substring(1) : address;
        const Irys = yield init(options, "balance");
        const balance = yield Irys.utils.getBalance(options.address);
        console.log(`Balance: ${balance} ${Irys.tokenConfig.base[0]} (${Irys.utils.unitConverter(balance).toFixed()} ${Irys.token})`);
    }
    catch (err) {
        console.error(`Error whilst getting balance: ${options.debug ? err.stack : err.message} `);
        return;
    }
}));
// Withdraw command - sends a withdrawal request for n base units to the specified bundler for the loaded wallet
exports.program
    .command("withdraw")
    .description("Sends a fund withdrawal request")
    .argument("<amount>", "amount to withdraw in token base units")
    .action((amount) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const Irys = yield init(options, "withdraw");
        const confirmed = yield confirmation(`Confirmation: withdraw ${amount} ${Irys.tokenConfig.base[0]} from ${Irys.api.config.url.host} (${yield Irys.utils.getBundlerAddress(Irys.token)})?\n Y / N`);
        if (confirmed) {
            const res = yield Irys.withdrawBalance(new bignumber_js_1.default(amount));
            console.log(`Withdrawal request for ${res === null || res === void 0 ? void 0 : res.requested} ${Irys.tokenConfig.base[0]} successful\nTransaction ID: ${res === null || res === void 0 ? void 0 : res.tx_id} with network fee ${res === null || res === void 0 ? void 0 : res.fee} for a total cost of ${res === null || res === void 0 ? void 0 : res.final} `);
        }
        else {
            console.log("confirmation failed");
        }
    }
    catch (err) {
        console.error(`Error whilst sending withdrawal request: ${options.debug ? err.stack : err.message} `);
        return;
    }
}));
// Upload command - Uploads a specified file to the specified bundler using the loaded wallet.
exports.program
    .command("upload")
    .description("Uploads a specified file")
    .argument("<file>", "relative path to the file you want to upload")
    .action((file) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const Irys = yield init(options, "upload");
        const tags = parseTags(options === null || options === void 0 ? void 0 : options.tags);
        const res = yield Irys.uploadFile(file, { tags: tags !== null && tags !== void 0 ? tags : [], upload: { getReceiptSignature: options === null || options === void 0 ? void 0 : options.provenance } });
        console.log(`Uploaded to https://arweave.net/${res === null || res === void 0 ? void 0 : res.id}`);
    }
    catch (err) {
        console.error(`Error whilst uploading file: ${options.debug ? err.stack : err.message} `);
        return;
    }
}));
exports.program
    .command("upload-dir")
    .description("Uploads a folder (with a manifest)")
    .argument("<folder>", "relative path to the folder you want to upload")
    .action((folder) => __awaiter(void 0, void 0, void 0, function* () {
    yield uploadDir(folder);
}));
// Deploy command - DEPRECATED
exports.program
    .command("deploy")
    .description("(DEPRECATED - use the functionally identical 'upload-dir' instead.) Deploys a folder (with a manifest) to the specified bundler")
    .argument("<folder>", "relative path to the folder you want to deploy")
    .action((folder) => __awaiter(void 0, void 0, void 0, function* () {
    console.warn("WARN: Deploy is deprecated, use the functionally identical 'upload-dir' instead.");
    yield uploadDir(folder);
}));
function uploadDir(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const bundler = yield init(options, "upload");
            const tags = parseTags(options === null || options === void 0 ? void 0 : options.tags);
            const res = yield bundler.uploadFolder(folder, {
                indexFile: options.indexFile,
                batchSize: +options.batchSize,
                interactivePreflight: options.confirmation,
                keepDeleted: !options.removeDeleted,
                manifestTags: tags !== null && tags !== void 0 ? tags : [],
                logFunction: (log) => __awaiter(this, void 0, void 0, function* () {
                    console.log(log);
                }),
                itemOptions: {
                    upload: { getReceiptSignature: options === null || options === void 0 ? void 0 : options.provenance },
                },
            });
            if (!res)
                return console.log("Nothing to upload");
            console.log(`Uploaded to https://arweave.net/${res.id}`);
        }
        catch (err) {
            console.error(`Error whilst uploading ${folder} - ${options.debug ? err.stack : err.message}`);
        }
    });
}
const parseTags = (arr) => {
    if (!arr)
        return;
    if (arr.length % 2 !== 0)
        throw new Error(`Tags key is missing a value!`);
    return arr.reduce((a, v, i) => {
        (i + 1) % 2 === 0 ? (a.at(-1).value = v) : a.push({ name: v, value: "" });
        return a;
    }, []);
};
exports.program
    .command("fund")
    .description("Funds your account with the specified amount of atomic units")
    .argument("<amount>", "Amount to add in atomic units")
    .action((amount) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        if (isNaN(+amount))
            throw new Error("Amount must be an integer");
        const Irys = yield init(options, "fund");
        const confirmed = yield confirmation(`Confirmation: send ${amount} ${Irys.tokenConfig.base[0]} (${Irys.utils.unitConverter(amount).toFixed()} ${Irys.token}) to ${Irys.api.config.url.host} (${yield Irys.utils.getBundlerAddress(Irys.token)})?\n Y / N`);
        if (confirmed) {
            const tx = yield Irys.fund(new bignumber_js_1.default(amount), options.multiplier);
            console.log(`Funding receipt: \nAmount: ${tx.quantity} with Fee: ${tx.reward} to ${tx.target} \nTransaction ID: ${tx.id} `);
        }
        else {
            console.log("confirmation failed");
        }
    }
    catch (err) {
        console.error(`Error whilst funding: ${options.debug ? err.stack : err.message} `);
        return;
    }
}));
exports.program
    .command("price")
    .description("Check how much of a specific token is required for an upload of <amount> bytes")
    .argument("<bytes>", "The number of bytes to get the price for")
    .action((bytes) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        if (isNaN(+bytes))
            throw new Error("Amount must be an integer");
        const Irys = yield init(options, "price");
        yield Irys.utils.getBundlerAddress(options.token); // will throw if the bundler doesn't support the token
        const cost = yield Irys.utils.getPrice(options.token, +bytes);
        console.log(`Price for ${bytes} bytes in ${options.token} is ${cost.toFixed(0)} ${Irys.tokenConfig.base[0]} (${Irys.utils
            .unitConverter(cost)
            .toFixed()} ${Irys.token})`);
    }
    catch (err) {
        console.error(`Error whilst getting price: ${options.debug ? err.stack : err.message} `);
        return;
    }
}));
/**
 * Interactive CLI prompt allowing a user to confirm an action
 * @param message the message specifying the action they are asked to confirm
 */
function confirmation(message) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(options === null || options === void 0 ? void 0 : options.confirmation)) {
            return true;
        }
        const answers = yield inquirer_1.default.prompt([{ type: "input", name: "confirmation", message }]);
        return answers.confirmation.toLowerCase() == "y";
    });
}
/**
 * Initialisation routine for the CLI, mainly for initialising a Irys instance
 * @param opts the parsed options from the cli
 * @returns a new Irys instance
 */
function init(opts, operation) {
    return __awaiter(this, void 0, void 0, function* () {
        let wallet;
        let bundler;
        // every option needs a host and token so ensure they're present
        if (!opts.host) {
            throw new Error("Host parameter (-h) is required!");
        }
        if (!opts.token) {
            throw new Error("token flag (-t, --token) is required!");
        }
        // some operations do not require a wallet
        if (!["balance", "price"].includes(operation)) {
            // require a wallet
            if (opts.wallet === "default") {
                // default to wallet.json under the right conditions
                if (opts.token === "arweave" && (yield (0, upload_1.checkPath)("./wallet.json"))) {
                    wallet = yield loadWallet("./wallet.json");
                }
                else {
                    throw new Error("Wallet (-w) required for this operation!");
                }
            }
            else {
                // remove padding if present
                wallet = yield loadWallet(walpad ? opts.wallet.substring(1) : opts.wallet);
            }
        }
        try {
            // create and ready the Irys instance
            bundler = new irys_1.default({
                url: opts.host,
                token: opts.token.toLowerCase(),
                key: wallet !== null && wallet !== void 0 ? wallet : "",
                config: {
                    providerUrl: opts.providerUrl,
                    contractAddress: opts.contractAddress,
                },
            });
            yield bundler.ready();
        }
        catch (err) {
            throw new Error(`Error initialising Irys client - ${options.debug ? err.stack : err.message}`);
        }
        // log the loaded address
        if (wallet && bundler.address) {
            console.log(`Loaded address: ${bundler.address}`);
        }
        if (opts.contentType) {
            bundler.uploader.contentType = opts.contentType;
        }
        if (opts.forceChunking) {
            bundler.uploader.useChunking = true;
        }
        return bundler;
    });
}
/**
 * Loads a wallet file from the specified path into a JWK interface
 * @param path path to the JWK file
 * @returns JWK interface
 */
function loadWallet(path) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield (0, upload_1.checkPath)(path)) {
            if (options.debug) {
                console.log("Loading wallet file");
            }
            return JSON.parse((0, fs_1.readFileSync)(path).toString());
        }
        else {
            if (options.debug) {
                console.log("Assuming raw key instead of keyfile path");
            }
            return path;
        }
    });
}
const options = exports.program.opts();
if (options.currency)
    options.token = options.currency;
const isScript = require.main === module;
if (isScript) {
    // to debug CLI: log process argv, load into var, and run in debugger.
    // console.log(JSON.stringify(process.argv));
    // process.exit(1);
    // replace this with dumped array. (make sure to append/include --no-confirmation)
    const argv = process.argv;
    // padding hack
    // this is because B64URL strings can start with a "-" which makes commander think it's a flag
    // so we pad it with a char that is not part of the B64 char set to prevent wrongful detection
    // and then remove it later.
    const bal = argv.indexOf("balance") + 1;
    if (bal != 0 && argv[bal] && /-{1}[a-z0-9_-]{42}/i.test(argv[bal])) {
        balpad = true;
        argv[bal] = "[" + argv[bal];
    }
    // padding hack to wallet addresses as well
    const wal = (!argv.includes("-w") ? argv.indexOf("--wallet") : argv.indexOf("-w")) + 1;
    if (wal != 0 && argv[wal] && /-{1}.*/i.test(argv[wal])) {
        walpad = true;
        argv[wal] = "[" + argv[wal];
    }
    // pass the CLI our argv
    exports.program.parse(argv);
}
exports.exportForTesting = {
    path: __filename,
};
//# sourceMappingURL=cli.js.map