import { AlgorandSigner } from "arbundles";
import BigNumber from "bignumber.js";
import { BaseNodeToken } from "../token.js";
import axios from "axios";
import { decodeAddress, encodeAddress, makePaymentTxnWithSuggestedParamsFromObject, signTransaction, mnemonicToSecretKey } from "algosdk";
export default class AlgorandConfig extends BaseNodeToken {
    keyPair;
    apiURL;
    indexerURL;
    constructor(config) {
        super(config);
        this.base = ["microAlgos", 1e6];
        this.keyPair = mnemonicToSecretKey(this.wallet);
        this.apiURL = config.providerUrl;
        if (!config.opts.indexerUrl)
            throw new Error(`Algorand: required client constructor option 'opts.indexerUrl' is undefined`);
        this.indexerURL = config.opts.indexerUrl;
    }
    async getTx(txId) {
        const endpoint = `${this.indexerURL}/v2/transactions/${txId}`;
        const response = await axios.get(endpoint);
        const latestBlockHeight = new BigNumber(await this.getCurrentHeight()).toNumber();
        const txBlockHeight = new BigNumber(response.data.transaction["confirmed-round"]);
        const tx = {
            from: response.data.transaction.sender,
            to: response.data.transaction["payment-transaction"].receiver,
            amount: new BigNumber(response.data.transaction["payment-transaction"].amount),
            blockHeight: txBlockHeight,
            pending: false,
            confirmed: latestBlockHeight - txBlockHeight.toNumber() >= this.minConfirm,
        };
        return tx;
    }
    ownerToAddress(owner) {
        return encodeAddress(owner);
    }
    async sign(data) {
        return this.getSigner().sign(data);
    }
    getSigner() {
        return new AlgorandSigner(this.keyPair.sk, this.getPublicKey());
    }
    async verify(pub, data, signature) {
        return AlgorandSigner.verify(pub, data, signature);
    }
    async getCurrentHeight() {
        //  "last-round" = blockheight
        const endpoint = `${this.apiURL}/v2/transactions/params`;
        const response = await axios.get(endpoint);
        return new BigNumber(await response.data["last-round"]);
    }
    async getFee() {
        const endpoint = `${this.apiURL}/v2/transactions/params`;
        const response = await axios.get(endpoint);
        return new BigNumber(response.data["min-fee"]);
    }
    async sendTx(data) {
        const endpoint = `${this.apiURL}/v2/transactions`;
        const response = await axios.post(endpoint, data);
        return response.data.txId;
    }
    async createTx(amount, to) {
        const endpoint = `${this.apiURL}/v2/transactions/params`;
        const response = await axios.get(endpoint);
        const params = await response.data;
        const unsigned = makePaymentTxnWithSuggestedParamsFromObject({
            from: this.keyPair.addr,
            to: to,
            amount: new BigNumber(amount).toNumber(),
            note: undefined,
            suggestedParams: {
                fee: params.fee,
                firstRound: params["last-round"],
                flatFee: false,
                genesisHash: params["genesis-hash"],
                genesisID: params["genesis-id"],
                lastRound: params["last-round"] + 1000,
            },
        });
        const signed = signTransaction(unsigned, this.keyPair.sk);
        return { tx: signed.blob, txId: signed.txID };
    }
    getPublicKey() {
        this.keyPair = mnemonicToSecretKey(this.wallet);
        const pub = decodeAddress(this.keyPair.addr).publicKey;
        return Buffer.from(pub);
    }
}
//# sourceMappingURL=algorand.js.map