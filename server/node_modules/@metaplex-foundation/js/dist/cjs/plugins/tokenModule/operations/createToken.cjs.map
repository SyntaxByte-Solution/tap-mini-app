{"version":3,"file":"createToken.cjs","sources":["../../../../../src/plugins/tokenModule/operations/createToken.ts"],"sourcesContent":["import {\n  ACCOUNT_SIZE,\n  createAssociatedTokenAccountInstruction,\n  createInitializeAccountInstruction,\n} from '@solana/spl-token';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Token } from '../models/Token';\nimport { ExpectedSignerError } from '@/errors';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateTokenOperation' as const;\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const { token } = await metaplex.tokens().createToken({ mint });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createTokenOperation = useOperation<CreateTokenOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateTokenOperation = Operation<\n  typeof Key,\n  CreateTokenInput,\n  CreateTokenOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateTokenInput = {\n  /**\n   * The address of the mint account associated\n   * with the new token account.\n   */\n  mint: PublicKey;\n\n  /**\n   * The address of the owner of the new token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  owner?: PublicKey;\n\n  /**\n   * The token account as a Signer if we want to create\n   * a new token account with a specific address instead of\n   * creating a new associated token account.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mint` and `owner` parameters.\n   */\n  token?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateTokenOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created token account. */\n  token: Token;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createTokenOperationHandler: OperationHandler<CreateTokenOperation> =\n  {\n    async handle(\n      operation: CreateTokenOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateTokenOutput> {\n      const builder = await createTokenBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const token = await metaplex\n        .tokens()\n        .findTokenByAddress({ address: output.tokenAddress }, scope);\n\n      return { ...output, token };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenBuilderParams = Omit<\n  CreateTokenInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the account. */\n  createAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateTokenBuilderContext = {\n  /** The computed address of the token account to create. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * Creates a new token account.\n *\n * ```ts\n * const transactionBuilder = await metaplex.tokens().builders().createToken({ mint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createTokenBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mint, owner = metaplex.identity().publicKey, token } = params;\n\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const associatedTokenProgram = metaplex\n    .programs()\n    .getAssociatedToken(programs);\n\n  const isAssociatedToken = token === undefined;\n  const builder =\n    TransactionBuilder.make<CreateTokenBuilderContext>().setFeePayer(payer);\n\n  if (isAssociatedToken) {\n    const associatedTokenAddress = metaplex\n      .tokens()\n      .pdas()\n      .associatedTokenAccount({ mint, owner, programs });\n\n    return (\n      builder\n        .setContext({ tokenAddress: associatedTokenAddress })\n\n        // Create an associated token account.\n        .add({\n          instruction: createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedTokenAddress,\n            owner,\n            mint,\n            tokenProgram.address,\n            associatedTokenProgram.address\n          ),\n          signers: [payer],\n          key:\n            params.createAssociatedTokenAccountInstructionKey ??\n            'createAssociatedTokenAccount',\n        })\n    );\n  }\n\n  return (\n    builder\n      .setFeePayer(payer)\n      .setContext({ tokenAddress: token.publicKey })\n\n      // Create an empty account for the Token.\n      .add(\n        await metaplex\n          .system()\n          .builders()\n          .createAccount(\n            {\n              newAccount: token,\n              space: ACCOUNT_SIZE,\n              program: tokenProgram.address,\n              instructionKey:\n                params.createAccountInstructionKey ?? 'createAccount',\n            },\n            { payer, programs }\n          )\n      )\n\n      // Initialize the Token.\n      .add({\n        instruction: createInitializeAccountInstruction(\n          token.publicKey,\n          mint,\n          owner,\n          tokenProgram.address\n        ),\n        signers: [token],\n        key: params.initializeTokenInstructionKey ?? 'initializeToken',\n      })\n  );\n};\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateTokenIfMissingBuilderParams = Omit<\n  CreateTokenBuilderParams,\n  'token'\n> & {\n  /**\n   * The token account to create if it does not exist.\n   * Here, it may be passed as a PublicKey if and only\n   * if it already exists.\n   */\n  token?: PublicKey | Signer;\n\n  /**\n   * Whether or not the token account exists.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /**\n   * The name of the token variable on the operation that uses\n   * this helper token builder.\n   *\n   * @defaultValue `\"token\"`\n   */\n  tokenVariable?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Constructors\n * @internal\n */\nexport const createTokenIfMissingBuilder = async (\n  metaplex: Metaplex,\n  params: CreateTokenIfMissingBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateTokenBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mint,\n    owner = metaplex.identity().publicKey,\n    token,\n    tokenExists = true,\n    tokenVariable = 'token',\n  } = params;\n\n  const destination =\n    token ??\n    metaplex.tokens().pdas().associatedTokenAccount({ mint, owner, programs });\n  const destinationAddress = toPublicKey(destination);\n  const builder = TransactionBuilder.make<CreateTokenBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({ tokenAddress: destinationAddress });\n\n  if (tokenExists) {\n    return builder;\n  }\n\n  // When creating a token account, ensure it is passed as a Signer.\n  if (token && !isSigner(token)) {\n    throw new ExpectedSignerError(\n      tokenVariable,\n      'PublicKey',\n      `The provided \"${tokenVariable}\" account ` +\n        `at address [${destinationAddress}] does not exist. ` +\n        `Therefore, it needs to be created and passed as a Signer. ` +\n        `If you want to create the \"${tokenVariable}\" account, then please pass it as a Signer. ` +\n        `Alternatively, you can pass the owner account as a PublicKey instead to ` +\n        `use (or create) an associated token account.`\n    );\n  }\n\n  return builder.add(\n    await metaplex\n      .tokens()\n      .builders()\n      .createToken(\n        {\n          ...params,\n          mint,\n          owner,\n          token,\n        },\n        { programs, payer }\n      )\n  );\n};\n"],"names":["Key","createTokenOperation","useOperation","createTokenOperationHandler","handle","operation","metaplex","scope","builder","createTokenBuilder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","token","tokens","findTokenByAddress","address","tokenAddress","params","options","programs","payer","rpc","getDefaultFeePayer","mint","owner","identity","publicKey","tokenProgram","getToken","associatedTokenProgram","getAssociatedToken","isAssociatedToken","undefined","TransactionBuilder","make","setFeePayer","associatedTokenAddress","pdas","associatedTokenAccount","setContext","add","instruction","createAssociatedTokenAccountInstruction","signers","key","createAssociatedTokenAccountInstructionKey","system","builders","createAccount","newAccount","space","ACCOUNT_SIZE","program","instructionKey","createAccountInstructionKey","createInitializeAccountInstruction","initializeTokenInstructionKey","createTokenIfMissingBuilder","tokenExists","tokenVariable","destination","destinationAddress","toPublicKey","isSigner","ExpectedSignerError","createToken"],"mappings":"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"}