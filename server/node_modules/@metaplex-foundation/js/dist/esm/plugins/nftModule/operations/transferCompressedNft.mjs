import { PublicKey } from '@solana/web3.js';
import { createTransferInstruction } from '@metaplex-foundation/mpl-bubblegum';
import { MerkleTree, SPL_NOOP_PROGRAM_ID, SPL_ACCOUNT_COMPRESSION_PROGRAM_ID, ConcurrentMerkleTreeAccount } from '@solana/spl-account-compression';
import { useOperation } from '../../../types/Operation.mjs';
import { TransactionBuilder } from '../../../utils/TransactionBuilder.mjs';

// -----------------
// Operation
// -----------------

const Key = 'TransferCompressedNftOperation';

/**
 * Transfers a compressed NFT or SFT from one account to another.
 *
 * ```ts
 * await metaplex.nfts().transfer({
 *   nftOrSft,
 *   toOwner,
 * });
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const transferCompressedNftOperation = useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const transferCompressedNftOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    return transferCompressedNftBuilder(metaplex, operation.input, scope).sendAndConfirm(metaplex, scope.confirmOptions);
  }
};

// -----------------
// Builder
// -----------------

/**
 * @group Transaction Builders
 * @category Inputs
 */

/**
 * Transfers a compressed NFT from one account to another.
 *
 * ```ts
 * const transactionBuilder = metaplex
 *   .nfts()
 *   .builders()
 *   .transfer({
 *     nftOrSft,
 *     toOwner,
 *     compression,
 *   });
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */
const transferCompressedNftBuilder = (metaplex, params, options = {}) => {
  const {
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const {
    toOwner,
    compression
  } = params;

  // ensure all required compression data has been supplied
  if (!compression.merkleTree || !compression.assetProof || !compression.data || !compression.ownership) throw Error('Invalid compression data supplied');
  const merkleTree = new PublicKey(compression.assetProof.tree_id);
  const treeAuthority = compression.merkleTree?.getAuthority();
  const canopyDepth = compression.merkleTree?.getCanopyDepth();
  const leafOwner = new PublicKey(compression.ownership.owner);
  const leafDelegate = !!compression.ownership?.delegate ? new PublicKey(compression.ownership.delegate) : leafOwner;

  // check if the provided assetProof path is valid for the provided root
  if (!MerkleTree.verify(new PublicKey(compression.assetProof.root).toBuffer(), {
    leafIndex: compression.data.leaf_id,
    leaf: new PublicKey(compression.assetProof.leaf).toBuffer(),
    root: new PublicKey(compression.assetProof.root).toBuffer(),
    proof: compression.assetProof.proof.map(node => new PublicKey(node).toBuffer())
  })) throw Error('Provided proof path did not pass verification');

  // parse the list of proof addresses into a valid AccountMeta[]
  const proofPath = compression.assetProof.proof.map(node => ({
    pubkey: new PublicKey(node),
    isSigner: false,
    isWritable: false
  })).slice(0, compression.assetProof.proof.length - (!!canopyDepth ? canopyDepth : 0));
  return TransactionBuilder.make().setFeePayer(payer).add({
    instruction: createTransferInstruction({
      merkleTree,
      treeAuthority,
      leafOwner,
      leafDelegate,
      newLeafOwner: toOwner,
      logWrapper: SPL_NOOP_PROGRAM_ID,
      compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
      anchorRemainingAccounts: proofPath
    }, {
      root: [...new PublicKey(compression.assetProof.root.trim()).toBytes()],
      dataHash: [...new PublicKey(compression.data.data_hash.trim()).toBytes()],
      creatorHash: [...new PublicKey(compression.data.creator_hash.trim()).toBytes()],
      nonce: compression.data.leaf_id,
      index: compression.data.leaf_id
    }),
    signers: [payer],
    key: params.instructionKey ?? 'transferCompressedNft'
  });
};

/**
 * Helper function to auto fetch the asset proof data from the ReadApi
 */
async function prepareTransferCompressedNftBuilder(metaplex, params) {
  if (!params?.compression) params.compression = {};

  // auto fetch the assetProof data from the ReadApi, when not provided
  if (!params?.compression?.assetProof) {
    params.compression.assetProof = await metaplex.rpc().getAssetProof(params.nftOrSft.address);
  }
  const [asset, merkleTree] = await Promise.all([
  // get the asset from the ReadApi
  metaplex.rpc().getAsset(params.nftOrSft.address),
  // get the on-chain merkle tree AccountInfo (mainly needed for the `canopyHeight`)
  ConcurrentMerkleTreeAccount.fromAccountAddress(metaplex.connection, new PublicKey(params.compression.assetProof.tree_id))]);

  // update the params data for use by the transfer operation
  params.compression.merkleTree = merkleTree;
  params.compression.data = asset.compression;
  params.compression.ownership = asset.ownership;
  return params;
}

export { prepareTransferCompressedNftBuilder, transferCompressedNftBuilder, transferCompressedNftOperation, transferCompressedNftOperationHandler };
//# sourceMappingURL=transferCompressedNft.mjs.map
