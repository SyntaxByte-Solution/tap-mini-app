'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mplTokenMetadata = require('@metaplex-foundation/mpl-token-metadata');
var web3_js = require('@solana/web3.js');
var Sft = require('../models/Sft.cjs');
var Operation = require('../../../types/Operation.cjs');
var PublicKey = require('../../../types/PublicKey.cjs');
var Metadata = require('../models/Metadata.cjs');
var Signer = require('../../../types/Signer.cjs');
var TransactionBuilder = require('../../../utils/TransactionBuilder.cjs');

// -----------------
// Operation
// -----------------

const Key = 'CreateSftOperation';

/**
 * Creates a new SFT.
 *
 * ```ts
 * const { sft } = await metaplex
 *   .nfts()
 *   .createSft({
 *     name: 'My SFT',
 *     uri: 'https://example.com/my-sft',
 *     sellerFeeBasisPoints: 250, // 2.5%
 *   };
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const createSftOperation = Operation.useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const createSftOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const {
      useNewMint = web3_js.Keypair.generate(),
      useExistingMint,
      tokenOwner,
      tokenAddress: tokenSigner
    } = operation.input;
    const mintAddress = useExistingMint ?? useNewMint.publicKey;
    const associatedTokenAddress = tokenOwner ? metaplex.tokens().pdas().associatedTokenAccount({
      mint: mintAddress,
      owner: tokenOwner,
      programs: scope.programs
    }) : null;
    const tokenAddress = tokenSigner ? PublicKey.toPublicKey(tokenSigner) : associatedTokenAddress;
    let tokenExists;
    if (!!useExistingMint && !!tokenAddress) {
      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);
      tokenExists = tokenAccount.exists;
    } else {
      tokenExists = false;
    }
    const builder = await createSftBuilder(metaplex, {
      ...operation.input,
      useNewMint,
      tokenExists
    }, scope);
    scope.throwIfCanceled();
    const confirmOptions = Operation.makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);
    const output = await builder.sendAndConfirm(metaplex, confirmOptions);
    scope.throwIfCanceled();
    const sft = await metaplex.nfts().findByMint({
      mintAddress: output.mintAddress,
      tokenAddress: output.tokenAddress ?? undefined
    }, scope);
    scope.throwIfCanceled();
    Sft.assertSft(sft);
    return {
      ...output,
      sft
    };
  }
};

// -----------------
// Builder
// -----------------

/**
 * @group Transaction Builders
 * @category Inputs
 */

/**
 * Creates a new SFT.
 *
 * ```ts
 * const transactionBuilder = await metaplex
 *   .nfts()
 *   .builders()
 *   .createSft({
 *     name: 'My SFT',
 *     uri: 'https://example.com/my-sft',
 *     sellerFeeBasisPoints: 250, // 2.5%
 *   });
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */
const createSftBuilder = async (metaplex, params, options = {}) => {
  const {
    programs,
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const {
    useNewMint = web3_js.Keypair.generate(),
    updateAuthority = metaplex.identity(),
    mintAuthority = metaplex.identity(),
    tokenStandard = params.tokenStandard ?? mplTokenMetadata.TokenStandard.FungibleAsset
  } = params;
  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;
  const associatedTokenAddress = params.tokenOwner ? metaplex.tokens().pdas().associatedTokenAccount({
    mint: mintAddress,
    owner: params.tokenOwner,
    programs
  }) : null;
  const tokenAddress = params.tokenAddress ? PublicKey.toPublicKey(params.tokenAddress) : associatedTokenAddress;
  const systemProgram = metaplex.programs().getSystem(programs);
  const tokenProgram = metaplex.programs().getToken(programs);
  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);
  const metadataPda = metaplex.nfts().pdas().metadata({
    mint: mintAddress,
    programs
  });
  const masterEditionPda = metaplex.nfts().pdas().masterEdition({
    mint: mintAddress,
    programs
  });
  const creatorsInput = params.creators ?? [{
    address: updateAuthority.publicKey,
    authority: updateAuthority,
    share: 100
  }];
  const creators = creatorsInput.length > 0 ? creatorsInput.map(creator => ({
    ...creator,
    verified: creator.address.equals(updateAuthority.publicKey)
  })) : null;
  let printSupply = null;
  if (Metadata.isNonFungible({
    tokenStandard
  })) {
    if (params.maxSupply === undefined) {
      printSupply = {
        __kind: 'Zero'
      };
    } else if (params.maxSupply === null) {
      printSupply = {
        __kind: 'Unlimited'
      };
    } else {
      printSupply = {
        __kind: 'Limited',
        fields: [params.maxSupply]
      };
    }
  }
  const createInstruction = mplTokenMetadata.createCreateInstruction({
    metadata: metadataPda,
    masterEdition: Metadata.isNonFungible({
      tokenStandard
    }) ? masterEditionPda : undefined,
    mint: mintAddress,
    authority: mintAuthority.publicKey,
    payer: payer.publicKey,
    updateAuthority: updateAuthority.publicKey,
    systemProgram: systemProgram.address,
    sysvarInstructions: web3_js.SYSVAR_INSTRUCTIONS_PUBKEY,
    splTokenProgram: tokenProgram.address
  }, {
    createArgs: {
      __kind: 'V1',
      assetData: {
        name: params.name,
        symbol: params.symbol ?? '',
        uri: params.uri,
        sellerFeeBasisPoints: params.sellerFeeBasisPoints,
        creators,
        primarySaleHappened: params.primarySaleHappened ?? false,
        isMutable: params.isMutable ?? true,
        tokenStandard,
        collection: params.collection ? {
          key: params.collection,
          verified: false
        } : null,
        uses: params.uses ?? null,
        collectionDetails: params.isCollection ? {
          __kind: 'V1',
          size: 0
        } // Size ignored by program.
        : null,
        ruleSet: params.ruleSet ?? null
      },
      decimals: params.decimals ?? 0,
      printSupply
    }
  }, tokenMetadataProgram.address);
  const createSigners = [payer, mintAuthority, updateAuthority];
  if (!params.useExistingMint) {
    createSigners.push(useNewMint);
    createInstruction.keys[2].isSigner = true;
  }

  // When the payer is different than the update authority, the latter will
  // not be marked as a signer and therefore signing as a creator will fail.
  createInstruction.keys[5].isSigner = true;
  let createNonAtaInstruction = null;
  // Create the token account if it doesn't exist.
  if (!params.tokenExists && !!params.tokenAddress && Signer.isSigner(params.tokenAddress)) {
    createNonAtaInstruction = await metaplex.tokens().builders().createToken({
      mint: mintAddress,
      owner: params.tokenOwner,
      token: params.tokenAddress,
      createAccountInstructionKey: params.createTokenAccountInstructionKey,
      initializeTokenInstructionKey: params.initializeTokenInstructionKey
    }, {
      programs,
      payer
    });
  }

  // Mint provided amount to the token account.
  let mintInstruction = null;
  if (tokenAddress && params.tokenAmount) {
    mintInstruction = metaplex.nfts().builders().mint({
      nftOrSft: {
        address: mintAddress,
        tokenStandard
      },
      authority: Metadata.isNonFungible({
        tokenStandard
      }) ? updateAuthority : mintAuthority,
      toOwner: params.tokenOwner,
      toToken: tokenAddress,
      amount: params.tokenAmount
    }, {
      programs,
      payer
    });
  }
  const verifyAdditionalCreatorInstructions = creatorsInput.filter(creator => {
    return !!creator.authority && !creator.address.equals(updateAuthority.publicKey);
  }).map(creator => {
    return metaplex.nfts().builders().verifyCreator({
      mintAddress,
      creator: creator.authority
    }, {
      programs,
      payer
    });
  });
  return TransactionBuilder.TransactionBuilder.make().setFeePayer(payer).setContext({
    mintAddress,
    metadataAddress: metadataPda,
    tokenAddress
  })

  // Create the mint and token accounts before minting 1 token to the owner.
  // .add(mintAndTokenBuilder)

  // Create metadata/edition accounts.
  .add({
    instruction: createInstruction,
    signers: createSigners,
    key: params.createInstructionKey ?? 'createMetadata'
  })

  // Create the non-associated token account if needed.
  .add(...(createNonAtaInstruction ? [createNonAtaInstruction] : []))

  // Mint provided amount to the token account, if any.
  .add(...(mintInstruction ? [mintInstruction] : []))

  // Verify additional creators.
  .add(...verifyAdditionalCreatorInstructions)

  // Verify collection.
  .when(!!params.collection && !!params.collectionAuthority, builder => builder.add(metaplex.nfts().builders().verifyCollection({
    mintAddress,
    collectionMintAddress: params.collection,
    collectionAuthority: params.collectionAuthority,
    isDelegated: params.collectionAuthorityIsDelegated ?? false,
    isSizedCollection: params.collectionIsSized ?? true
  }, {
    payer,
    programs
  })));
};

exports.createSftBuilder = createSftBuilder;
exports.createSftOperation = createSftOperation;
exports.createSftOperationHandler = createSftOperationHandler;
//# sourceMappingURL=createSft.cjs.map
