"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPath = void 0;
const fs_1 = require("fs");
const upload_1 = __importDefault(require("../common/upload"));
const mime_types_1 = __importDefault(require("mime-types"));
const inquirer_1 = __importDefault(require("inquirer"));
const stream_1 = require("stream");
const path_1 = require("path");
const csv_parse_1 = __importDefault(require("csv-parse"));
const csv_stringify_1 = __importDefault(require("csv-stringify"));
const checkPath = (path) => __awaiter(void 0, void 0, void 0, function* () {
    return fs_1.promises
        .stat(path)
        .then((_) => true)
        .catch((_) => false);
});
exports.checkPath = checkPath;
class NodeUploader extends upload_1.default {
    constructor(api, utils, token, tokenConfig, irysTx) {
        super(api, utils, token, tokenConfig, irysTx);
    }
    /**
     * Uploads a file to the bundler
     * @param path to the file to be uploaded
     * @returns the response from the bundler
     */
    uploadFile(path, opts) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield fs_1.promises
                .stat(path)
                .then((_) => true)
                .catch((_) => false))) {
                throw new Error(`Unable to access path: ${path}`);
            }
            // don't add Content-type tag if it already exists
            const hasContentTypeTag = (opts === null || opts === void 0 ? void 0 : opts.tags) && opts.tags.some((t) => t.name.toLowerCase() === "content-type");
            const mimeType = mime_types_1.default.contentType(mime_types_1.default.lookup(path) || "application/octet-stream");
            (opts !== null && opts !== void 0 ? opts : (opts = {})).tags = hasContentTypeTag
                ? opts.tags
                : [{ name: "Content-Type", value: (_a = this.contentTypeOverride) !== null && _a !== void 0 ? _a : mimeType }, ...((_b = opts === null || opts === void 0 ? void 0 : opts.tags) !== null && _b !== void 0 ? _b : [])];
            const data = (0, fs_1.createReadStream)(path);
            return yield this.uploadData(data, opts);
        });
    }
    walk(dir) {
        return __asyncGenerator(this, arguments, function* walk_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(yield __await(fs_1.promises.opendir(dir))), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const d = _c;
                    const entry = (0, path_1.join)(dir, d.name);
                    if (d.isDirectory())
                        yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this.walk(entry)))));
                    else if (d.isFile())
                        yield yield __await(entry);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Preprocessor for folder uploads, ensures the rest of the system has a correct operating environment.
     * @param path - path to the folder to be uploaded
     * @param indexFile - path to the index file (i.e index.html)
     * @param batchSize - number of items to upload concurrently
     * @param interactivePreflight - whether to interactively prompt the user for confirmation of upload (CLI ONLY)
     * @param keepDeleted - Whether to keep previously uploaded (but now deleted) files in the manifest
     * @param logFunction - for handling logging from the uploader for UX
     * @returns
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    uploadFolder(path, { batchSize = 10, keepDeleted = true, indexFile, interactivePreflight, logFunction, manifestTags, itemOptions, } = { batchSize: 10, keepDeleted: true }) {
        var _a, e_2, _b, _c, _d, e_3, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            path = (0, path_1.resolve)(path);
            const alreadyProcessed = new Map();
            const receiptTxs = new Map();
            if (!(yield (0, exports.checkPath)(path))) {
                throw new Error(`Unable to access path: ${path}`);
            }
            // fallback to console.log if no logging function is given and interactive preflight is on.
            if (!logFunction && interactivePreflight) {
                logFunction = (log) => __awaiter(this, void 0, void 0, function* () {
                    console.log(log);
                });
            }
            else if (!logFunction) {
                // blackhole logs
                logFunction = (_) => __awaiter(this, void 0, void 0, function* () {
                    return;
                });
            }
            // manifest with folder name placed in parent directory of said folder - keeps contamination down.
            const manifestPath = (0, path_1.join)((0, path_1.join)(path, `${path_1.sep}..`), `${(0, path_1.basename)(path)}-manifest.csv`);
            const csvHeader = "path,id,receipt\n";
            if (yield (0, exports.checkPath)(manifestPath)) {
                const rstrm = (0, fs_1.createReadStream)(manifestPath);
                // check if empty
                if ((yield fs_1.promises.stat(manifestPath)).size === 0) {
                    yield fs_1.promises.writeFile(manifestPath, csvHeader);
                }
                // validate header
                yield new Promise((res) => {
                    (0, fs_1.createReadStream)(manifestPath).once("data", (d) => __awaiter(this, void 0, void 0, function* () {
                        const fl = d.toString().split("\n")[0];
                        if (`${fl}\n` !== csvHeader) {
                            yield fs_1.promises.writeFile(manifestPath, csvHeader);
                        }
                        res(d);
                    }));
                });
                const csvStream = stream_1.Readable.from(rstrm.pipe((0, csv_parse_1.default)({ delimiter: ",", columns: true })));
                try {
                    for (var _g = true, csvStream_1 = __asyncValues(csvStream), csvStream_1_1; csvStream_1_1 = yield csvStream_1.next(), _a = csvStream_1_1.done, !_a; _g = true) {
                        _c = csvStream_1_1.value;
                        _g = false;
                        const record = _c;
                        record;
                        if (record.path && record.id) {
                            alreadyProcessed.set(record.path, record.id);
                            receiptTxs.set(record.path, JSON.parse(record.receipt));
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (!_g && !_a && (_b = csvStream_1.return)) yield _b.call(csvStream_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            else {
                yield fs_1.promises.writeFile(manifestPath, csvHeader);
            }
            const files = [];
            let total = 0;
            let i = 0;
            try {
                for (var _h = true, _j = __asyncValues(this.walk(path)), _k; _k = yield _j.next(), _d = _k.done, !_d; _h = true) {
                    _f = _k.value;
                    _h = false;
                    const f = _f;
                    const relPath = (0, path_1.relative)(path, f);
                    if (!alreadyProcessed.has(relPath)) {
                        files.push(f);
                        total += (yield fs_1.promises.stat(f)).size;
                    }
                    else {
                        alreadyProcessed.delete(relPath);
                    }
                    if (++i % batchSize == 0) {
                        logFunction(`Checked ${i} files...`);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_h && !_d && (_e = _j.return)) yield _e.call(_j);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (!keepDeleted) {
                alreadyProcessed.clear();
            }
            // pass as param otherwise it thinks logFunction can be undef
            const uploadManifest = (logFunction) => __awaiter(this, void 0, void 0, function* () {
                // generate JSON
                yield logFunction("Generating JSON manifest...");
                const jsonManifestPath = yield this.generateManifestFromCsv(path, alreadyProcessed, indexFile);
                // upload the manifest
                yield logFunction("Uploading JSON manifest...");
                const tags = [
                    { name: "Type", value: "manifest" },
                    { name: "Content-Type", value: "application/x.arweave-manifest+json" },
                    ...(manifestTags !== null && manifestTags !== void 0 ? manifestTags : []),
                ];
                const mres = yield this.uploadData((0, fs_1.createReadStream)(jsonManifestPath), { tags }).catch((e) => {
                    throw new Error(`Failed to upload manifest: ${e.message}`);
                });
                yield logFunction("Done!");
                if (mres === null || mres === void 0 ? void 0 : mres.id) {
                    yield fs_1.promises.writeFile((0, path_1.join)((0, path_1.join)(path, `${path_1.sep}..`), `${(0, path_1.basename)(path)}-id.txt`), JSON.stringify(mres));
                }
                else {
                    throw new Error(`Unable to get upload ID! ${JSON.stringify(mres)}`);
                }
                return mres;
            });
            // TODO: add logic to detect changes (MD5/other hash)
            if (files.length == 0 && alreadyProcessed.size === 0) {
                logFunction("No items to process");
                // return the txID of the upload
                const idpath = (0, path_1.join)((0, path_1.join)(path, `${path_1.sep}..`), `${(0, path_1.basename)(path)}-id.txt`);
                if (yield (0, exports.checkPath)(idpath)) {
                    return JSON.parse(yield fs_1.promises.readFile(idpath, "utf-8"));
                }
                // assume manifest wasn't uploaded
                return yield uploadManifest(logFunction);
            }
            // const zprice = (await this.utils.getPrice(this.currency, 0)).multipliedBy(files.length);
            // const price = (await this.utils.getPrice(this.currency, total)).plus(zprice).toFixed(0);
            const price = yield this.utils.estimateFolderPrice({ fileCount: files.length, totalBytes: total });
            if (interactivePreflight) {
                if (!(yield confirmation(`Authorize upload?\nTotal amount of data: ${total} bytes over ${files.length} files - cost: ${price} ${this.tokenConfig.base[0]} (${this.utils.fromAtomic(price).toFixed()} ${this.token})\n Y / N`))) {
                    throw new Error("Confirmation failed");
                }
            }
            const stringifier = (0, csv_stringify_1.default)({
                header: false,
                columns: {
                    path: "path",
                    id: "id",
                    receipt: "receipt",
                },
            });
            const wstrm = (0, fs_1.createWriteStream)(manifestPath, { flags: "a+" });
            stringifier.pipe(wstrm);
            const processor = (data) => __awaiter(this, void 0, void 0, function* () {
                var _l;
                if ((_l = data === null || data === void 0 ? void 0 : data.res) === null || _l === void 0 ? void 0 : _l.id) {
                    const receipt = data.res.signature
                        ? {
                            id: data.res.id,
                            block: data.res.block,
                            deadlineHeight: data.res.deadlineHeight,
                            public: data.res.public,
                            signature: data.res.signature,
                            timestamp: data.res.timestamp,
                            validatorSignatures: data.res.validatorSignatures,
                            version: data.res.version,
                        }
                        : {};
                    receiptTxs.set((0, path_1.relative)(path, data.item), receipt);
                    stringifier.write([(0, path_1.relative)(path, data.item), data.res.id, JSON.stringify(receipt)]);
                }
            });
            const processingResults = yield this.concurrentUploader(files, {
                concurrency: batchSize,
                resultProcessor: processor,
                logFunction,
                itemOptions,
            });
            if (processingResults.errors.length > 0) {
                yield logFunction(`${processingResults.errors.length} Errors detected, skipping manifest upload...`);
                const ewstrm = (0, fs_1.createWriteStream)((0, path_1.join)((0, path_1.join)(path, `${path_1.sep}..`), `${(0, path_1.basename)(path)}-errors.txt`), { flags: "a+" });
                ewstrm.write(`Errors from upload at ${new Date().toString()}:\n`);
                processingResults.errors.forEach((e) => { var _a; return ewstrm.write(`${(_a = e === null || e === void 0 ? void 0 : e.stack) !== null && _a !== void 0 ? _a : JSON.stringify(e)}\n`); });
                yield new Promise((res) => ewstrm.close(res));
                throw new Error(`${processingResults.errors.length} Errors detected - check ${(0, path_1.basename)(path)}-errors.txt for more information.`);
            }
            yield logFunction(`Finished processing ${files.length} Items`);
            yield new Promise((r) => wstrm.close(r));
            return yield uploadManifest(logFunction);
        });
    }
    /**
     * processes an item to convert it into a DataItem, and then uploads it.
     * @param item can be a string value, a path to a file, a Buffer of data or a DataItem
     * @returns A dataItem
     */
    processItem(item, opts) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.arbundles.DataItem.isDataItem(item)) {
                return this.uploadTransaction(item, Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.upload));
            }
            let tags;
            if (typeof item === "string") {
                if (yield (0, exports.checkPath)(item)) {
                    const mimeType = mime_types_1.default.contentType(mime_types_1.default.lookup(item) || "application/octet-stream");
                    tags = [{ name: "Content-Type", value: (_a = this.contentTypeOverride) !== null && _a !== void 0 ? _a : mimeType }];
                    // returnVal = item;
                    item = (0, fs_1.createReadStream)(item);
                }
                else {
                    item = Buffer.from(item);
                    if (this.contentTypeOverride) {
                        tags = [{ name: "Content-Type", value: this.contentTypeOverride }];
                    }
                }
            }
            return this.uploadData(item, Object.assign(Object.assign({}, opts), { tags: [...tags, ...((_b = opts === null || opts === void 0 ? void 0 : opts.tags) !== null && _b !== void 0 ? _b : [])] }));
        });
    }
    /**
     * Stream-based CSV parser and JSON assembler
     * @param path base path of the upload
     * @param indexFile optional path to an index file
     * @returns the path to the generated manifest
     */
    generateManifestFromCsv(path, nowRemoved, indexFile) {
        var _a, e_4, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const csvstrm = (0, csv_parse_1.default)({ delimiter: ",", columns: true });
            const csvPath = (0, path_1.join)((0, path_1.join)(path, `${path_1.sep}..`), `${(0, path_1.basename)(path)}-manifest.csv`);
            const manifestPath = (0, path_1.join)((0, path_1.join)(path, `${path_1.sep}..`), `${(0, path_1.basename)(path)}-manifest.json`);
            const wstrm = (0, fs_1.createWriteStream)(manifestPath, { flags: "w+" });
            (0, fs_1.createReadStream)(csvPath).pipe(csvstrm); // pipe csv
            /* eslint-disable quotes */
            // "header"
            wstrm.write(`{\n"manifest": "arweave/paths",\n"version": "0.1.0",\n"paths": {\n`);
            const csvs = stream_1.Readable.from(csvstrm);
            let firstValue = true;
            try {
                for (var _d = true, csvs_1 = __asyncValues(csvs), csvs_1_1; csvs_1_1 = yield csvs_1.next(), _a = csvs_1_1.done, !_a; _d = true) {
                    _c = csvs_1_1.value;
                    _d = false;
                    const d = _c;
                    if (nowRemoved === null || nowRemoved === void 0 ? void 0 : nowRemoved.has(d.path)) {
                        nowRemoved.delete(d.path);
                        continue;
                    }
                    const prefix = firstValue ? "" : ",\n";
                    wstrm.write(`${prefix}"${d.path.replaceAll("\\", "/")}":{"id":"${d.id}"}`);
                    firstValue = false;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = csvs_1.return)) yield _b.call(csvs_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            // "trailer"
            wstrm.write(`\n}`);
            // add index
            if (indexFile) {
                wstrm.write(`,\n"index":{"path":"${indexFile.replaceAll("\\", "/")}"}`);
            }
            wstrm.write(`\n}`);
            yield new Promise((r) => wstrm.close(r));
            return manifestPath;
        });
    }
}
exports.default = NodeUploader;
function confirmation(message) {
    return __awaiter(this, void 0, void 0, function* () {
        const answers = yield inquirer_1.default.prompt([{ type: "input", name: "confirmation", message }]);
        return answers.confirmation.toLowerCase() == "y";
    });
}
//# sourceMappingURL=upload.js.map