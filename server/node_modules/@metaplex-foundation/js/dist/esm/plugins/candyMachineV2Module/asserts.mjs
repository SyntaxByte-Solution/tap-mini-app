import { EndSettingType } from '@metaplex-foundation/mpl-candy-machine';
import { MAX_NAME_LENGTH, MAX_URI_LENGTH } from './constants.mjs';
import { CandyMachineV2IsFullError, CandyMachineV2CannotAddAmountError, CandyMachineV2AddItemConstraintsViolatedError, CandyMachineV2IsEmptyError, CandyMachineV2NotLiveError, CandyMachineV2EndedError } from './errors.mjs';
import assert from '../../utils/assert.mjs';
import { toBigNumber } from '../../types/BigNumber.mjs';
import { now } from '../../types/DateTime.mjs';

const assertName = name => {
  assert(name.length <= MAX_NAME_LENGTH, `Candy Machine name too long: ${name} (max ${MAX_NAME_LENGTH})`);
};
const assertUri = uri => {
  assert(uri.length <= MAX_URI_LENGTH, `Candy Machine URI too long: ${uri} (max ${MAX_URI_LENGTH})`);
};
const assertNotFull = (candyMachine, index) => {
  if (candyMachine.itemsAvailable.lte(candyMachine.itemsLoaded)) {
    throw new CandyMachineV2IsFullError(index, candyMachine.itemsAvailable);
  }
};
const assertNotEmpty = candyMachine => {
  if (candyMachine.itemsRemaining.isZero()) {
    throw new CandyMachineV2IsEmptyError(candyMachine.itemsAvailable);
  }
};
const assertCanAdd = (candyMachine, index, amount) => {
  if (index.addn(amount).gt(candyMachine.itemsAvailable)) {
    throw new CandyMachineV2CannotAddAmountError(index, amount, candyMachine.itemsAvailable);
  }
};
const assertAllConfigLineConstraints = configLines => {
  for (let i = 0; i < configLines.length; i++) {
    try {
      assertName(configLines[i].name);
      assertUri(configLines[i].uri);
    } catch (error) {
      throw new CandyMachineV2AddItemConstraintsViolatedError(toBigNumber(i), configLines[i], error);
    }
  }
};
const assertCandyMachineV2IsLive = candyMachine => {
  const hasWhitelistPresale = candyMachine.whitelistMintSettings?.presale ?? false;
  if (hasWhitelistPresale) {
    return;
  }
  const liveDate = candyMachine.goLiveDate;
  if (!liveDate || liveDate.gte(now())) {
    throw new CandyMachineV2NotLiveError(liveDate);
  }
};
const assertCandyMachineV2HasNotEnded = candyMachine => {
  const {
    endSettings
  } = candyMachine;
  if (!endSettings) {
    return;
  }
  const hasEndedByAmount = endSettings.endSettingType === EndSettingType.Amount && candyMachine.itemsMinted.gte(endSettings.number);
  const hasEndedByDate = endSettings.endSettingType === EndSettingType.Date && endSettings.date.lt(now());
  if (hasEndedByAmount || hasEndedByDate) {
    throw new CandyMachineV2EndedError(endSettings);
  }
};
const assertCanMintCandyMachineV2 = (candyMachine, payer) => {
  assertNotEmpty(candyMachine);
  if (candyMachine.authorityAddress.equals(payer.publicKey)) {
    return;
  }
  assertCandyMachineV2IsLive(candyMachine);
  assertCandyMachineV2HasNotEnded(candyMachine);
};

export { assertAllConfigLineConstraints, assertCanAdd, assertCanMintCandyMachineV2, assertCandyMachineV2HasNotEnded, assertCandyMachineV2IsLive, assertName, assertNotEmpty, assertNotFull, assertUri };
//# sourceMappingURL=asserts.mjs.map
