import Uploader from "../common/upload.js";
import { ArweaveSigner } from "arbundles";
export class WebUploader extends Uploader {
    irys;
    constructor(irys) {
        super(irys.api, irys.utils, irys.token, irys.tokenConfig, irys.IrysTransaction);
        this.irys = irys;
    }
    /**
     * Uploads a tagged file object, automatically adding the content-type tag if it's not present
     * @param file - File object to upload
     * @param opts - optional options for the upload / data item creation
     * @returns
     */
    async uploadFile(file, opts) {
        const hasContentType = opts?.tags ? opts.tags.some(({ name }) => name.toLowerCase() === "content-type") : false;
        const tags = hasContentType ? opts?.tags : [...(opts?.tags ?? []), { name: "Content-Type", value: file.type }];
        return this.uploadData(Buffer.from(await file.arrayBuffer()), { tags, ...opts });
    }
    /**
     * Uploads a list of `File` objects & a generated folder manifest as a nested bundle using a temporary signing key.
     *
     * @param files list of `File` objects to upload - note: this code determines the paths via the File's `webkitRelativePath` property - if it's undefined, it falls back to file.name
     * @param {string} [opts.indexFileRelPath] Relative path for the index file, i.e `folder/index.html`
     * @param {Tag[]} [opts.manifestTags] List of tags to add onto the manifest transaction
     * @param {JWKInterface} [opts.throwawayKey] Provide your own throwaway JWK to use for signing the items in the bundle
     * @param {boolean} [opts.seperateManifestTx=false] Whether upload the manifest as a seperate tx (not in the nested bundle) - note: transactions in a nested bundle are not indexed by bundlr GQL - if you have tags you want to use to find the manifest, set this option to true
     *
     * @returns Standard upload response from the bundler node, plus the throwaway key & address, manifest, manifest TxId and the list of generated transactions
     */
    async uploadFolder(files, opts) {
        const txs = [];
        const txMap = new Map();
        const throwawayKey = opts?.throwawayKey ?? (await this.irys.arbundles.getCryptoDriver().generateJWK());
        const ephemeralSigner = new ArweaveSigner(throwawayKey);
        for (const file of files) {
            const path = file.webkitRelativePath ? file.webkitRelativePath : file.name;
            const hasContentType = file.tags ? file.tags.some(({ name }) => name.toLowerCase() === "content-type") : false;
            const tags = hasContentType ? file.tags : [...(file.tags ?? []), { name: "Content-Type", value: file.type }];
            const tx = this.irys.arbundles.createData(Buffer.from(await file.arrayBuffer()), ephemeralSigner, {
                tags,
            });
            await tx.sign(ephemeralSigner);
            txs.push(tx);
            txMap.set(path, tx.id);
        }
        // generate manifest, add to bundle
        const manifest = await this.generateManifest({ items: txMap, indexFile: opts?.indexFileRelPath });
        const manifestTx = this.irys.arbundles.createData(JSON.stringify(manifest), opts?.seperateManifestTx ? this.irys.tokenConfig.getSigner() : ephemeralSigner, {
            tags: [
                { name: "Type", value: "manifest" },
                { name: "Content-Type", value: "application/x.arweave-manifest+json" },
                ...(opts?.manifestTags ?? []),
            ],
        });
        if (opts?.seperateManifestTx === true) {
            await manifestTx.sign(this.irys.tokenConfig.getSigner());
            await this.uploadTransaction(manifestTx, { ...opts });
        }
        else {
            await manifestTx.sign(ephemeralSigner);
            txs.push(manifestTx);
        }
        // upload bundle
        const bundleRes = await this.uploadBundle(txs, { ...opts });
        return {
            ...bundleRes.data,
            manifestId: manifestTx.id,
            manifest,
            throwawayKey: bundleRes.throwawayKey,
            throwawayKeyAddress: bundleRes.throwawayKeyAddress,
            txs: bundleRes.txs,
        };
    }
}
//# sourceMappingURL=upload.js.map