import { createSerializerFromSolitaType, deserializeAccount } from './Serializer.mjs';
import { AccountNotFoundError } from '../errors/SdkError.mjs';

function getAccountParsingFunction(parser) {
  function parse(account) {
    if ('exists' in account && !account.exists) {
      return account;
    }
    const serializer = createSerializerFromSolitaType(parser);
    return deserializeAccount(account, serializer);
  }
  return parse;
}
function getAccountParsingAndAssertingFunction(parser) {
  const parse = getAccountParsingFunction(parser);
  return (unparsedAccount, solution) => {
    if ('exists' in unparsedAccount) {
      assertAccountExists(unparsedAccount, parser.name, solution);
    }
    return parse(unparsedAccount);
  };
}
function assertAccountExists(account, name, solution) {
  if (!account.exists) {
    throw new AccountNotFoundError(account.publicKey, name, solution);
  }
}
const toAccountInfo = account => {
  const {
    executable,
    owner,
    lamports,
    rentEpoch
  } = account;
  return {
    executable,
    owner,
    lamports,
    rentEpoch
  };
};

export { assertAccountExists, getAccountParsingAndAssertingFunction, getAccountParsingFunction, toAccountInfo };
//# sourceMappingURL=Account.mjs.map
