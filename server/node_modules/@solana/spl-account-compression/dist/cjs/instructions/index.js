"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCloseEmptyTreeIx = exports.createAllocTreeIx = exports.createVerifyLeafIx = exports.createTransferAuthorityIx = exports.createAppendIx = exports.createReplaceIx = exports.createInitEmptyMerkleTreeIx = exports.addProof = void 0;
const web3_js_1 = require("@solana/web3.js");
const accounts_1 = require("../accounts");
const constants_1 = require("../constants");
const generated_1 = require("../generated");
/**
 * Helper function that adds proof nodes to a TransactionInstruction
 * by adding extra keys to the transaction
 */
function addProof(instruction, nodeProof) {
    instruction.keys = instruction.keys.concat(nodeProof.map(node => {
        return {
            isSigner: false,
            isWritable: false,
            pubkey: new web3_js_1.PublicKey(node),
        };
    }));
    return instruction;
}
exports.addProof = addProof;
/**
 * Helper function for {@link createInitEmptyMerkleTreeInstruction}
 *
 * @param merkleTree
 * @param authority
 * @param depthSizePair
 * @returns
 */
function createInitEmptyMerkleTreeIx(merkleTree, authority, depthSizePair) {
    return (0, generated_1.createInitEmptyMerkleTreeInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, depthSizePair);
}
exports.createInitEmptyMerkleTreeIx = createInitEmptyMerkleTreeIx;
/**
 * Helper function for {@link createReplaceLeafInstruction}
 * @param merkleTree
 * @param authority
 * @param proof
 * @param newLeaf
 * @returns
 */
function createReplaceIx(merkleTree, authority, newLeaf, proof) {
    return addProof((0, generated_1.createReplaceLeafInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, {
        index: proof.leafIndex,
        newLeaf: Array.from(newLeaf),
        previousLeaf: Array.from(proof.leaf),
        root: Array.from(proof.root),
    }), proof.proof);
}
exports.createReplaceIx = createReplaceIx;
/**
 * Helper function for {@link createAppendInstruction}
 * @param merkleTree
 * @param authority
 * @param newLeaf
 * @returns
 */
function createAppendIx(merkleTree, authority, newLeaf) {
    return (0, generated_1.createAppendInstruction)({
        authority: authority,
        merkleTree,
        noop: constants_1.SPL_NOOP_PROGRAM_ID,
    }, {
        leaf: Array.from(newLeaf),
    });
}
exports.createAppendIx = createAppendIx;
/**
 * Helper function for {@link createTransferAuthorityIx}
 * @param merkleTree
 * @param authority
 * @param newAuthority
 * @returns
 */
function createTransferAuthorityIx(merkleTree, authority, newAuthority) {
    return (0, generated_1.createTransferAuthorityInstruction)({
        authority: authority,
        merkleTree,
    }, {
        newAuthority,
    });
}
exports.createTransferAuthorityIx = createTransferAuthorityIx;
/**
 * Helper function for {@link createVerifyLeafInstruction}
 * @param merkleTree
 * @param proof
 * @returns
 */
function createVerifyLeafIx(merkleTree, proof) {
    return addProof((0, generated_1.createVerifyLeafInstruction)({
        merkleTree,
    }, {
        index: proof.leafIndex,
        leaf: Array.from(proof.leaf),
        root: Array.from(proof.root),
    }), proof.proof);
}
exports.createVerifyLeafIx = createVerifyLeafIx;
/**
 * Helper function for creating the {@link ConcurrentMerkleTreeAccount}.
 * It is best to use this method to initialize a {@link ConcurrentMerkleTreeAccount}
 * because these accounts can be quite large, and over the limit for what you
 * can allocate via CPI.
 * @param connection
 * @param merkleTree
 * @param payer
 * @param depthSizePair
 * @param canopyDepth
 * @returns
 */
function createAllocTreeIx(connection, merkleTree, payer, depthSizePair, canopyDepth) {
    return __awaiter(this, void 0, void 0, function* () {
        const requiredSpace = (0, accounts_1.getConcurrentMerkleTreeAccountSize)(depthSizePair.maxDepth, depthSizePair.maxBufferSize, canopyDepth !== null && canopyDepth !== void 0 ? canopyDepth : 0);
        return web3_js_1.SystemProgram.createAccount({
            fromPubkey: payer,
            lamports: yield connection.getMinimumBalanceForRentExemption(requiredSpace),
            newAccountPubkey: merkleTree,
            programId: generated_1.PROGRAM_ID,
            space: requiredSpace,
        });
    });
}
exports.createAllocTreeIx = createAllocTreeIx;
/**
 * Helper function for {@link createCloseEmptyTreeInstruction}.
 * @param merkleTree
 * @param authority
 * @param recipient
 * @returns
 */
function createCloseEmptyTreeIx(merkleTree, authority, recipient) {
    return (0, generated_1.createCloseEmptyTreeInstruction)({
        authority,
        merkleTree,
        recipient,
    });
}
exports.createCloseEmptyTreeIx = createCloseEmptyTreeIx;
//# sourceMappingURL=index.js.map