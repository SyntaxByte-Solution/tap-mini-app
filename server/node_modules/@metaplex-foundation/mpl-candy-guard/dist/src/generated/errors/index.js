"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorFromCode = exports.AllocationGuardNotEnabledError = exports.AllocationLimitReachedError = exports.AllocationNotInitializedError = exports.ExceededProgramListSizeError = exports.UnauthorizedProgramFoundError = exports.DuplicatedMintLimitIdError = exports.DuplicatedGroupLabelError = exports.UnlockNotEnabledError = exports.ThawNotEnabledError = exports.ExceededMaximumFreezePeriodError = exports.FreezeEscrowAlreadyExistsError = exports.MissingFreezePeriodError = exports.FreezeNotInitializedError = exports.FreezeGuardNotEnabledError = exports.MissingFreezeInstructionError = exports.AddressNotAuthorizedError = exports.MaximumRedeemedAmountError = exports.MissingNftError = exports.InvalidNftCollectionError = exports.AllowedMintLimitReachedError = exports.AllowedListNotEnabledError = exports.MissingAllowedListProofError = exports.AddressNotFoundInAllowedListError = exports.InvalidMintTimeError = exports.AfterEndDateError = exports.GatewayTokenInvalidError = exports.MissingRequiredSignatureError = exports.TokenTransferFailedError = exports.NotEnoughTokensError = exports.TokenBurnFailedError = exports.NotEnoughSOLError = exports.MintNotLiveError = exports.MintNotLastTransactionError = exports.CollectionUpdateAuthorityKeyMismatchError = exports.MissingCollectionAccountsError = exports.CollectionKeyMismatchError = exports.InstructionNotFoundError = exports.CandyMachineEmptyError = exports.ExceededLengthError = exports.GroupNotFoundError = exports.RequiredGroupLabelNotFoundError = exports.NumericalOverflowErrorError = exports.MissingRemainingAccountError = exports.UninitializedError = exports.IncorrectOwnerError = exports.DataIncrementLimitExceededError = exports.PublicKeyMismatchError = exports.DeserializationErrorError = exports.InvalidAccountSizeError = void 0;
exports.errorFromName = void 0;
const createErrorFromCodeLookup = new Map();
const createErrorFromNameLookup = new Map();
class InvalidAccountSizeError extends Error {
    constructor() {
        super('Could not save guard to account');
        this.code = 0x1770;
        this.name = 'InvalidAccountSize';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidAccountSizeError);
        }
    }
}
exports.InvalidAccountSizeError = InvalidAccountSizeError;
createErrorFromCodeLookup.set(0x1770, () => new InvalidAccountSizeError());
createErrorFromNameLookup.set('InvalidAccountSize', () => new InvalidAccountSizeError());
class DeserializationErrorError extends Error {
    constructor() {
        super('Could not deserialize guard');
        this.code = 0x1771;
        this.name = 'DeserializationError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DeserializationErrorError);
        }
    }
}
exports.DeserializationErrorError = DeserializationErrorError;
createErrorFromCodeLookup.set(0x1771, () => new DeserializationErrorError());
createErrorFromNameLookup.set('DeserializationError', () => new DeserializationErrorError());
class PublicKeyMismatchError extends Error {
    constructor() {
        super('Public key mismatch');
        this.code = 0x1772;
        this.name = 'PublicKeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PublicKeyMismatchError);
        }
    }
}
exports.PublicKeyMismatchError = PublicKeyMismatchError;
createErrorFromCodeLookup.set(0x1772, () => new PublicKeyMismatchError());
createErrorFromNameLookup.set('PublicKeyMismatch', () => new PublicKeyMismatchError());
class DataIncrementLimitExceededError extends Error {
    constructor() {
        super('Exceeded account increase limit');
        this.code = 0x1773;
        this.name = 'DataIncrementLimitExceeded';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DataIncrementLimitExceededError);
        }
    }
}
exports.DataIncrementLimitExceededError = DataIncrementLimitExceededError;
createErrorFromCodeLookup.set(0x1773, () => new DataIncrementLimitExceededError());
createErrorFromNameLookup.set('DataIncrementLimitExceeded', () => new DataIncrementLimitExceededError());
class IncorrectOwnerError extends Error {
    constructor() {
        super('Account does not have correct owner');
        this.code = 0x1774;
        this.name = 'IncorrectOwner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IncorrectOwnerError);
        }
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
createErrorFromCodeLookup.set(0x1774, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());
class UninitializedError extends Error {
    constructor() {
        super('Account is not initialized');
        this.code = 0x1775;
        this.name = 'Uninitialized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UninitializedError);
        }
    }
}
exports.UninitializedError = UninitializedError;
createErrorFromCodeLookup.set(0x1775, () => new UninitializedError());
createErrorFromNameLookup.set('Uninitialized', () => new UninitializedError());
class MissingRemainingAccountError extends Error {
    constructor() {
        super('Missing expected remaining account');
        this.code = 0x1776;
        this.name = 'MissingRemainingAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingRemainingAccountError);
        }
    }
}
exports.MissingRemainingAccountError = MissingRemainingAccountError;
createErrorFromCodeLookup.set(0x1776, () => new MissingRemainingAccountError());
createErrorFromNameLookup.set('MissingRemainingAccount', () => new MissingRemainingAccountError());
class NumericalOverflowErrorError extends Error {
    constructor() {
        super('Numerical overflow error');
        this.code = 0x1777;
        this.name = 'NumericalOverflowError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NumericalOverflowErrorError);
        }
    }
}
exports.NumericalOverflowErrorError = NumericalOverflowErrorError;
createErrorFromCodeLookup.set(0x1777, () => new NumericalOverflowErrorError());
createErrorFromNameLookup.set('NumericalOverflowError', () => new NumericalOverflowErrorError());
class RequiredGroupLabelNotFoundError extends Error {
    constructor() {
        super('Missing required group label');
        this.code = 0x1778;
        this.name = 'RequiredGroupLabelNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, RequiredGroupLabelNotFoundError);
        }
    }
}
exports.RequiredGroupLabelNotFoundError = RequiredGroupLabelNotFoundError;
createErrorFromCodeLookup.set(0x1778, () => new RequiredGroupLabelNotFoundError());
createErrorFromNameLookup.set('RequiredGroupLabelNotFound', () => new RequiredGroupLabelNotFoundError());
class GroupNotFoundError extends Error {
    constructor() {
        super('Group not found');
        this.code = 0x1779;
        this.name = 'GroupNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, GroupNotFoundError);
        }
    }
}
exports.GroupNotFoundError = GroupNotFoundError;
createErrorFromCodeLookup.set(0x1779, () => new GroupNotFoundError());
createErrorFromNameLookup.set('GroupNotFound', () => new GroupNotFoundError());
class ExceededLengthError extends Error {
    constructor() {
        super('Value exceeded maximum length');
        this.code = 0x177a;
        this.name = 'ExceededLength';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ExceededLengthError);
        }
    }
}
exports.ExceededLengthError = ExceededLengthError;
createErrorFromCodeLookup.set(0x177a, () => new ExceededLengthError());
createErrorFromNameLookup.set('ExceededLength', () => new ExceededLengthError());
class CandyMachineEmptyError extends Error {
    constructor() {
        super('Candy machine is empty');
        this.code = 0x177b;
        this.name = 'CandyMachineEmpty';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CandyMachineEmptyError);
        }
    }
}
exports.CandyMachineEmptyError = CandyMachineEmptyError;
createErrorFromCodeLookup.set(0x177b, () => new CandyMachineEmptyError());
createErrorFromNameLookup.set('CandyMachineEmpty', () => new CandyMachineEmptyError());
class InstructionNotFoundError extends Error {
    constructor() {
        super('No instruction was found');
        this.code = 0x177c;
        this.name = 'InstructionNotFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InstructionNotFoundError);
        }
    }
}
exports.InstructionNotFoundError = InstructionNotFoundError;
createErrorFromCodeLookup.set(0x177c, () => new InstructionNotFoundError());
createErrorFromNameLookup.set('InstructionNotFound', () => new InstructionNotFoundError());
class CollectionKeyMismatchError extends Error {
    constructor() {
        super('Collection public key mismatch');
        this.code = 0x177d;
        this.name = 'CollectionKeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionKeyMismatchError);
        }
    }
}
exports.CollectionKeyMismatchError = CollectionKeyMismatchError;
createErrorFromCodeLookup.set(0x177d, () => new CollectionKeyMismatchError());
createErrorFromNameLookup.set('CollectionKeyMismatch', () => new CollectionKeyMismatchError());
class MissingCollectionAccountsError extends Error {
    constructor() {
        super('Missing collection accounts');
        this.code = 0x177e;
        this.name = 'MissingCollectionAccounts';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingCollectionAccountsError);
        }
    }
}
exports.MissingCollectionAccountsError = MissingCollectionAccountsError;
createErrorFromCodeLookup.set(0x177e, () => new MissingCollectionAccountsError());
createErrorFromNameLookup.set('MissingCollectionAccounts', () => new MissingCollectionAccountsError());
class CollectionUpdateAuthorityKeyMismatchError extends Error {
    constructor() {
        super('Collection update authority public key mismatch');
        this.code = 0x177f;
        this.name = 'CollectionUpdateAuthorityKeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CollectionUpdateAuthorityKeyMismatchError);
        }
    }
}
exports.CollectionUpdateAuthorityKeyMismatchError = CollectionUpdateAuthorityKeyMismatchError;
createErrorFromCodeLookup.set(0x177f, () => new CollectionUpdateAuthorityKeyMismatchError());
createErrorFromNameLookup.set('CollectionUpdateAuthorityKeyMismatch', () => new CollectionUpdateAuthorityKeyMismatchError());
class MintNotLastTransactionError extends Error {
    constructor() {
        super('Mint must be the last instructions of the transaction');
        this.code = 0x1780;
        this.name = 'MintNotLastTransaction';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MintNotLastTransactionError);
        }
    }
}
exports.MintNotLastTransactionError = MintNotLastTransactionError;
createErrorFromCodeLookup.set(0x1780, () => new MintNotLastTransactionError());
createErrorFromNameLookup.set('MintNotLastTransaction', () => new MintNotLastTransactionError());
class MintNotLiveError extends Error {
    constructor() {
        super('Mint is not live');
        this.code = 0x1781;
        this.name = 'MintNotLive';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MintNotLiveError);
        }
    }
}
exports.MintNotLiveError = MintNotLiveError;
createErrorFromCodeLookup.set(0x1781, () => new MintNotLiveError());
createErrorFromNameLookup.set('MintNotLive', () => new MintNotLiveError());
class NotEnoughSOLError extends Error {
    constructor() {
        super('Not enough SOL to pay for the mint');
        this.code = 0x1782;
        this.name = 'NotEnoughSOL';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotEnoughSOLError);
        }
    }
}
exports.NotEnoughSOLError = NotEnoughSOLError;
createErrorFromCodeLookup.set(0x1782, () => new NotEnoughSOLError());
createErrorFromNameLookup.set('NotEnoughSOL', () => new NotEnoughSOLError());
class TokenBurnFailedError extends Error {
    constructor() {
        super('Token burn failed');
        this.code = 0x1783;
        this.name = 'TokenBurnFailed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenBurnFailedError);
        }
    }
}
exports.TokenBurnFailedError = TokenBurnFailedError;
createErrorFromCodeLookup.set(0x1783, () => new TokenBurnFailedError());
createErrorFromNameLookup.set('TokenBurnFailed', () => new TokenBurnFailedError());
class NotEnoughTokensError extends Error {
    constructor() {
        super('Not enough tokens on the account');
        this.code = 0x1784;
        this.name = 'NotEnoughTokens';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotEnoughTokensError);
        }
    }
}
exports.NotEnoughTokensError = NotEnoughTokensError;
createErrorFromCodeLookup.set(0x1784, () => new NotEnoughTokensError());
createErrorFromNameLookup.set('NotEnoughTokens', () => new NotEnoughTokensError());
class TokenTransferFailedError extends Error {
    constructor() {
        super('Token transfer failed');
        this.code = 0x1785;
        this.name = 'TokenTransferFailed';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TokenTransferFailedError);
        }
    }
}
exports.TokenTransferFailedError = TokenTransferFailedError;
createErrorFromCodeLookup.set(0x1785, () => new TokenTransferFailedError());
createErrorFromNameLookup.set('TokenTransferFailed', () => new TokenTransferFailedError());
class MissingRequiredSignatureError extends Error {
    constructor() {
        super('A signature was required but not found');
        this.code = 0x1786;
        this.name = 'MissingRequiredSignature';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingRequiredSignatureError);
        }
    }
}
exports.MissingRequiredSignatureError = MissingRequiredSignatureError;
createErrorFromCodeLookup.set(0x1786, () => new MissingRequiredSignatureError());
createErrorFromNameLookup.set('MissingRequiredSignature', () => new MissingRequiredSignatureError());
class GatewayTokenInvalidError extends Error {
    constructor() {
        super('Gateway token is not valid');
        this.code = 0x1787;
        this.name = 'GatewayTokenInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, GatewayTokenInvalidError);
        }
    }
}
exports.GatewayTokenInvalidError = GatewayTokenInvalidError;
createErrorFromCodeLookup.set(0x1787, () => new GatewayTokenInvalidError());
createErrorFromNameLookup.set('GatewayTokenInvalid', () => new GatewayTokenInvalidError());
class AfterEndDateError extends Error {
    constructor() {
        super('Current time is after the set end date');
        this.code = 0x1788;
        this.name = 'AfterEndDate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AfterEndDateError);
        }
    }
}
exports.AfterEndDateError = AfterEndDateError;
createErrorFromCodeLookup.set(0x1788, () => new AfterEndDateError());
createErrorFromNameLookup.set('AfterEndDate', () => new AfterEndDateError());
class InvalidMintTimeError extends Error {
    constructor() {
        super('Current time is not within the allowed mint time');
        this.code = 0x1789;
        this.name = 'InvalidMintTime';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMintTimeError);
        }
    }
}
exports.InvalidMintTimeError = InvalidMintTimeError;
createErrorFromCodeLookup.set(0x1789, () => new InvalidMintTimeError());
createErrorFromNameLookup.set('InvalidMintTime', () => new InvalidMintTimeError());
class AddressNotFoundInAllowedListError extends Error {
    constructor() {
        super('Address not found on the allowed list');
        this.code = 0x178a;
        this.name = 'AddressNotFoundInAllowedList';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AddressNotFoundInAllowedListError);
        }
    }
}
exports.AddressNotFoundInAllowedListError = AddressNotFoundInAllowedListError;
createErrorFromCodeLookup.set(0x178a, () => new AddressNotFoundInAllowedListError());
createErrorFromNameLookup.set('AddressNotFoundInAllowedList', () => new AddressNotFoundInAllowedListError());
class MissingAllowedListProofError extends Error {
    constructor() {
        super('Missing allowed list proof');
        this.code = 0x178b;
        this.name = 'MissingAllowedListProof';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingAllowedListProofError);
        }
    }
}
exports.MissingAllowedListProofError = MissingAllowedListProofError;
createErrorFromCodeLookup.set(0x178b, () => new MissingAllowedListProofError());
createErrorFromNameLookup.set('MissingAllowedListProof', () => new MissingAllowedListProofError());
class AllowedListNotEnabledError extends Error {
    constructor() {
        super('Allow list guard is not enabled');
        this.code = 0x178c;
        this.name = 'AllowedListNotEnabled';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AllowedListNotEnabledError);
        }
    }
}
exports.AllowedListNotEnabledError = AllowedListNotEnabledError;
createErrorFromCodeLookup.set(0x178c, () => new AllowedListNotEnabledError());
createErrorFromNameLookup.set('AllowedListNotEnabled', () => new AllowedListNotEnabledError());
class AllowedMintLimitReachedError extends Error {
    constructor() {
        super('The maximum number of allowed mints was reached');
        this.code = 0x178d;
        this.name = 'AllowedMintLimitReached';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AllowedMintLimitReachedError);
        }
    }
}
exports.AllowedMintLimitReachedError = AllowedMintLimitReachedError;
createErrorFromCodeLookup.set(0x178d, () => new AllowedMintLimitReachedError());
createErrorFromNameLookup.set('AllowedMintLimitReached', () => new AllowedMintLimitReachedError());
class InvalidNftCollectionError extends Error {
    constructor() {
        super('Invalid NFT collection');
        this.code = 0x178e;
        this.name = 'InvalidNftCollection';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidNftCollectionError);
        }
    }
}
exports.InvalidNftCollectionError = InvalidNftCollectionError;
createErrorFromCodeLookup.set(0x178e, () => new InvalidNftCollectionError());
createErrorFromNameLookup.set('InvalidNftCollection', () => new InvalidNftCollectionError());
class MissingNftError extends Error {
    constructor() {
        super('Missing NFT on the account');
        this.code = 0x178f;
        this.name = 'MissingNft';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingNftError);
        }
    }
}
exports.MissingNftError = MissingNftError;
createErrorFromCodeLookup.set(0x178f, () => new MissingNftError());
createErrorFromNameLookup.set('MissingNft', () => new MissingNftError());
class MaximumRedeemedAmountError extends Error {
    constructor() {
        super('Current redemeed items is at the set maximum amount');
        this.code = 0x1790;
        this.name = 'MaximumRedeemedAmount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MaximumRedeemedAmountError);
        }
    }
}
exports.MaximumRedeemedAmountError = MaximumRedeemedAmountError;
createErrorFromCodeLookup.set(0x1790, () => new MaximumRedeemedAmountError());
createErrorFromNameLookup.set('MaximumRedeemedAmount', () => new MaximumRedeemedAmountError());
class AddressNotAuthorizedError extends Error {
    constructor() {
        super('Address not authorized');
        this.code = 0x1791;
        this.name = 'AddressNotAuthorized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AddressNotAuthorizedError);
        }
    }
}
exports.AddressNotAuthorizedError = AddressNotAuthorizedError;
createErrorFromCodeLookup.set(0x1791, () => new AddressNotAuthorizedError());
createErrorFromNameLookup.set('AddressNotAuthorized', () => new AddressNotAuthorizedError());
class MissingFreezeInstructionError extends Error {
    constructor() {
        super('Missing freeze instruction data');
        this.code = 0x1792;
        this.name = 'MissingFreezeInstruction';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingFreezeInstructionError);
        }
    }
}
exports.MissingFreezeInstructionError = MissingFreezeInstructionError;
createErrorFromCodeLookup.set(0x1792, () => new MissingFreezeInstructionError());
createErrorFromNameLookup.set('MissingFreezeInstruction', () => new MissingFreezeInstructionError());
class FreezeGuardNotEnabledError extends Error {
    constructor() {
        super('Freeze guard must be enabled');
        this.code = 0x1793;
        this.name = 'FreezeGuardNotEnabled';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, FreezeGuardNotEnabledError);
        }
    }
}
exports.FreezeGuardNotEnabledError = FreezeGuardNotEnabledError;
createErrorFromCodeLookup.set(0x1793, () => new FreezeGuardNotEnabledError());
createErrorFromNameLookup.set('FreezeGuardNotEnabled', () => new FreezeGuardNotEnabledError());
class FreezeNotInitializedError extends Error {
    constructor() {
        super('Freeze must be initialized');
        this.code = 0x1794;
        this.name = 'FreezeNotInitialized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, FreezeNotInitializedError);
        }
    }
}
exports.FreezeNotInitializedError = FreezeNotInitializedError;
createErrorFromCodeLookup.set(0x1794, () => new FreezeNotInitializedError());
createErrorFromNameLookup.set('FreezeNotInitialized', () => new FreezeNotInitializedError());
class MissingFreezePeriodError extends Error {
    constructor() {
        super('Missing freeze period');
        this.code = 0x1795;
        this.name = 'MissingFreezePeriod';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MissingFreezePeriodError);
        }
    }
}
exports.MissingFreezePeriodError = MissingFreezePeriodError;
createErrorFromCodeLookup.set(0x1795, () => new MissingFreezePeriodError());
createErrorFromNameLookup.set('MissingFreezePeriod', () => new MissingFreezePeriodError());
class FreezeEscrowAlreadyExistsError extends Error {
    constructor() {
        super('The freeze escrow account already exists');
        this.code = 0x1796;
        this.name = 'FreezeEscrowAlreadyExists';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, FreezeEscrowAlreadyExistsError);
        }
    }
}
exports.FreezeEscrowAlreadyExistsError = FreezeEscrowAlreadyExistsError;
createErrorFromCodeLookup.set(0x1796, () => new FreezeEscrowAlreadyExistsError());
createErrorFromNameLookup.set('FreezeEscrowAlreadyExists', () => new FreezeEscrowAlreadyExistsError());
class ExceededMaximumFreezePeriodError extends Error {
    constructor() {
        super('Maximum freeze period exceeded');
        this.code = 0x1797;
        this.name = 'ExceededMaximumFreezePeriod';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ExceededMaximumFreezePeriodError);
        }
    }
}
exports.ExceededMaximumFreezePeriodError = ExceededMaximumFreezePeriodError;
createErrorFromCodeLookup.set(0x1797, () => new ExceededMaximumFreezePeriodError());
createErrorFromNameLookup.set('ExceededMaximumFreezePeriod', () => new ExceededMaximumFreezePeriodError());
class ThawNotEnabledError extends Error {
    constructor() {
        super('Thaw is not enabled');
        this.code = 0x1798;
        this.name = 'ThawNotEnabled';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ThawNotEnabledError);
        }
    }
}
exports.ThawNotEnabledError = ThawNotEnabledError;
createErrorFromCodeLookup.set(0x1798, () => new ThawNotEnabledError());
createErrorFromNameLookup.set('ThawNotEnabled', () => new ThawNotEnabledError());
class UnlockNotEnabledError extends Error {
    constructor() {
        super('Unlock is not enabled (not all NFTs are thawed)');
        this.code = 0x1799;
        this.name = 'UnlockNotEnabled';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UnlockNotEnabledError);
        }
    }
}
exports.UnlockNotEnabledError = UnlockNotEnabledError;
createErrorFromCodeLookup.set(0x1799, () => new UnlockNotEnabledError());
createErrorFromNameLookup.set('UnlockNotEnabled', () => new UnlockNotEnabledError());
class DuplicatedGroupLabelError extends Error {
    constructor() {
        super('Duplicated group label');
        this.code = 0x179a;
        this.name = 'DuplicatedGroupLabel';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DuplicatedGroupLabelError);
        }
    }
}
exports.DuplicatedGroupLabelError = DuplicatedGroupLabelError;
createErrorFromCodeLookup.set(0x179a, () => new DuplicatedGroupLabelError());
createErrorFromNameLookup.set('DuplicatedGroupLabel', () => new DuplicatedGroupLabelError());
class DuplicatedMintLimitIdError extends Error {
    constructor() {
        super('Duplicated mint limit id');
        this.code = 0x179b;
        this.name = 'DuplicatedMintLimitId';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DuplicatedMintLimitIdError);
        }
    }
}
exports.DuplicatedMintLimitIdError = DuplicatedMintLimitIdError;
createErrorFromCodeLookup.set(0x179b, () => new DuplicatedMintLimitIdError());
createErrorFromNameLookup.set('DuplicatedMintLimitId', () => new DuplicatedMintLimitIdError());
class UnauthorizedProgramFoundError extends Error {
    constructor() {
        super('An unauthorized program was found in the transaction');
        this.code = 0x179c;
        this.name = 'UnauthorizedProgramFound';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UnauthorizedProgramFoundError);
        }
    }
}
exports.UnauthorizedProgramFoundError = UnauthorizedProgramFoundError;
createErrorFromCodeLookup.set(0x179c, () => new UnauthorizedProgramFoundError());
createErrorFromNameLookup.set('UnauthorizedProgramFound', () => new UnauthorizedProgramFoundError());
class ExceededProgramListSizeError extends Error {
    constructor() {
        super('Exceeded the maximum number of programs in the additional list');
        this.code = 0x179d;
        this.name = 'ExceededProgramListSize';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ExceededProgramListSizeError);
        }
    }
}
exports.ExceededProgramListSizeError = ExceededProgramListSizeError;
createErrorFromCodeLookup.set(0x179d, () => new ExceededProgramListSizeError());
createErrorFromNameLookup.set('ExceededProgramListSize', () => new ExceededProgramListSizeError());
class AllocationNotInitializedError extends Error {
    constructor() {
        super('Allocation PDA not initialized');
        this.code = 0x179e;
        this.name = 'AllocationNotInitialized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AllocationNotInitializedError);
        }
    }
}
exports.AllocationNotInitializedError = AllocationNotInitializedError;
createErrorFromCodeLookup.set(0x179e, () => new AllocationNotInitializedError());
createErrorFromNameLookup.set('AllocationNotInitialized', () => new AllocationNotInitializedError());
class AllocationLimitReachedError extends Error {
    constructor() {
        super('Allocation limit was reached');
        this.code = 0x179f;
        this.name = 'AllocationLimitReached';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AllocationLimitReachedError);
        }
    }
}
exports.AllocationLimitReachedError = AllocationLimitReachedError;
createErrorFromCodeLookup.set(0x179f, () => new AllocationLimitReachedError());
createErrorFromNameLookup.set('AllocationLimitReached', () => new AllocationLimitReachedError());
class AllocationGuardNotEnabledError extends Error {
    constructor() {
        super('Allocation guard must be enabled');
        this.code = 0x17a0;
        this.name = 'AllocationGuardNotEnabled';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AllocationGuardNotEnabledError);
        }
    }
}
exports.AllocationGuardNotEnabledError = AllocationGuardNotEnabledError;
createErrorFromCodeLookup.set(0x17a0, () => new AllocationGuardNotEnabledError());
createErrorFromNameLookup.set('AllocationGuardNotEnabled', () => new AllocationGuardNotEnabledError());
function errorFromCode(code) {
    const createError = createErrorFromCodeLookup.get(code);
    return createError != null ? createError() : null;
}
exports.errorFromCode = errorFromCode;
function errorFromName(name) {
    const createError = createErrorFromNameLookup.get(name);
    return createError != null ? createError() : null;
}
exports.errorFromName = errorFromName;
//# sourceMappingURL=index.js.map